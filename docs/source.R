#############
# Libraries #
#############

library(Matrix)
library(Matrix.utils)
library(colorout)
library(ggplot2)
library(ggpubr)
library(data.table)
library(scales)
library(Seurat)
#library(Signac)
library(GenomeInfoDb)
#library(EnsDb.Hsapiens.v75)
library(patchwork)
library(hdf5r)
library(GenomicRanges)
library(future)
library(dplyr)
library(DoubletFinder)
library(DropletUtils)
library(gplots)
#library(ggVennDiagram)
library(plotly)
library(htmlwidgets)
library(DropletUtils)
library(SingleCellExperiment)
library(scater)
library(celda)
library(ggrepel)
library(glmGamPoi)
library(factoextra)
library(cluster)
library(monocle)
library(velocyto.R)
library(stringr)
library(randomcoloR)
library(mclust)
library(slingshot)
library(RColorBrewer)
library(grid)
library(ggplotify)
library(gridExtra)
library(limma)
library(scCATCH)
library(SCINA)
library(edgeR)
library(TCseq)
library(UpSetR)
library(clusterProfiler)
library(org.Hs.eg.db)
#library(ReactomePA)
library(dynamicTreeCut)
library(DoMultiBarHeatmap)
library(metaRNASeq)
library(ggpointdensity)
library(scico)
library(tximeta)
library(fishpond)
library(tidyverse)
library(colorRamps)
library(pheatmap)
library(harmony)
library(berryFunctions)
library(SeuratWrappers)
library(dbscan)
library(heatmaply)
library(pdist)
library(rsvd)
library(pdftools)
library(flexmix)
library(ks)
library(DESeq2)
library(IHW)
library(garnett)
library(GOSemSim)

#############
# Functions #
#############

# A helper function to generate a split violin plot.
GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin,
                           draw_group = function(self, data, ..., draw_quantiles = NULL) {
  data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
  grp <- data[1, "group"]
  newdata <- plyr::arrange(transform(data, x = if (grp %% 2 == 1) xminv else xmaxv), if (grp %% 2 == 1) y else -y)
  newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
  newdata[c(1, nrow(newdata) - 1, nrow(newdata)), "x"] <- round(newdata[1, "x"])

  if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
    stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <=
      1))
    quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
    aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
    aesthetics$alpha <- rep(1, nrow(quantiles))
    both <- cbind(quantiles, aesthetics)
    quantile_grob <- GeomPath$draw_panel(both, ...)
    ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
  }
  else {
    ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
  }
})


# The main function to generate a split violin plot as part of ggplot.
geom_split_violin <- function(mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ...,
                              draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE,
                              show.legend = NA, inherit.aes = TRUE) {
  layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin,
        position = position, show.legend = show.legend, inherit.aes = inherit.aes,
        params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))
}

#' Produces a user-defined range of Hex color codes for plotting.
#'
#' A helper function that generates Hex color codes for plotting.
#' @param n numeric. The number of colors to generate.
#' @keywords gg_color_hue
#' @return A vector of Hex color codes.
#'
gg_color_hue <- function(n) {
    hues = seq(15, 375, length = n + 1)
    hcl(h = hues, l = 65, c = 100)[1:n]
}


#' Read the QC information generated by the cellranger count pipeline.
#'
#' It locates the file summary.csv of the given folders and reads the information.
#' @param input_folders character. A vector with the named folders where the summary.csv is located. Names serve as the
#'   sample ID.
#' @param correction logical. If TRUE (default), it removes the "," and "%" symbols from the numbers (issue with metrics_summary.csv)
#' @keywords cellrangerQC_reader
#' @return A data frame for metrics_summary.csv with the data of all samples.
#'
cellrangerQC_reader <- function(input_folders,correction=TRUE){

    if(!all(file.exists(
                paste(input_folders,"metrics_summary.csv",sep="")
                ))){
        stop("One or more of the summary.csv files is not located in that input_folder")
    }


    sampleIDs<-names(input_folders)
    if(is.null(sampleIDs)){
        stop("Provide names to the input_folders")
    }
    if(length(sampleIDs)<length(input_folders)){
        stop("Provide names to all input_folders entries")
    }
    
    x<-as.list(rep(0,length(input_folders)))
    for(i in 1:length(input_folders)){
	a<-read.table(paste(input_folders[i],"metrics_summary.csv",sep=""),sep=",",header=T)
	cc<-colnames(a)
	if(correction){
	    a<-as.matrix(a)
	    a<-data.frame(matrix(gsub("[%,]","",a),nrow=1))
	    colnames(a)<-cc
	}

        x[[i]]<-cbind(Sample=sampleIDs[i],a)
    }
    x<-do.call(rbind,x)
    for(i in 2:ncol(x)){
	x[,i]<-as.numeric(as.character(x[,i]))
    }   

  return(x)
}



#' Read the QC information generated by the Kallisto pipeline.
#'
#' It locates the file run_info.json of the given folders and reads the information.
#' @param input_folders character. A vector with the named folders where the run_info.json is located. Names serve as the
#'   sample ID.
#' @keywords KallistoQC_reader
#' @return A data frame for run_info.json with the data of all samples.
#'
KallistoQC_reader<-function(input_folders){

   if(!all(file.exists(
                paste(input_folders,"run_info.json",sep="")
                ))){
        stop("One or more of the run_info.json files is not located in that input_folder")
    }


    sampleIDs<-names(input_folders)
    if(is.null(sampleIDs)){
        stop("Provide names to the input_folders")
    }
    if(length(sampleIDs)<length(input_folders)){
        stop("Provide names to all input_folders entries")
    }

    x<-as.list(rep(0,length(input_folders)))
    for(i in 1:length(input_folders)){
        a<-scan(paste(input_folders[i],"run_info.json",sep=""),what="character",sep="\t")
        a<-a[c(grep("p_pseudoaligned:",a),grep("p_unique:",a))]
        a<-t(matrix(unlist(strsplit(a,":",fixed=T)),nrow=2))
        a[,2]<-str_replace(a[,2],",","")
        cc<-a[,1]
        a<-matrix(as.numeric(as.character(a[,2])),nrow=1)
        a<-data.frame(a)
        colnames(a)<-cc
        x[[i]]<-cbind(Sample=sampleIDs[i],a)
    }
    x<-do.call(rbind,x)
    for(i in 2:ncol(x)){
        x[,i]<-as.numeric(as.character(x[,i]))
    }

  return(x)
}





#' Read the QC information generated by the STARsolo pipeline.
#'
#' It locates the file Summary.csv of the given folders and reads the information.
#' @param input_folders character. A vector with the named folders where the Summary.csv is located. Names serve as the
#'   sample ID.
#' @keywords STARsoloQC_reader
#' @return A data frame for Summary.csv with the data of all samples.
#'
STARsoloQC_reader<-function(input_folders){

   if(!all(file.exists(
                paste(input_folders,"Summary.csv",sep="")
                ))){
        stop("One or more of the Summary.csv files is not located in that input_folder")
    }


    sampleIDs<-names(input_folders)
    if(is.null(sampleIDs)){
        stop("Provide names to the input_folders")
    }
    if(length(sampleIDs)<length(input_folders)){
        stop("Provide names to all input_folders entries")
    }

    x<-as.list(rep(0,length(input_folders)))
    for(i in 1:length(input_folders)){
        a<-read.table(paste(input_folders[i],"Summary.csv",sep=""),sep=",",header=F)
	a<-t(a)
	cc<-a[1,]
	a<-matrix(as.numeric(as.character(a[-1,])),nrow=1)
	for(j in 1:ncol(a)){
	   if(a[1,j]<=1){
		a[1,j]<-100*a[1,j]
	   }
	}
	a<-data.frame(a)
	colnames(a)<-cc
        x[[i]]<-cbind(Sample=sampleIDs[i],a)
    }
    x<-do.call(rbind,x)
    for(i in 2:ncol(x)){
        x[,i]<-as.numeric(as.character(x[,i]))
    }
    
  return(x)
}





#' Produces the plots of the Sequencing section of STARsolo QC.
#'
#' It plots the metrics of the Sequencing section of STARsolo QC from the
#'   Summary.csv data. It is similar to the cellrangerQC_SequencingPlot().
#' @param x data.frame. The summary data frame components of STARsoloQC_reader().
#' @param outdir character. A folder to store the plots.
#' @param fname character. A filename for the stored plot. If NULL (default), the filename is automatically chosen.
#' @keywords STARsoloQC_SequencingPlot
#' @return A set of barplots.
#'
STARsoloQC_SequencingPlot <- function(x,outdir,fname=NULL){

    p1<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Number of Reads")],
                                     text="Number of Reads",color="#00B0F6",legend="Number of Reads",
                                     add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                                     interactive=FALSE)

    p2<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Reads With Valid Barcodes")],
                                     text="Percentage of Valid Barcodes",color="#F8766D",legend="Percentage of Valid Barcodes",
                                     add.line=TRUE,grouped.style=FALSE,cutoff=75,cutoff.text=NULL,
                                     interactive=FALSE)

    p3<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Sequencing Saturation")],
                                     text="Sequncing Saturation",color="#FFA372",legend="Sequncing Saturation",
                                     add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                                     interactive=FALSE)

    yy<-c("Q30 Bases in CB+UMI","Q30 Bases in RNA read")
    cols<-c("#523906","#535204")
    ll<-c("% of Q30 Bases in CB+UMI","% of Q30 Bases in RNA Reads")
    cuts<-c(-100,-100)
    mm<-match(yy,colnames(x),nomatch=0)
    yy<-colnames(x)[mm]
    cols<-cols[mm>0]
    ll<-ll[mm>0]
    cuts<-cuts[mm>0]
    p4<-cellrangerQC_barplot(data=x,x="Sample",y=yy,
                             text="Percent",color=cols,
                             legend=ll,
                             add.line=TRUE,grouped.style=TRUE,cutoff=cuts,cutoff.text=NULL,
                             interactive=FALSE)

    if(is.null(fname)){
	fname<-paste(x$Sample,collapse="_")
    }
    pnoninteractive<-list(p1,p2,p3,p4)
    pdf(paste(outdir,"STARsoloQC_sequencing_",fname,".pdf",sep=""))
        print(p1)
        print(p2)
        print(p3)
        print(p4)
    dev.off()

    # message
    print(paste("Download plot: ",outdir,"STARsoloQC_sequencing_",fname,".pdf",sep=""))

 return(pnoninteractive)
}




#' Helper for the generation of the interactive and non-interactive plots.
#'
#' Helper for the generation of the interactive and non-interactive plots.
#' @param data data frame. A data frame with the values to be plotted.
#' @param x formula or numeric. In the interactive plots, it takes a formula expressin of the column to be used in the x-axis of the plot. In the non-interactive
#'   plots, it is a the values of a particular column.
#' @param y formula or numeric. In the interactive plots, it takes a formula expressin of the column to be used in the y-axis of the plot. In the non-interactive
#'   plots, it is a the values of a particular column. 
#' @param text character. A text to display upon mouse over on the interactive plot or on the y-axis of the group-style non-interactive plot.
#' @param color character. The barplot colors.
#' @param legend character. The plot legends.
#' @param add.line logical. If TRUE, it adds a horizontal cutoff.
#' @param grouped.style logical. If TRUE, it generated a grouped barplot.
#' @param cutoff numeric. The cutoffs to be plotted as horizontal lines.
#' @param cutoff.text character. A text describing the cutoff in the interactive plots.
#' @param interactive logical. If TRUE, it generates an interactive plotly barplor otherwise a non-interactive ggplot2 barplot.
#' @keywords cellrangerQC_barplot
#' @return A series of barplots.
#'
cellrangerQC_barplot<-function(data,x,y,text,color,legend,add.line,grouped.style,cutoff,cutoff.text,interactive){

    a <- list(
        title = "Sample",
        showticklabels = TRUE,
        tickmode= "array",
        ticktext = unique(data$Sample),
        tickvals = c(1:length(unique(data$Sample))))
    
    # type 1: !add.line & !grouped.style
    if(!add.line & !grouped.style & interactive){
	p<-plot_ly(data=data,
                    x=x,
                    y=y,
                    type="bar",
                    text=rep(text,length(unique(data$Sample))),
                    marker = list(color = color),
                    name=legend) %>% layout(yaxis = list(title = legend))
    }

    if(!add.line & !grouped.style & !interactive){
	p<- ggplot(data,aes(x=x,y=y,fill=x)) +
            geom_bar(stat = "identity",position=position_dodge(),fill=color) +
            labs(y=text,x="Sample ID") +
            geom_text(aes(label=y), position=position_dodge(width=0.9), vjust=1.2)
	    scale_y_continuous(limits=c(0,max(y,100,na.rm=T)))	
    }


    # type 2: add.line & !grouped.style
    if(add.line & !grouped.style & interactive){
	p<-plot_ly(data=data)
        p<-p %>% add_trace(
                    x=x,
                    y=y,
                    type="bar",
                    text=rep(text,length(unique(data$Sample))),
                    marker = list(color = color),
                    name=legend) %>% layout(yaxis = list(title = legend))
        p<-p %>% add_segments(x = 0.5,xend = length(unique(data$Sample))+0.5, y = cutoff, yend = as.formula(paste("~",cutoff)),text=cutoff.text,line = list(dash = "dash",color="black"),showlegend=FALSE) %>%
                   layout(xaxis=a)
    }

    if(add.line & !grouped.style & !interactive){
    	p<-ggplot(data,aes(x=x,y=y,fill=x)) +
           geom_bar(stat = "identity",position=position_dodge(),fill=color) +
           labs(y=text,x="Sample ID") +
           geom_hline(yintercept=cutoff, linetype="dashed", color = "black") +
           geom_text(aes(label=y), position=position_dodge(width=0.9), vjust=1.2) +
           scale_y_continuous(breaks = sort(c(seq(0, max(y,100,na.rm=T), length.out=5), cutoff)),limits=c(0,max(y,100,na.rm=T)))
    }


    # type 3: add.line & grouped.style
    if(add.line & grouped.style & interactive){
        p<-plot_ly(data=data,
                   x=x,
                   y=y[[1]],
                   text=rep(text[1],length(unique(data$Sample))),
                   type="bar",
                   marker = list(color = color[1]),
                   name=legend[1]) %>% layout(yaxis = list(title = "Percentage"))
        for(i in 2:length(y)){
            p<-p %>% add_trace(
			y=y[[i]],
			text=rep(text[i],length(unique(data$Sample))),
			marker = list(color = color[i]),
			name=legend[i])
        }
        p<-p %>% add_segments(x = 0.5,xend = 2.5, y = 65, yend = ~65,text="HQ (RNA reads) > 65%",line = list(dash = "dash",color="black"),showlegend=FALSE) %>%
                   layout(xaxis=a)


    }

    if(add.line & grouped.style & !interactive){
	data2<-cbind(as.matrix(data[,which(colnames(data)==x | colnames(data)==y[1])]),rep(y[1],nrow(data)))
	for(i in 2:length(y)){
	    data2<-rbind(data2,cbind(as.matrix(data[,which(colnames(data)==x | colnames(data)==y[i])]),rep(y[i],nrow(data))))
    	}
	data2<-data.frame(data2)
	colnames(data2)<-c("Sample","Value","Type")
	data2$Sample<-factor(data2$Sample)
	data2$Sample<-factor(data2$Sample,levels=unique(data2$Sample))
	data2$Type<-factor(data2$Type)
	data2$Type<-factor(data2$Type,levels=unique(data2$Type))
	data2$Value<-as.numeric(as.character(data2$Value))
 	p<-ggplot(data2,aes(x=Sample,y=Value,fill=Type)) +
           geom_bar(stat = "identity",position=position_dodge(),color="black") +
           labs(y=text,x="Sample ID") +
           geom_hline(yintercept=cutoff, linetype="dashed", color = color) +
           geom_text(aes(label=Value), position=position_dodge(width=0.9), vjust=1.2) +
           scale_y_continuous(breaks = sort(c(seq(0, max(data2$Value,100,na.rm=T), length.out=5), cutoff)),limits=c(0,max(data2$Value,100,na.rm=T)))   	
	p<-p+scale_fill_manual(values=color,labels=legend)
    }


    # type 4: !add.line & grouped.style
    if(!add.line & grouped.style & interactive){
        p<-plot_ly(data=data,
                   x=x,
                   y=y[[1]],
                   text=rep(text[1],length(unique(data$Sample))),
                   type="bar",
                   marker = list(color = color[1]),
                   name=legend[1]) %>% layout(yaxis = list(title = "Percentage"))
        for(i in 2:length(y)){
            p<-p %>% add_trace(
                        y=y[[i]],
                        text=rep(text[i],length(unique(data$Sample))),
                        marker = list(color = color[i]),
                        name=legend[i])
        }
	p<- p %>% layout(xaxis=a)
    }

    if(!add.line & grouped.style & !interactive){
        data2<-cbind(as.matrix(data[,which(colnames(data)==x | colnames(data)==y[1])]),rep(y[1],nrow(data)))
        for(i in 2:length(y)){
            data2<-rbind(data2,cbind(as.matrix(data[,which(colnames(data)==x | colnames(data)==y[i])]),rep(y[i],nrow(data))))
        }
        data2<-data.frame(data2)
        colnames(data2)<-c("Sample","Value","Type")
        data2$Sample<-factor(data2$Sample)
        data2$Sample<-factor(data2$Sample,levels=unique(data2$Sample))
        data2$Type<-factor(data2$Type)
        data2$Type<-factor(data2$Type,levels=unique(data2$Type))
        data2$Value<-as.numeric(as.character(data2$Value))
        p<-ggplot(data2,aes(x=Sample,y=Value,fill=Type)) +
           geom_bar(stat = "identity",position=position_dodge(),color="black") +
           labs(y=text,x="Sample ID") +
           geom_text(aes(label=Value), position=position_dodge(width=0.9), vjust=1.2) +
           scale_y_continuous(limits=c(0,max(data2$Value,100,na.rm=T)))
        p<-p+scale_fill_manual(values=color,labels=legend)
    }


  return(p)
}




#' Produces the plots of the Sequencing section of cellranger QC.
#'
#' It plots the metrics of the Sequencing section of cellranger QC from the 
#'   metrics_summary.csv data. It compares the the following metrics across samples: 
#'   Number of reads, Percentage of valid barcodes, Sequencing saturation, Q30 bases 
#'   in Barcodes, RNA reads, Sample Index and UMIs. The horizontal lines indicate 
#'   cutoffs suggested in the 10x cellranger manual.
#' @param x data.frame. The summary data frame components of cellrangerQC_reader().
#' @param type character. If Interactive, it creates an interactive plotly figure. If Non-interactive, it creates a non-interactive ggplot2 figure.
#'   Default is Both that creates both options.  
#' @param outdir character. A folder to store the plots.
#' @param fname character. A filename for the stored plot. If NULL (default), the filename is automatically chosen.
#' @keywords cellrangerQC_SequencingPlot
#' @return A set of barplots.
#'
cellrangerQC_SequencingPlot <- function(x,outdir,fname=NULL,type="Both"){

    if(type!="Interactive" & type!="Noninteractive" & type!="Both"){
	stop("Parameter type should be one of Interactive, Noninteractive or Both.")
    }

    pinteractive<-pnoninteractive<-NULL
    if(type=="Interactive" | type=="Both"){
	
	a <- list(
        title = "Sample",
        showticklabels = TRUE,
        tickmode= "array",
        ticktext = unique(x$Sample),
        tickvals = c(1:length(unique(x$Sample)))
        )

	p1<-cellrangerQC_barplot(data=x,x=as.formula("~Sample"),y=as.formula("~Number.of.Reads"),
				 text="Reads",color="#00B0F6",legend="Number of Reads",
				 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
				 interactive=TRUE)

	p2<-cellrangerQC_barplot(data=x,x=as.formula("~as.numeric(factor(data$Sample))"),y=as.formula("~Valid.Barcodes"),
                                 text="Barcodes",color="#F8766D",legend="% of Valid Barcodes",
                                 add.line=TRUE,grouped.style=FALSE,cutoff=75,cutoff.text="HQ > 75%",
                                 interactive=TRUE)	

	p3<-cellrangerQC_barplot(data=x,x=as.formula("~Sample"),y=as.formula("~Sequencing.Saturation"),
                                 text="Saturation",color="#FFA372",legend="Sequencing Saturation",
                                 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                                 interactive=TRUE)
	
	p4<-cellrangerQC_barplot(data=x,x=as.formula("~as.numeric(factor(data$Sample))"),
				 y=list(as.formula("~Q30.Bases.in.Barcode"),as.formula("~Q30.Bases.in.RNA.Read"),as.formula("~Q30.Bases.in.Sample.Index"),as.formula("~Q30.Bases.in.UMI")),
                                 text=c("Barcodes","RNA","SI","UMI"),
				 color=c("#523906","#535204","#62760C","#CDB30C"),
				 legend=c("% of Q30 Bases in Barcode","% of Q30 Bases in RNA Reads","% of Q30 Bases in Sample Index","% of Q30 Bases in UMI"),
                                 add.line=TRUE,grouped.style=TRUE,cutoff=65,cutoff.text="HQ (RNA) > 65%",
                                 interactive=TRUE)

	pinteractive<-subplot(p1,p2,p3,p4,nrows=2)
	saveWidget(pinteractive,paste(outdir,"cellrangerQC_sequencing.html",sep=""),selfcontained = FALSE)

	# message	
	print(paste("Download plot: ",outdir,"cellrangerQC_sequencing*",sep=""))
	
    }

    if(type=="Noninteractive" | type=="Both"){

	p1<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Number.of.Reads")],
                                 text="Number of Reads",color="#00B0F6",legend="Number of Reads",
                                 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                                 interactive=FALSE)
	
	p2<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Valid.Barcodes")],
                                 text="Percentage of Valid Barcodes",color="#F8766D",legend="Percentage of Valid Barcodes",
                                 add.line=TRUE,grouped.style=FALSE,cutoff=75,cutoff.text=NULL,
                                 interactive=FALSE)

        p3<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Sequencing.Saturation")],
                                 text="Sequencing Saturation",color="#FFA372",legend="Sequncing Saturation",
                                 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                                 interactive=FALSE)
	

	yy<-c("Q30.Bases.in.Barcode","Q30.Bases.in.RNA.Read","Q30.Bases.in.Sample.Index","Q30.Bases.in.UMI")
	cols<-c("#523906","#535204","#62760C","#CDB30C")
	ll<-c("% of Q30 Bases in Barcode","% of Q30 Bases in RNA Reads","% of Q30 Bases in Sample Index","% of Q30 Bases in UMI")
	cuts<-c(-100,-100,65,-100)
	mm<-match(yy,colnames(x),nomatch=0)
	yy<-colnames(x)[mm]
	cols<-cols[mm>0]
	ll<-ll[mm>0]
	cuts<-cuts[mm>0]
	p4<-cellrangerQC_barplot(data=x,x="Sample",y=yy,
                                 text="Percent",color=cols,
				 legend=ll,
                                 add.line=TRUE,grouped.style=TRUE,cutoff=cuts,cutoff.text=NULL,
                                 interactive=FALSE)

	if(is.null(fname)){
	   fname<-paste(x$Sample,collapse="_")
	}	
	pnoninteractive<-list(p1,p2,p3,p4)
    	pdf(paste(outdir,"cellrangerQC_sequencing_",fname,".pdf",sep=""))
            print(p1)
            print(p2)
            print(p3)
            print(p4)
    	dev.off()

	# message       
        print(paste("Download plot: ",outdir,"cellrangerQC_sequencing_",fname,".pdf",sep=""))

    }


  return(list(Interactive=pinteractive,Noninteractive=pnoninteractive))
}



#' Reads the generated data of the Kallisto-Bus pipeline.
#'
#' Reads the generated data of the Kallisto-Bus pipeline in order to generate the raw UMI matrix.
#' @param dir character. The directory of the data.
#' @param umi_name character. The name of the file to retrieve. Default is cells_x_genes.
#' @param gene_name character. The name of the file to retrieve. Default is cells_x_genes.genes.
#' @param barcode_name character. The name of the file to retrieve. Default is cells_x_genes.barcodes.
#' @keywords read_count_output
#' @return The UMI matrix
#'
read_count_output <- function(dir, umi_name="cells_x_genes",gene_name="cells_x_genes.genes",barcode_name="cells_x_genes.barcodes") {
  dir <- normalizePath(dir, mustWork = TRUE)
  m <- readMM(paste0(dir, "/", umi_name, ".mtx"))
  m <- Matrix::t(m)
  m <- as(m, "dgCMatrix")
  # The matrix read has cells in rows
  ge <- ".genes.txt"
  genes <- readLines(file(paste0(dir, "/", gene_name, ".txt")))
  barcodes <- readLines(file(paste0(dir, "/", barcode_name, ".txt")))
  colnames(m) <- barcodes
  rownames(m) <- genes
  return(m)
}


#' Generate the knee plot of Kallisto-Bus.
#'
#' Generate the knee plot of Kallisto-Bus.
#' @param mat data frame. The UMI data. Typically, the output of read_count_output().
#' @param filter.cut numeric. A library size cutoff that removes sample with less than filter.cut counts. Defaut is 0.
#' @keywords get_knee_df
#' @return A tibble matrix
#'
get_knee_df <- function(mat,filter.cut=0) {
  total <- rank <- NULL
  tibble(total = Matrix::colSums(mat),
         rank = row_number(desc(total))) %>%
    distinct() %>%
    dplyr::filter(total > filter.cut) %>% 
    arrange(rank)
}



#' Get the inflection point for the knee plot of Kallisto-Bus.
#'
#' Get the inflection point for the knee plot of Kallisto-Bus.
#' @param df data frame. The output of get_knee_df().
#' @param sampleID character. An ID to be used in the Knee plot filename.
#' @param outdir character. The folder to store Kallisto's Knee plot.
#' @param lower numeric. A cutoff of the least expressed samples. Default is 100.
#' @keywords get_inflection
#' @return A number indicating the inflection point.
#'
get_inflection <- function(df, sampleID, outdir, lower = 100) {
  log_total <- log_rank <- total <-  NULL
  df_fit <- df %>% 
    dplyr::filter(total > lower) %>% 
    transmute(log_total = log10(total),
              log_rank = log10(rank))
  d1n <- diff(df_fit$log_total)/diff(df_fit$log_rank)
  right.edge <- which.min(d1n)
  inf<-10^(df_fit$log_total[right.edge])

  p<-knee_plot(df,inf)
  
  #message
  print(paste("Download plot: ",outdir,"KneePlot_KallistoPipeline_",sampleID,".pdf",sep=""))

  pdf(paste(outdir,"KneePlot_KallistoPipeline_",sampleID,".pdf",sep=""))
  	print(p)
  dev.off()

  return(inf)
}



#' Generates the Knee plot of Kallisto-Bus.
#'
#' Generates the Knee plot of Kallisto-Bus.
#' @param df data frame. The output of get_knee_df().
#' @param inflection numeric. The output of get_inflection().
#' @keywords knee_plot
#' @return A ggplot.
#'
knee_plot <- function(df, inflection) {
  total <- rank_cutoff <- NULL
  annot <- tibble(inflection = inflection,
                  rank_cutoff = max(df$rank[df$total > inflection]))
  ggplot(df, aes(total, rank)) +
    geom_path() +
    geom_vline(aes(xintercept = inflection), data = annot, linetype = 2, 
               color = "gray40") +
    geom_hline(aes(yintercept = rank_cutoff), data = annot, linetype = 2, 
               color = "gray40") +
    geom_text(aes(inflection, rank_cutoff, 
                  label = paste(rank_cutoff, "'cells'")),
              data = annot, vjust = 1) +
    scale_x_log10() +
    scale_y_log10() +
    labs(y = "Rank", x = "Total UMIs") +
    annotation_logticks()
}




#' Produces the plots of the Cells section of cellranger QC.
#'
#' It plots the metrics of the Cells section of cellranger QC from the metrics_summary.csv.
#'   It compares the following metrics across samples: Estimated number of cells,
#'   median UMI counts per cell, median genes per cell and total genes detected. The horizontal 
#'   lines indicate cutoffs suggested in the 10x cellranger manual.
#' @param x data.frame. The summary data frame component of cellrangerQC_reader().
#' @param type character. If Interactive, it creates an interactive plotly figure. If Non-interactive, it creates a non-interactive ggplot2 figure.
#'   Default is Both that creates both options. 
#' @param outdir character. A folder to store the plots.
#' @param fname character. A filename for the stored plot. If NULL (default), the filename is automatically chosen.
#' @keywords cellrangerQC_CellsPlot
#' @return A set of barplots.
#'
cellrangerQC_CellsPlot <- function(x,outdir,fname=NULL,type="Both"){

    if(type!="Interactive" & type!="Noninteractive" & type!="Both"){
        stop("Parameter type should be one of Interactive, Noninteractive or Both.")
    }

    pinteractive<-pnoninteractive<-NULL
    if(type=="Interactive" | type=="Both"){

        a <- list(
        title = "Sample",
        showticklabels = TRUE,
        tickmode= "array",
        ticktext = unique(x$Sample),
        tickvals = c(1:length(unique(x$Sample)))
        )

        p1<-cellrangerQC_barplot(data=x,x=as.formula("~as.numeric(factor(data$Sample))"),y=as.formula("~Estimated.Number.of.Cells"),
                                 text="Cells",color="#00B0F6",legend="Number of Cells",
                                 add.line=TRUE,grouped.style=FALSE,cutoff=500,cutoff.text="HQ > 500",
                                 interactive=TRUE)

	p2<-cellrangerQC_barplot(data=x,x=as.formula("~Sample"),y=as.formula("~Median.UMI.Counts.per.Cell"),
                                 text="UMI/cell",color="#F8766D",legend="Median UMI/cell",
                                 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text="",
                                 interactive=TRUE)

	p3<-cellrangerQC_barplot(data=x,x=as.formula("~Sample"),y=as.formula("~Median.Genes.per.Cell"),
                                 text="Genes/cell",color="#FFA372",legend="Median Genes/cell",
                                 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text="",
                                 interactive=TRUE)

	p4<-cellrangerQC_barplot(data=x,x=as.formula("~Sample"),y=as.formula("~Total.Genes.Detected"),
                                 text="Genes",color="#CDB30C",legend="Number of Genes",
                                 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text="",
                                 interactive=TRUE)

	pinteractive<-subplot(p1,p2,p3,p4,nrows=2)
        saveWidget(pinteractive,paste(outdir,"cellrangerQC_cells.html",sep=""),selfcontained = FALSE)
 
	# message       
        print(paste("Download plot: ",outdir,"cellrangerQC_cells*",sep=""))
   
    }

    if(type=="Noninteractive" | type=="Both"){

    	p1<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Estimated.Number.of.Cells")],
                                 text="Number of Cells",color="#00B0F6",legend="Number of Cells",
                                 add.line=TRUE,grouped.style=FALSE,cutoff=500,cutoff.text=NULL,
                                 interactive=FALSE)

	p2<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Median.UMI.Counts.per.Cell")],
                                 text="Median UMI/cell",color="#F8766D",legend="Median UMI/cell",
                                 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                                 interactive=FALSE)

        p3<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Median.Genes.per.Cell")],
                                 text="Median Genes/cell",color="#FFA372",legend="Median Genes/cell",
                                 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                                 interactive=FALSE)

	p4<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Total.Genes.Detected")],
                                 text="Number of Genes",color="#CDB30C",legend="Number of Genes",
                                 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                                 interactive=FALSE)

	if(is.null(fname)){
	   fname<-paste(x$Sample,collapse="_")
	}
	pnoninteractive<-list(p1,p2,p3,p4)
    	pdf(paste(outdir,"cellrangerQC_cells_",fname,".pdf",sep=""))
            print(p1)
            print(p2)
            print(p3)
            print(p4)
    	dev.off()

	# message       
        print(paste("Download plot: ",outdir,"cellrangerQC_cells_",fname,".pdf",sep=""))

    }

  return(list(Interactive=pinteractive,Noninteractive=pnoninteractive))
}



#' Produces the plots of the Cells section of STARsolo QC.
#'
#' It plots the metrics of the Cells section of STARsolo QC from the Summary.csv.
#'   It is similar to the cellrangerQC_CellsPlot().
#' @param x data.frame. The summary data frame component of STAsoloQC_reader().
#' @param outdir character. A folder to store the plots.
#' @param fname character. A filename for the stored plot. If NULL (default), the filename is automatically chosen.
#' @keywords STARsoloQC_CellsPlot
#' @return A set of barplots.
#'
STARsoloQC_CellsPlot <- function(x,outdir,fname=NULL){

    p1<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Estimated Number of Cells")],
                              text="Number of Cells",color="#00B0F6",legend="Number of Cells",
                              add.line=TRUE,grouped.style=FALSE,cutoff=500,cutoff.text=NULL,
                              interactive=FALSE)

     p2<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Median UMI per Cell")],
                              text="Median UMI/cell",color="#F8766D",legend="Median UMI/cell",
                              add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                              interactive=FALSE)

     p3<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Median Gene per Cell")],
                              text="Median Genes/cell",color="#FFA372",legend="Median Genes/cell",
                              add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                              interactive=FALSE)

     p4<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Total Gene Detected")],
                              text="Number of Genes",color="#CDB30C",legend="Number of Genes",
                              add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                              interactive=FALSE)

     if(is.null(fname)){
	fname<-paste(x$Sample,collapse="_")
     }
     pnoninteractive<-list(p1,p2,p3,p4)
     pdf(paste(outdir,"STARsoloQC_cells_",fname,".pdf",sep=""))
         print(p1)
         print(p2)
         print(p3)
         print(p4)
     dev.off()

     # message
     print(paste("Download plot: ",outdir,"STARsoloQC_cells_",fname,".pdf",sep=""))

return(pnoninteractive)
}





#' It merges the summary metrics of different cellranger runs.
#'
#' It merges the summary metrics of different cellranger runs into a joint data frame for plotting.
#' @param data list. A list of data.frames generated by the cellrangerQC_reader() function.
#' @keywords merge_cellrangerQC_reader
#' @return A data.frame with the metrics of all runs.
#'
merge_cellrangerQC_reader<-function(data){
    
    if(length(data)<2){
        stop("Parameter data must be a list of length >2.")
    }
    if(!is.list(data)){
        stop("Parameter data must be a list of length >2.")
    }
    
    ll<-lapply(data,colnames)
    ull<-unique(unlist(ll))
    
    for(i in 1:length(data)){
        cc<-setdiff(ull,ll[[i]])
        if(length(cc)==0){
            data[[i]]<-data[[i]][,match(ull,ll[[i]])]
        } else {
            data[[i]]<-cbind(data[[i]],0)
            colnames(data[[i]])<-c(ll[[i]],cc)
            data[[i]]<-data[[i]][,match(ull,colnames(data[[i]]))]
        }
    }
    dat<-do.call(rbind,data)
  return(dat)
}




#' Reads and annotates the Alevin generated counts.
#'
#' Reads and annotates the Alevin generated counts. It locates the quants_mat.gz output of Alevin's pipeline and  reformats
#'   them in a data frame. It uses a preformated annotation file containing the Ensembl and Gencode hg19 and GRCh38 transcript
#'   and gene ID, as well as their biotypes, and converts the rownames (gene IDs) of the matrix.mtx in the form EnsemblID:GeneName.
#'   Finally, it constructs an informative feature.names slot witht the detailed gene annotation.
#' @param input_folder character. A vector with the named folders where the quants_mat.gz is located. Names serve as the sample ID.
#' @param hto_folder character. A vector with the named folders where the matrix.mtx.gz, features.tsv.gz and barcodes.tsv.gz of the
#'   hashtags are located. The user also needs to store on that location the HTO design table to associate each HTO with hashtag experimental
#'   information. The first column of the matrix should contain the hashtags as found n the feature matrix (not necessarily in that order).
#'   The hto_folder names should match the names of the input_folder (to associate the two). Default is NULL (no hashtag data / protocol).
#' @param tx2genes character. The location of the gene annotation file. Columns 1-2 contain the Ensembl transcript IDs (ENST_dot, ENST_nodot),
#'   columns 3-4 the Ensembl gene IDs (ENSG_dot, ENSG_nodot), column 5 the gene names (GeneName), column 6 the biotype (BioType)
#'   and columns 7-8 the reference genome ID (Ref: GRCh37 or GRCh38) and the annotation type  (DB: Gencode or Ensembl). The other columns specify
#'   the genes that are reported as TFs (PMID:29425488) and Epigenetic factors (PMID:26153137).
#' @param default_annotation character. The annotataion that has been used in the cellranger pipeline to produce the results.
#'   It will mainly consider those IDs from the annotation file. If some genes of the matrix.mtx are (not present in the annotataion
#'   file, the algorithm will perform a global annotataion search using the entris of all annotation types. Currently, the possible
#'   values must be one of: 'GRCh37_Gencode', 'GRCh38_Gencode', 'GRCh37_Ensembl' and 'GRCh38_Ensembl'.
#' @param umi.design data frame. One or more characteristics of the cells. Default is NULL.
#' @param hto.design data frame. If HTOs are used, a data.frame associating the HTOs to experimental conditions. The first column
#'   must specify the HTO ID and the rest of the columns the Condition, Time of Experiment and any other relevant information
#'   present. Default is NULL.
#' @param column character. The column of the annotation file that matches the original rownames of the matrix.mtx (to update the
#'   rownames in the appropriate form). Default is column="ENSG_nodot" that uses the Ensembl gene IDs without the '.x' symbol at the end.
#'   Other options are ENSG_dot and GeneName depending on the dataset.
#' @param hto_barcode_correction logical. If TRUE (default), the '-1' symbol is added at the end of the hto barcodes to match with the
#'   barcodes of the UMI count data.
#' @param hto_feature_correction logical. If TRUE (default), the -<<barcode>> extension is removed from the end of the hto features.
#' @param include.names logical. If TRUE (default), it looks for the GeneNames column in tx2genes matrix and builds the final
#'   gene annotation.
#' @keywords readAlevinRNAs
#' @return A list with the reformatted Alevin counts data and annotation for each sample. If available the hashtag data are added
#'   to the components of the list.
#'
readAlevinRNAs<-function(input_folder,hto_folder,tx2genes,default_annotation,umi.design=NULL,hto.design=NULL,
                      column="ENSG_nodot",hto_barcode_correction=TRUE,hto_feature_correction=TRUE,include.names=TRUE){
    
    if(is.null(names(input_folder))){
         stop("Parameter input_folder should be named vector. The names are to be used as sampleIDs!")
    }
     
    if(!is.null(hto_folder)){
        if(is.null(names(hto_folder))){
             stop("Parameter hto_folder should be named vector. The names are to be used as sampleIDs!")
        }
         
        if(is.null(hto.design)){
             stop("Parameter hto.design must be specified.")
        }
         
        ide<-identical(sort(names(input_folder)),sort(names(hto_folder)))
        if(!ide){
            stop("The names of the input_folder and hto_folder must be identical")
        }
        sl<-sort.list(names(hto_folder))
        hto_folder<-hto_folder[sl]
    }
    sl<-sort.list(names(input_folder))
    input_folder<-input_folder[sl]

    tx2genes<-read.table(tx2genes,sep="\t",header=T)
    data<-hto_data<-as.list(rep(0,length(input_folder)))
    names(data)<-names(hto_data)<-names(input_folder)
    
    for(i in 1:length(input_folder)){
        
	se <- tximeta(paste(input_folder[i],"quants_mat.gz",sep=""), type="alevin", alevinArgs=list(filterBarcodes=TRUE))
    	sce <- as(se, "SingleCellExperiment")
        mat <- counts(sce)
        feature.names <- data.frame(V1=rownames(mat))
        barcode.names <- data.frame(V1=colnames(mat))
        
        keepHTO_barcodes<-NULL
        keepData_barcodes<-barcode.names$V1


        if(!is.null(hto_folder)){
            htomat<-readMM(paste(hto_folder[i],"matrix.mtx.gz",sep=""))
            htofeature.names <- read.delim(paste(hto_folder[i],"features.tsv.gz",sep=""),header = FALSE,stringsAsFactors = FALSE)
            htobarcode.names <- read.delim(paste(hto_folder[i],"barcodes.tsv.gz",sep=""),header = FALSE,stringsAsFactors = FALSE)
            
            keepHTO_barcodes<-htobarcode.names
            mm<-match(as.character(hto.design[,1]),as.character(htofeature.names$V1),nomatch=0)
            if(length(mm[mm==0])>0){
                stop("The hashtag IDs of the design and the feature tables should match.")
            }

            if(hto_barcode_correction){
                htobarcode.names<-apply(htobarcode.names,1,paste,"-1",sep="")
                htobarcode.names<-data.frame(htobarcode.names)
                colnames(htobarcode.names)<-"V1"
            }
            colnames(htomat) <- htobarcode.names$V1
            rownames(htomat) <- htofeature.names$V1

            common.barcodes <- intersect(colnames(mat), colnames(htomat))
            mat <- mat[, match(common.barcodes,colnames(mat))]
            barcode.names<-data.frame(common.barcodes)
            htomat <- htomat[, match(common.barcodes,colnames(htomat))]
            
            hto_data[[i]]<-htomat
            w<-which(rownames(hto_data[[i]])=="unmapped")
            if(length(w)>0){
                hto_data[[i]]<-hto_data[[i]][-w,]
            }
            if(hto_feature_correction){
                rownames(hto_data[[i]])<-t(matrix(unlist(strsplit(as.character(rownames(hto_data[[i]])),"-")),nrow=2))[,1]
                hto.design[,1]<-t(matrix(unlist(strsplit(as.character(hto.design[,1]),"-")),nrow=2))[,1]
            }
            hto_data[[i]]<-list(mat=hto_data[[i]],design=hto.design)
            
        }

        data[[i]]<-fixIDs(mat=mat,feature.names=feature.names,barcode.names=barcode.names,
                          tx2genes=tx2genes,default_annotation=default_annotation,column=column,
                          include.names=include.names)
        
        if(!is.null(umi.design)){
            if(is.null(names(umi.design)) | length(which(names(umi.design)==""))>0){
                stop("The umi.design must be a named vector.")
            }
            hto.design<-data.frame(matrix(umi.design,nrow=1)[rep(1,nrow(data[[i]]$barcode.names)),])
            colnames(hto.design)<-names(umi.design)
            rownames(hto.design)<-data[[i]]$barcode.names$V1
            data[[i]]<-c(data[[i]],list(design=hto.design))
        } else {
            data[[i]]<-c(data[[i]],list(design=NULL))
        }
    }
    
  return(list(UMI=data,HTO=hto_data,RawUMI_barcodes=keepData_barcodes,RawHTO_barcodes=keepHTO_barcodes))
}




#' Produces the plots of the Mapping section of cellranger QC.
#'
#' It plots the metrics of the Mapping section of cellranger QC from the metrics_summary.csv.
#'   It compares the following metrics across samples: fraction of reads mapped confidently (uniquely) to the genome,
#'   fraction of reads mapped confidently (uniquely) to the transcritome, fraction of reads mapped confidently at the opposite strand
#'   (antisense) to the annotated gene of the transcriptome and fraction of reads mapped confidently to intergenic, intronic and 
#'   exonic regions. The horizontal lines indicate cutoffs suggested in the 10x cellranger manual.
#' @param x data.frame. The summary data frame component of cellrangerQC_reader().
#' @param type character. If Interactive, it creates an interactive plotly figure. If Non-interactive, it creates a non-interactive ggplot2 figure.
#'   Default is Both that creates both options. 
#' @param outdir character. A folder to store the plots.
#' @param fname character. A filename for the stored plot. If NULL (default), the filename is automatically chosen.
#' @keywords cellrangerQC_MappingPlot
#' @return A set of barplots.
#'
cellrangerQC_MappingPlot <- function(x,outdir,fname=NULL,type="Both"){

    if(type!="Interactive" & type!="Noninteractive" & type!="Both"){
        stop("Parameter type should be one of Interactive, Noninteractive or Both.")
    }

    pinteractive<-pnoninteractive<-NULL
    if(type=="Interactive" | type=="Both"){

        a <- list(
        title = "Sample",
        showticklabels = TRUE,
        tickmode= "array",
        ticktext = unique(x$Sample),
        tickvals = c(1:length(unique(x$Sample)))
        )
    
	p1<-cellrangerQC_barplot(data=x,x=as.formula("~Sample"),y=as.formula("~Reads.Mapped.Confidently.to.Genome"),
                                 text="Genome",color="#00B0F6",legend="% Reads Mapped to Genome",
                                 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text="",
                                 interactive=TRUE)

    	p2<-cellrangerQC_barplot(data=x,x=as.formula("~as.numeric(factor(data$Sample))"),y=as.formula("~Reads.Mapped.Confidently.to.Transcriptome"),
                                 text="Transcriptome",color="#F8766D",legend="% Reads Mapped to Transcriptome",
                                 add.line=TRUE,grouped.style=FALSE,cutoff=30,cutoff.text="HQ > 30%",
                                 interactive=TRUE)

    	p3<-cellrangerQC_barplot(data=x,x=as.formula("~as.numeric(factor(data$Sample))"),y=as.formula("~Reads.Mapped.Antisense.to.Gene"),
                                 text="Antisense",color="#FFA372",legend="% Reads Mapped Antisense",
                                 add.line=TRUE,grouped.style=FALSE,cutoff=10,cutoff.text="HQ < 10%",
                                 interactive=TRUE)

	p4<-cellrangerQC_barplot(data=x,x=as.formula("~as.numeric(factor(data$Sample))"),
                                 y=list(as.formula("~Reads.Mapped.Confidently.to.Exonic.Regions"),as.formula("~Reads.Mapped.Confidently.to.Intronic.Regions"),as.formula("~Reads.Mapped.Confidently.to.Intergenic.Regions")),
                                 text=c("Exonic","Intronic","Intergenic"),
                                 color=c("#523906","#535204","#62760C"),
                                 legend=c("% Reads Mapped to Exons","% of Reads Mapped to Introns","% of Reads Mapped Intergenic"),
                                 add.line=FALSE,grouped.style=TRUE,cutoff=NULL,cutoff.text="",
                                 interactive=TRUE)

	pinteractive<-subplot(p1,p2,p3,p4,nrows=2)
        saveWidget(pinteractive,paste(outdir,"cellrangerQC_mapping.html",sep=""),selfcontained = FALSE)

	# message       
        print(paste("Download plot: ",outdir,"cellrangerQC_mapping*",sep=""))

    }

    if(type=="Noninteractive" | type=="Both"){

	p1<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Reads.Mapped.Confidently.to.Genome")],
                                 text="% Reads Mapped to Genome",color="#00B0F6",legend="% Reads Mapped to Genome",
                                 add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                                 interactive=FALSE)

	p2<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Reads.Mapped.Confidently.to.Transcriptome")],
                                 text="% Reads Mapped to Transcriptome",color="#F8766D",legend="% Reads Mapped to Transcriptome",
                                 add.line=TRUE,grouped.style=FALSE,cutoff=30,cutoff.text=NULL,
                                 interactive=FALSE)

        p3<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Reads.Mapped.Antisense.to.Gene")],
                                 text="% Reads Mapped Antisense",color="#FFA372",legend="% Reads Mapped Antisense",
                                 add.line=TRUE,grouped.style=FALSE,cutoff=10,cutoff.text=NULL,
                                 interactive=FALSE)

	p4<-cellrangerQC_barplot(data=x,x="Sample",y=c("Reads.Mapped.Confidently.to.Exonic.Regions","Reads.Mapped.Confidently.to.Intronic.Regions","Reads.Mapped.Confidently.to.Intergenic.Regions"),
                                 text="Percent",color=c("#523906","#535204","#62760C"),
				 legend=c("% Reads Mapped to Exons","% of Reads Mapped to Introns","% of Reads Mapped Intergenic"),
                                 add.line=FALSE,grouped.style=TRUE,cutoff=NULL,cutoff.text=NULL,
                                 interactive=FALSE)


	if(is.null(fname)){
	   fname<-paste(x$Sample,collapse="_")
	}
        pnoninteractive<-list(p1,p2,p3,p4)
        pdf(paste(outdir,"cellrangerQC_mapping_",fname,".pdf",sep=""))
            print(p1)
            print(p2)
            print(p3)
            print(p4)
        dev.off()

	# message       
        print(paste("Download plot: ",outdir,"cellrangerQC_mapping_",fname,".pdf",sep=""))

    }

  return(list(Interactive=pinteractive,Noninteractive=pnoninteractive))
}



#' Produces the plots of the Mapping section of STARsolo QC.
#'
#' It plots the metrics of the Mapping section of STARsolo QC from the Summary.csv.
#'   It is similar to the cellrangerQC_MappingPlot().
#' @param x data.frame. The summary data frame component of STARsoloQC_reader().
#' @param outdir character. A folder to store the plots.
#' @param fname character. A filename for the stored plot. If NULL (default), the filename is automatically chosen.
#' @keywords STARsoloQC_MappingPlot
#' @return A set of barplots.
#'
STARsoloQC_MappingPlot <- function(x,outdir,fname=NULL){

    p1<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Reads Mapped to Genome: Unique")],
                              text="% Reads Mapped to Genome (Unique)",color="#00B0F6",legend="% Reads Mapped to Genome",
                              add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                              interactive=FALSE)

     p2<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Reads Mapped to Gene: Unique Gene")],
                              text="% Reads Mapped to Gene (Unique)",color="#F8766D",legend="% Reads Mapped to Gene",
                              add.line=TRUE,grouped.style=FALSE,cutoff=30,cutoff.text=NULL,
                              interactive=FALSE)

     p3<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="Fraction of Unique Reads in Cells")],
                              text="% Unique Reads in Cells",color="#FFA372",legend="% Unique Reads in Cells",
                              add.line=TRUE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                              interactive=FALSE)

     if(is.null(fname)){
	fname<-paste(x$Sample,collapse="_")
     }
     pnoninteractive<-list(p1,p2,p3)
     pdf(paste(outdir,"STARsoloQC_mapping_",fname,".pdf",sep=""))
         print(p1)
         print(p2)
         print(p3)
     dev.off()

     # message
     print(paste("Download plot: ",outdir,"STARsoloQC_mapping_",fname,".pdf",sep=""))

return(pnoninteractive)
}




#' Produces the plots of the pseudoaligned section of Kallisto QC.
#'
#' It plots the metrics of the pseudoaligned section of Kallisto QC from the
#'   run_info.json. It is similar to the cellrangerQC_MappingPlot().
#' @param x data.frame. The summary data frame component of KallistoQC_reader().
#' @param outdir character. A folder to store the plots.
#' @keywords KallistoQC_MappingPlot
#' @return A set of barplots.
#'
KallistoQC_PseudoAlignPlot <- function(x,outdir){

    p1<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="p_pseudoaligned")],
                              text="% Pseudoaligned Fragments",color="#00B0F6",legend="% Pseudoaligned Fragments",
                              add.line=FALSE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                              interactive=FALSE)

     p2<-cellrangerQC_barplot(data=x,x=x[,which(colnames(x)=="Sample")],y=x[,which(colnames(x)=="p_unique")],
                              text="% Pseudoaligned Fragments to Unique Genes",color="#F8766D",legend="% Pseudoaligned Fragments (Unique)",
                              add.line=TRUE,grouped.style=FALSE,cutoff=NULL,cutoff.text=NULL,
                              interactive=FALSE)


     pnoninteractive<-list(p1,p2)
     pdf(paste(outdir,"KallistoQC_pseudoalign_",paste(x$Sample,collapse="_"),".pdf",sep=""))
         print(p1)
         print(p2)
     dev.off()

     # message
     print(paste("Download plot: ",outdir,"KallistoQC_pseudoalign_",paste(x$Sample,collapse="_"),".pdf",sep=""))

return(pnoninteractive)
}


#' Extracts the useful information from the souporcell clusters.tsv results.
#'
#' Extracts the useful information from the souporcell clusters.tsv result. Specifically, it summarises into a list of 
#'   data frames the barcode IDs, the doublet identification and the individuals' clustering. NOTE that the samples
#'   need to be merged (e.g. with cellranger aggr function) so that there is a direct association among the individuals 
#'   of different samples.
#' @param input_folder character. A folder where the souporcell's clusters.tsv is located.
#' @param obj list. A list of consisting of Seurat objects (one for each sample). The barcode ID will be taken from there 
#'   to split the souporcell input back into sample-specific information.
#' @param allDoublets logical. If TRUE (default), all cells that are not 'signlets' in souporcell_stats() are convertd to
#'   Doublets.
#' @keywords souporcell_stats
#' @return An updated Seurat object with list with the important information of souporcell's output and an estimate of 
#'   souporcell's doublet rate.
#'  
souporcell_stats<-function(input_folder,obj,allDoublets=TRUE){
    
    if(!file.exists(input_folder[[1]])){
        dir.create(input_folder[[1]])
    }
    
    
   clu<-read.table(paste(input_folder,"clusters.tsv",sep=""),sep="\t",header=T)[,1:3]
   perc<-matrix(0,length(obj),2)
   perc[,1]<-names(obj)

   ide<-identical(sort(names(obj)),sort(names(input_folder)))
    if(!ide){
        stop("The input_folder and obj names must match.")
    }
    sl<-sort.list(names(obj))
    obj<-obj[sl]
    sl<-sort.list(names(input_folder))
    input_folder<-input_folder[sl]

    ss<-as.list(rep(0,length(obj)))
    names(ss)<-names(obj)
    for(i in 1:length(input_folder)){
        ss[[i]]<-read.table(paste(input_folder[i],"clusters.tsv",sep=""),sep="\t",header=T)[,1:3]
    }

   SOC<-as.list(rep(0,length(ss)))
   names(SOC)<-names(ss)
   for(i in 1:length(obj)){

       s1<-setdiff(as.character(rownames(obj[[i]]@meta.data)),as.character(clu[,1]))
       ii<-intersect(as.character(clu[,1]),as.character(rownames(obj[[i]]@meta.data)))
       mm<-match(ii,as.character(clu[,1]),nomatch=0)
       soc1<-clu[mm,]
       if(length(s1)>0){
           soc2<-cbind(s1,rep("unassigned",length(s1)),rep(-1,length(s1)))
           if(!is.null(input_folder)){
               for(j in 1:length(s1)){

                   w<-which(ss[[i]][,1]==s1[j])
		   if(length(w)>0){
                   	a<-ss[[i]][w,]
                   	soc2[j,2]<-as.character(a[2])
                   	b<-ss[[i]][as.character(ss[[i]][,3])==as.character(a[3]),1]
                   	ref<-soc1[match(b,as.character(soc1[,1])),3]
                   	tt<-table(ref)
                   	soc2[j,3]<-names(tt)[which.max(tt)]
		   } else {
			soc2[j,3]<-"0/1"
			soc2[j,2]<-"doublet"
		   }

               }
               soc<-rbind(as.matrix(soc1),soc2)
               soc<-soc[match(as.character(rownames(obj[[i]]@meta.data)),as.character(soc[,1])),]
           } else {
               soc<-rbind(as.matrix(soc1),soc2)
               soc<-soc[match(as.character(rownames(obj[[i]]@meta.data)),as.character(soc[,1])),]
           }

           SOC[[i]]<-data.frame(soc[,2:3])
           colnames(SOC[[i]])<-c("Souporcell_doublet","Souporcell_Individual")
           obj[[i]]@meta.data<-cbind(obj[[i]]@meta.data,SOC[[i]])
       } else {

           mm<-match(rownames(obj[[i]]@meta.data),as.character(soc1[,1]),nomatch=0)
           SOC[[i]]<-data.frame(soc1[mm,2:3])
           colnames(SOC[[i]])<-c("Souporcell_doublet","Souporcell_Individual")
           obj[[i]]@meta.data<-cbind(obj[[i]]@meta.data,SOC[[i]])

       }
       
       if(allDoublets){
           if(length(which(colnames(obj[[i]]@meta.data)=="hash.ID"))>0){
               hh<-cbind(as.character(obj[[i]]@meta.data$hash.ID),
                         as.character(obj[[i]]@meta.data$Souporcell_doublet),
                         rep(0,nrow(obj[[i]]@meta.data)))
               for(j in 1:nrow(hh)){
                   if(hh[j,1]=="Doublet" | hh[j,2]!="singlet"){
                       hh[j,3]<-"Doublet"
                   } else {
                       hh[j,3]<-hh[j,1]
                   }
               }
               obj[[1]]@meta.data$hash.ID<-as.character(hh[,3])
           } else {
               
               hh<-as.character(obj[[i]]@meta.data$Souporcell_doublet)
               hh[hh!="singlet"]<-"doublet"
               obj[[i]]@meta.data$Souporcell_doublet<-hh
               
           }
       }
       
       tt<-table(as.character(SOC[[i]][,1]))
       perc[i,2]<-sum(tt[names(tt)!="singlet"]/sum(tt))
   }

return(list(Obj=obj,Nonsinglet_perc=perc))
}



#' Converts Kallisto UMIs to a Seurat object.
#'
#' Converts Kallisto UMIs to a Seurat object. Using the min.cells and min.features parameters, the function reduces dramatically
#'   the data dimensionality and speeds up the downstream analysis. Optionally it removes the version from the ENSG rownames.
#' @param data data frame. The UMI matrix of Kallisto-Bus.
#' @param min.cells numeric. Include features detected in at least this many cells. Default is 3.
#' @param min.features numeric. Include cells where at least this many features are detected. Default is 200.
#' @param remove.dot.from.rownames logical. If TRUE (default), it removes the version from the ENSG rownames.
#' @keywords kallisto2Seurat
#' @return A Seurat object.
#'
kallisto2Seurat<-function(data,min.cells=3,min.features=200,remove.dot.from.rownames=TRUE){

   if(remove.dot.from.rownames){
   	rownames(data)<-t(matrix(unlist(strsplit(rownames(data),".",fixed=TRUE)),nrow=2))[,1]
   }

   data <- CreateSeuratObject(counts = data, project = "RAW", min.cells = min.cells, min.features = min.features)

 return(data)
}


#' Reads and annotates the Kallisto generated counts.
#'
#' Reads and annotates the Kallisto generated counts. The data generation pipeline cretes a Seurat object where the
#'   information of raw counts matrix, features and barcodes can be easily extracted. To edit the gene names this function
#'   uses a preformated annotation file containing the Ensembl and Gencode hg19 and GRCh38 transcrit and gene ID, as well
#'   as their biotypes, and converts the rownames (gene IDs) of the raw counts matrix in the form EnsemblID:GeneName.
#' @param data object. A Seurat object of the Kallisto counts and information.
#' @param hto_folder character. A vector with the named folders where the matrix.mtx.gz, features.tsv.gz and barcodes.tsv.gz of the
#'   hashtags are located. The user also needs to store on that location the HTO design table to associate each HTO with hashtag experimental
#'   information. The first column of the matrix should contain the hashtags as found n the feature matrix (not necessarily in that order).
#'   The hto_folder names should match the names of the input_folder (to associate the two). Default is NULL (no hashtag data / protocol).
#' @param tx2genes character. The location of the gene annotation file. Columns 1-2 contain the Ensembl transcript IDs (ENST_dot, ENST_nodot),
#'   columns 3-4 the Ensembl gene IDs (ENSG_dot, ENSG_nodot), column 5 the gene names (GeneName), column 6 the biotype (BioType)
#'   and columns 7-8 the reference genome ID (Ref: GRCh37 or GRCh38) and the annotation type  (DB: Gencode or Ensembl). The other columns specify
#'   the genes that are reported as TFs (PMID:29425488) and Epigenetic factors (PMID:26153137).
#' @param default_annotation character. The annotataion that has been used in the cellranger pipeline to produce the results.
#'   It will mainly consider those IDs from the annotation file. If some genes of the matrix.mtx are (not present in the annotataion
#'   file, the algorithm will perform a global annotataion search using the entris of all annotation types. Currently, the possible
#'   values must be one of: 'GRCh37_Gencode', 'GRCh38_Gencode', 'GRCh37_Ensembl' and 'GRCh38_Ensembl'.
#' @param umi.design data frame. One or more characteristics of the cells. Default is NULL.
#' @param hto.design data frame. If HTOs are used, a data.frame associating the HTOs to experimental conditions. The first column
#'   must specify the HTO ID and the rest of the columns the Condition, Time of Experiment and any other relevant information
#'   present. Default is NULL.
#' @param column character. The column of the annotation file that matches the original rownames of the matrix.mtx (to update the
#'   rownames in the appropriate form). Default is column="ENSG_nodot" that uses the Ensembl gene IDs without the '.x' symbol at the end.
#'   Other options are ENSG_dot and GeneName depending on the dataset.
#' @param hto_barcode_correction logical. If TRUE (default), the '-1' symbol is added at the end of the hto barcodes to match with the
#'   barcodes of the UMI count data.
#' @param hto_feature_correction logical. If TRUE (default), the -<<barcode>> extension is removed from the end of the hto features.
#' @param include.names logical. If TRUE (default), it looks for the GeneNames column in tx2genes matrix and builds the final
#'   gene annotation.
#' @keywords readKallisto
#' @return A list with the reformatted Kallisto counts data and annotation for each sample. If available the hashtag data are added
#'   to the components of the list.
#'
readKallisto<-function(data,hto_folder=NULL,umi.design=NULL,hto.design=NULL,
                       tx2gene="/home/motake/Annotation/GeneAnnotation/Human_transcripts_to_genes.txt",
                       column="ENSG_nodot",include.names=TRUE,default_annotation="GRCh38_Ensembl",
                       hto_barcode_correction=TRUE,hto_feature_correction=TRUE){
    
    if(!is.null(hto_folder)){
        if(is.null(names(hto_folder))){
                stop("Parameter hto_folder should be named vector. The names are to be used as sampleIDs!")
        }

        if(is.null(hto.design)){
            stop("Parameter hto.design must be specified.")
        }

    }
    
    tx2genes<-read.table(tx2gene,sep="\t",header=T)
    mat<-data@assays$RNA@counts
    #if(length(grep("ENSG",column))>0){
    #	rownames(mat)<-t(matrix(unlist(strsplit(rownames(mat),".",fixed=T)),nrow=2))[,1]
    #}
    feature.names <- rownames(mat)
    barcode.names <- colnames(mat)
    
    hto_data<-NULL
   
    keepHTO_barcodes<-NULL
    keepData_barcodes<-barcode.names


    if(!is.null(hto_folder)){
         htomat<-readMM(paste(hto_folder,"matrix.mtx.gz",sep=""))
         htofeature.names <- read.delim(paste(hto_folder,"features.tsv.gz",sep=""),header = FALSE,stringsAsFactors = FALSE)
         htobarcode.names <- read.delim(paste(hto_folder,"barcodes.tsv.gz",sep=""),header = FALSE,stringsAsFactors = FALSE)

         keepHTO_barcodes<-htobarcode.names
         mm<-match(as.character(hto.design[,1]),as.character(htofeature.names$V1),nomatch=0)
         if(length(mm[mm==0])>0){
             stop("The hashtag IDs of the design and the feature tables should match.")
         }

         if(hto_barcode_correction){
             htobarcode.names<-apply(htobarcode.names,1,paste,"-1",sep="")
             htobarcode.names<-data.frame(htobarcode.names)
             colnames(htobarcode.names)<-"V1"
         }
         colnames(htomat) <- htobarcode.names$V1
         rownames(htomat) <- htofeature.names$V1

         common.barcodes <- intersect(colnames(mat), colnames(htomat))
         mat <- mat[, match(common.barcodes,colnames(mat))]
         barcode.names<-data.frame(common.barcodes)
         htomat <- htomat[, match(common.barcodes,colnames(htomat))]

         hto_data<-htomat
         w<-which(rownames(hto_data)=="unmapped")
         if(length(w)>0){
             hto_data<-hto_data[-w,]
         }
         if(hto_feature_correction){
             rownames(hto_data)<-t(matrix(unlist(strsplit(as.character(rownames(hto_data)),"-")),nrow=2))[,1]
             hto.design[,1]<-t(matrix(unlist(strsplit(as.character(hto.design[,1]),"-")),nrow=2))[,1]
         }
         hto_data<-list(mat=hto_data,design=hto.design)

    }

    data<-fixIDs(mat=mat,feature.names=feature.names,barcode.names=barcode.names,
                 tx2genes=tx2genes,default_annotation=default_annotation,column=column,
                 include.names=include.names)

    if(!is.null(umi.design)){
        if(is.null(names(umi.design)) | length(which(names(umi.design)==""))>0){
                stop("The umi.design must be a named vector.")
        }
        hto.design<-data.frame(matrix(umi.design,nrow=1)[rep(1,nrow(data$barcode.names)),])
        colnames(hto.design)<-names(umi.design)
        rownames(hto.design)<-data$barcode.names
        data<-c(data,list(design=hto.design))
    } else {
        data<-c(data,list(design=NULL))
    }

 return(list(UMI=data,HTO=hto_data,RawUMI_barcodes=keepData_barcodes,RawHTO_barcodes=keepHTO_barcodes))
}





#' Reads and annotates the 10x generated counts.
#'
#' Reads and annotates the 10x generated counts. It locates the matrix.mtx, features.tsv and barcodes.tsv output of
#'   cellranger pipeline and  reformats them in a data frame. It uses a preformated annotation file containing the 
#'   Ensembl and Gencode hg19 and GRCh38 transcrit and gene ID, as well as their biotypes, and converts the rownames 
#'   (gene IDs) of the matrix.mtx in the form EnsemblID:GeneName. Finally, it constructs an infrmative feature.names 
#'   slot witht the detailed gene annotation.
#' @param input_folder character. A vector with the named folders where the matrix.mtx.gz, features.tsv.gz and barcodes.tsv.gz 
#'   are located. Names serve as the sample ID.
#' @param hto_folder character. A vector with the named folders where the matrix.mtx.gz, features.tsv.gz and barcodes.tsv.gz of the
#'   hashtags are located. The user also needs to store on that location the HTO design table to associate each HTO with hashtag experimental
#'   information. The first column of the matrix should contain the hashtags as found n the feature matrix (not necessarily in that order).
#'   The hto_folder names should match the names of the input_folder (to associate the two). Default is NULL (no hashtag data / protocol). 
#' @param tx2genes character. The location of the gene annotation file. Columns 1-2 contain the Ensembl transcript IDs (ENST_dot, ENST_nodot),
#'   columns 3-4 the Ensembl gene IDs (ENSG_dot, ENSG_nodot), column 5 the gene names (GeneName), column 6 the biotype (BioType)
#'   and columns 7-8 the reference genome ID (Ref: GRCh37 or GRCh38) and the annotation type  (DB: Gencode or Ensembl). The other columns specify
#'   the genes that are reported as TFs (PMID:29425488) and Epigenetic factors (PMID:26153137).
#' @param default_annotation character. The annotataion that has been used in the cellranger pipeline to produce the results.
#'   It will mainly consider those IDs from the annotation file. If some genes of the matrix.mtx are (not present in the annotataion 
#'   file, the algorithm will perform a global annotataion search using the entris of all annotation types. Currently, the possible
#'   values must be one of: 'GRCh37_Gencode', 'GRCh38_Gencode', 'GRCh37_Ensembl' and 'GRCh38_Ensembl'.
#' @param umi.design data frame. One or more characteristics of the cells. Default is NULL.
#' @param hto.design data frame. If HTOs are used, a data.frame associating the HTOs to experimental conditions. The first column
#'   must specify the HTO ID and the rest of the columns the Condition, Time of Experiment and any other relevant information
#'   present. Default is NULL.
#' @param column character. The column of the annotation file that matches the original rownames of the matrix.mtx (to update the
#'   rownames in the appropriate form). Default is column="ENSG_nodot" that uses the Ensembl gene IDs without the '.x' symbol at the end.
#'   Other options are ENSG_dot and GeneName depending on the dataset.
#' @param hto_barcode_correction logical. If TRUE (default), the '-1' symbol is added at the end of the hto barcodes to match with the
#'   barcodes of the UMI count data. 
#' @param hto_feature_correction logical. If TRUE (default), the -<<barcode>> extension is removed from the end of the hto features.
#' @param include.names logical. If TRUE (default), it looks for the GeneNames column in tx2genes matrix and builds the final
#'   gene annotation.
#' @keywords read10xRNAs
#' @return A list with the reformatted 10x counts data and annotation for each sample. If available the hashtag data are added
#'   to the components of the list.
#'    
read10xRNAs<-function(input_folder,hto_folder,tx2genes,default_annotation,umi.design=NULL,hto.design=NULL,
                      column="ENSG_nodot",hto_barcode_correction=TRUE,hto_feature_correction=TRUE,include.names=TRUE){
    
    if(is.null(names(input_folder))){
        stop("Parameter input_folder should be named vector. The names are to be used as sampleIDs!")
    }
    
    if(!is.null(hto_folder)){
    	if(is.null(names(hto_folder))){
        	stop("Parameter hto_folder should be named vector. The names are to be used as sampleIDs!")
    	}
        
        if(is.null(hto.design)){
            stop("Parameter hto.design must be specified.")
        }
        
    	ide<-identical(sort(names(input_folder)),sort(names(hto_folder)))
    	if(!ide){
	    stop("The names of the input_folder and hto_folder must be identical")
        }
        sl<-sort.list(names(hto_folder))
    	hto_folder<-hto_folder[sl]
    }
    sl<-sort.list(names(input_folder))
    input_folder<-input_folder[sl]


    tx2genes<-read.table(tx2genes,sep="\t",header=T)
    data<-hto_data<-as.list(rep(0,length(input_folder)))
    names(data)<-names(hto_data)<-names(input_folder)
    
    for(i in 1:length(input_folder)){
        
        mat <- readMM(file = paste(input_folder[i],"matrix.mtx.gz",sep=""))
        feature.names <- read.delim(paste(input_folder[i],"features.tsv.gz",sep=""),header = FALSE,stringsAsFactors = FALSE)
        barcode.names <- read.delim(paste(input_folder[i],"barcodes.tsv.gz",sep=""),header = FALSE,stringsAsFactors = FALSE)
        colnames(mat) <- barcode.names$V1
        rownames(mat) <- feature.names$V1
	
        keepHTO_barcodes<-NULL
        keepData_barcodes<-barcode.names$V1


        if(!is.null(hto_folder)){
            htomat<-readMM(paste(hto_folder[i],"matrix.mtx.gz",sep=""))
            htofeature.names <- read.delim(paste(hto_folder[i],"features.tsv.gz",sep=""),header = FALSE,stringsAsFactors = FALSE)
            htobarcode.names <- read.delim(paste(hto_folder[i],"barcodes.tsv.gz",sep=""),header = FALSE,stringsAsFactors = FALSE)
            
            keepHTO_barcodes<-htobarcode.names
            mm<-match(as.character(hto.design[,1]),as.character(htofeature.names$V1),nomatch=0)
            if(length(mm[mm==0])>0){
                stop("The hashtag IDs of the design and the feature tables should match.")
            }
	    htomat<-htomat[mm,]
	    htofeature.names<-data.frame(V1=htofeature.names[mm,])
	    
            if(hto_barcode_correction){
                htobarcode.names<-apply(htobarcode.names,1,paste,"-1",sep="")
                htobarcode.names<-data.frame(htobarcode.names)
                colnames(htobarcode.names)<-"V1"
            }
            colnames(htomat) <- htobarcode.names$V1
            rownames(htomat) <- htofeature.names$V1

            common.barcodes <- intersect(colnames(mat), colnames(htomat))
            mat <- mat[, match(common.barcodes,colnames(mat))]
            barcode.names<-data.frame(common.barcodes)
            htomat <- htomat[, match(common.barcodes,colnames(htomat))]
            
            hto_data[[i]]<-htomat
            w<-which(rownames(hto_data[[i]])=="unmapped")
            if(length(w)>0){
                hto_data[[i]]<-hto_data[[i]][-w,]
            }
            if(hto_feature_correction){
                rownames(hto_data[[i]])<-t(matrix(unlist(strsplit(as.character(rownames(hto_data[[i]])),"-")),nrow=2))[,1]
                hto.design[,1]<-t(matrix(unlist(strsplit(as.character(hto.design[,1]),"-")),nrow=2))[,1]
            }
            hto_data[[i]]<-list(mat=hto_data[[i]],design=hto.design)
            
        }

        data[[i]]<-fixIDs(mat=mat,feature.names=feature.names,barcode.names=barcode.names,
                          tx2genes=tx2genes,default_annotation=default_annotation,column=column,
                          include.names=include.names)
        
        if(!is.null(umi.design)){
            if(is.null(names(umi.design)) | length(which(names(umi.design)==""))>0){
                stop("The umi.design must be a named vector.")
            }
            hto.design<-data.frame(matrix(umi.design,nrow=1)[rep(1,nrow(data[[i]]$barcode.names)),])
            colnames(hto.design)<-names(umi.design)
            rownames(hto.design)<-data[[i]]$barcode.names$V1
            data[[i]]<-c(data[[i]],list(design=hto.design))
        } else {
            data[[i]]<-c(data[[i]],list(design=NULL))
        }
    }
    
  return(list(UMI=data,HTO=hto_data,RawUMI_barcodes=keepData_barcodes,RawHTO_barcodes=keepHTO_barcodes))
}
    


#' Generates the knee plot and the saturation plot from the raw 10x counts.
#'
#' Generates the knee plot and the saturation plot from the raw 10x counts.
#' @param input_folder character. A vector with the named folders where the matrix.mtx.gz, features.tsv.gz and barcodes.tsv.gz 
#'   (or the related files for Kallisto / Alevin) are located. Names serve as the sample ID.
#' @param outdir character. A folder to store the plots.
#' @param methodology character. One of cellranger (default), STARsolo, Kallisto or Alevin. Depending on the input, the function 
#'   points to the correct folder names.
#' @keywords raw10xViz
#' @return A list with the data frames that generate the saturation and the knee plots.
#'
raw10xViz<-function(input_folder,outdir,methodology="cellranger"){
    
    if(is.null(names(input_folder))){
        stop("Parameter input_folder should be named vector. The names are to be used as sampleIDs!")
    }
    
    if(methodology!="cellranger" & methodology!="STARsolo" & methodology!="Kallisto" & methodology!="Alevin"){
	stop("Parameter methodology should be one of cellranger, STARsolo, Kallisto or Alevin")
    }

    if(methodology=="cellranger"){
	f1<-"raw_feature_bc_matrix/matrix.mtx.gz"
	f2<-"raw_feature_bc_matrix/features.tsv.gz"
	f3<-"raw_feature_bc_matrix/barcodes.tsv.gz"
	f4<-"filtered_feature_bc_matrix/barcodes.tsv.gz"
    }
    if(methodology=="STARsolo"){
	f1<-"raw/matrix.mtx"
        f2<-"raw/features.tsv"
        f3<-"raw/barcodes.tsv"
        f4<-"filtered/barcodes.tsv.gz"
    }
    if(methodology=="Kallisto"){
	f1<-"counts_unfiltered/cells_x_genes.mtx"
	f2<-"counts_unfiltered/cells_x_genes.genes.txt"
	f3<-"counts_unfiltered/cells_x_genes.barcodes.txt"
	f4<-"counts_filtered/cells_x_genes.barcodes.txt"
    }
    if(methodology=="Alevin"){
	stop("Not yet available")
    }

    for(i in 1:length(input_folder)){
        
        mat <- readMM(file = paste(input_folder[i],f1,sep=""))
	if(methodology=="Kallisto"){
	   mat<-t(mat)
	}
        feature.names <- read.delim(paste(input_folder[i],f2,sep=""),header = FALSE,stringsAsFactors = FALSE)
        barcode.names <- read.delim(paste(input_folder[i],f3,sep=""),header = FALSE,stringsAsFactors = FALSE)
        colnames(mat) <- barcode.names$V1
        rownames(mat) <- feature.names$V1
        keptbars<-read.delim(paste(input_folder[i],f4,sep=""),header = FALSE,stringsAsFactors = FALSE)
        
        x1<-data.frame(nCount=rowSums(t(mat)),nGene=rowSums(t(mat)>0))
        x2 <- tibble(Barcode=colnames(mat),total = x1$nCount,rank = row_number(desc(total))) %>% distinct() %>% arrange(rank)
        mm<-match(x2$Barcode,keptbars$V1,nomatch=0)
        mm[mm>0]<-1
        mm<-ifelse(mm==0,"Empty","Cell")
        x2<-cbind(x2,Type=mm)
        x1<-cbind(x1,Type=x2$Type[match(rownames(x1),x2$Barcode)])
        x2$Type<-factor(x2$Type,levels=c("Empty","Cell"))
        x1$Type<-factor(x1$Type,levels=c("Empty","Cell"))
        
        pdf(paste(outdir,"KneePlot_",methodology,"_",names(input_folder)[i],".pdf",sep=""))
            p<-ggplot(x2,aes(y=total,x=rank,color=Type)) + geom_path(size = 2) + scale_color_manual(values = c("gray","#00B0F6")) +
            scale_x_log10() + scale_y_log10() + annotation_logticks() +
	    annotate(geom="text", x=x2$rank[max(which(x2$Type=="Cell"))], y=x2$total[max(which(x2$Type=="Cell"))]-100, label=length(which(x2$Type=="Cell")),color="#00B0F6") +
            labs(x = "Barcode rank", y = "Total UMI count") + ggtitle(paste("Sample ",names(input_folder)[i],sep=""))
            print(p)
        dev.off()
        
        # message
        print(paste("Download plot: ",outdir,"KneePlot_",methodology,"_",names(input_folder)[i],".pdf",sep=""))
        
        png(paste(outdir,"SaturationPlot_",methodology,"_",names(input_folder)[i],".png",sep=""))
            p<-ggplot(x1,aes(x=nCount,y=nGene,color=Type)) + geom_point(size=0.5) + scale_color_manual(values = c("gray","#00B0F6")) +
            scale_x_log10() + scale_y_log10() + annotation_logticks() +
            labs(x = "Total UMI counts", y = "Number of genes detected")  + ggtitle(paste("Sample ",names(input_folder)[i],sep=""))
            print(p)
        dev.off()
        
        # message
        print(paste("Download plot: ",outdir,"SaturationPlot_",methodology,"_",names(input_folder)[i],".png",sep=""))
        
    }

  return(list(Saturation=x1,Knee=x2))
}



#' Fixes the gene annotation of the original 10x data matrices.
#' 
#' A helper function for the read10xRNAs() that reformats the rownames of the matrix.mtx and generates the updated feature.names.
#' @param mat sparse matrix. The 10x sparse counts matrix of 10x.
#' @param feature.names data frame. The 10x features.tsv data.
#' @param barcode.names data.frame. The 10x barcodes.tsv data.
#' @param tx2genes data frame. The gene annotation information.
#' @param default_annotation character. The annotataion that has been used in the cellranger pipeline to produce the results.    
#' @param column character. The column of the annotation file that matches the original rownames of the matrix.mtx (to update the
#'   rownames in the appropriate form).
#' @param include.names logical. If TRUE, it looks for the GeneNames column in tx2genes matrix and builds the final
#'   gene annotation.
#' @keywords fixIDs
#' @return A list with the reformatted 10x counts data and annotataion for each sample.
#' 
fixIDs<-function(mat,feature.names,barcode.names,tx2genes,default_annotation,column,include.names){
    
    column<-which(colnames(tx2genes)==column)
    name.order<-NULL
    if(include.names){
	if(colnames(tx2genes)[column]!="GeneName"){
            column.names<-which(colnames(tx2genes)=="GeneName")
	} else {
	    name.order<-"reverse"
	    column.names<-which(colnames(tx2genes)=="ENSG_nodot" | colnames(tx2genes)=="ENSMUSG_nodot")
	}
        if(length(column.names)==0){
            stop("Column GeneName was not found in the tx2gene matrix.")
        }
    } else {
        column.names<-column
    }
    if(length(column)==0){
        stop("This column name does not exist in the tx2genes matrix.")
    }
    w<-which(tx2genes[,7]==unlist(strsplit(default_annotation,"_"))[1] &
             tx2genes[,8]==unlist(strsplit(default_annotation,"_"))[2])
    t2g<-tx2genes[w,]
    if(length(w)==0){
        a<-paste(apply(unique(tx2genes[,7:8]),1,paste,collapse="_"),collapse=",")
        stop(paste("The default_annotation does not exist in the tx2genes matrix. Use one of ",a,sep=""))
    }
    ii<-intersect(as.character(rownames(mat)),as.character(t2g[,column]))
    mat1<-mat[match(ii,as.character(rownames(mat)),nomatch=0),]
    rownames.mat1<-t2g[match(ii,as.character(t2g[,column]),nomatch=0),]
    
    s1<-setdiff(as.character(rownames(mat)),as.character(t2g[,column]))
    if(length(s1)>0){
        
        print("Some genes of the scRNA-seq counts matrix are missing in the default annotation matrix. Using other annotations to fill the gaps")
 	
        ii<-intersect(s1,as.character(tx2genes[,column]))
        mat2<-mat[match(ii,rownames(mat),nomatch=0),]
        rownames.mat2<-tx2genes[match(ii,as.character(tx2genes[,column]),nomatch=0),]
        colnames(rownames.mat2)<-colnames(rownames.mat1)

        s2<-setdiff(as.character(rownames(mat)),as.character(tx2genes[,column]))
        if(length(s2)>0){
            mat3<-mat[match(s2,rownames(mat)),]
            rownames.mat3<-data.frame(matrix("---",length(s2),ncol(tx2genes)))
            rownames.mat3[,column]<-s2
	    colnames(rownames.mat3)<-colnames(rownames.mat1)
        } else {
            mat3<-as(matrix(0,1,ncol(mat)),"sparseMatrix")[-1,]
            colnames(mat3)<-colnames(mat)
            rownames.mat3<-data.frame(matrix(rep("---",ncol(tx2genes)),nrow=1))
            rownames.mat3<-rownames.mat3[-1,]
            colnames(rownames.mat3)<-colnames(rownames.mat1)
        }
        
    } else {
        mat2<-mat3<-as(matrix(0,1,ncol(mat)),"sparseMatrix")[-1,]
        colnames(mat2)<-colnames(mat3)<-colnames(mat)
        rownames.mat2<-rownames.mat3<-data.frame(matrix(rep("---",ncol(tx2genes)),nrow=1))
        rownames.mat2<-rownames.mat2[-1,]
        rownames.mat3<-rownames.mat3[-1,]
        colnames(rownames.mat2)<-colnames(rownames.mat3)<-colnames(rownames.mat1)
    }
    
    
    fmat<-rbind(mat1,mat2,mat3)
    colnames(fmat)<-colnames(mat)
    rownames.mat<-rbind(rownames.mat1,rownames.mat2,rownames.mat3)
    if(include.names){
	if(is.null(name.order)){
            rownames(fmat)<-apply(rownames.mat[,c(column,column.names)],1,paste,collapse=":")
	} else {
	    rownames(fmat)<-apply(rownames.mat[,c(column.names,column)],1,paste,collapse=":")
	}
    } else {
        rownames(fmat)<-rownames.mat[,column]
    }
    
    feature.names<-rownames.mat
    rownames(feature.names)<-rownames(fmat)
    
  return(list(mat=fmat,feature.names=feature.names,barcode.names=barcode.names))
}

    


#' Performs celda's decontamination pipeline.
#'
#' Performs celda's decontamination pipeline on the raw data counts of each sample. If estimated, the HTO doublets or
#'   any other doublets are removed in order to estimate more accurately the ambient RNA.
#' @param data list. A Seurat object. Typically the output of Seurat_priliminaryQC() or doubletViz().
#' @param filter list. A set of indices specifying low-quality cells that need to be removed before decontamination.
#'   Default is NULL.
#' @param doublet.char character. A vector of IDs that specify which cells are to be considerd as doublets and removed.
#'   This option removes only non-HTO doublets. The HTO doublets are removed by default. Default is NULL.
#' @param remove.negatives logical. If TRUE (default), the HTO Nehatives are removed before decontamination.
#' @param do.postfiltering logical. If TRUE (default), it filters cells with low features and total counts after decontamination.
#' @param feature.cut numeric. The minimum number of features for post-filtering. Default is 200.
#' @param count.cut numeric. The minimum number of total counts for post-filtering. Default is 200.
#' @keywords celda_decontamination
#' @return An updated list with the decontaminated counts.
#'
celda_decontamination<-function(data,filter=NULL,doublet.char=NULL,remove.negatives=TRUE,do.postfiltering=TRUE,feature.cut=200,count.cut=200){

        print("Using the old version of celda_decontamination that is done after cell QC.")   

	ll<-length(data)
    if(!is.null(filter)){
        if(is.null(names(filter))){
            stop("Parameter filter should be named list. The names should match the names of data.")
        }
        ide<-identical(sort(names(data)),sort(names(filter)))
        if(!ide){
            stop("The names of data and filter should be identical.")
        }
        sl<-sort.list(names(data))
        data<-data[sl]
        sl<-sort.list(names(filter))
        filter<-filter[sl]
    }
    
    
    for(i in 1:ll){
	
	if(is.null(filter)){
	    test<-data[[i]]$Consensus_filter
	    if(length(test[test=="FAIL"])>0){
	    	stop("Please remove the low quality cells before decontamination")
	    }
	}

        		
	# remove the HTO doublets and negatives or the consensus doublets
	if(length(which(colnames(data[[i]]@meta.data)=="hash.ID"))>0){
            
            if(remove.negatives){
                ww<-which(data[[i]]@meta.data$hash.ID=="Doublet" | data[[i]]@meta.data$hash.ID=="Negative")
            } else {
                ww<-which(data[[i]]@meta.data$hash.ID=="Doublet")
            }
            if(!is.null(filter)){
                ww<-unique(c(ww,filter[[i]]))
            }
            
	    if(length(ww)>0){
                data[[i]]<-data[[i]][,-ww]
	    }
            
        }
		
        # remove the doublets from Scrublet / Souporcell
        if(!is.null(doublet.char)){
            
            if(length(which(colnames(data[[i]]@meta.data)=="Consensus_doublet"))>0){
                ww<-which(data[[i]]@meta.data$Consensus_doublet==doublet.char)
                if(!is.null(filter)){
                    ww<-unique(c(ww,filter[[i]]))
                }
                
                if(length(ww)>0){
                    data[[i]]<-data[[i]][,-ww]
                }
            } else {

		stop("The estimated doublets should be in the Consensus_doublet column of the meta.data slot.")
	    }	
	}
        
        # decontX
		cou<-data[[i]]@assays$RNA@counts
		sce <- SingleCellExperiment(list(counts=as.matrix(cou)),
                	                    colData=colnames(cou),
                        	            rowData=rownames(cou))
		decontX_sce <- decontX(x = sce)
                res<-decontXcounts(decontX_sce)
		rownames(res)<-rownames(cou)
		data[[i]]@assays$RNA@counts<-round(res)
		data[[i]]@meta.data<-cbind(data[[i]]@meta.data,decontX_contamination=colData(decontX_sce)[,2])		
        
        # postfiltering
		if(do.postfiltering){
		    ss1<-colSums(data[[i]]@assays$RNA@counts)
		    II<-I(as.matrix(data[[i]]@assays$RNA@counts)>0)
                    II<-ifelse(II==TRUE,1,0)
                    ss2<-colSums(II)
                    ww<-which(ss1<count.cut | ss2<feature.cut)
		    if(length(ww)>0){
                    	data[[i]]<-data[[i]][,-ww]
		    }
		}
	}
	    
  return(data)
}


	    
#' Performs celda's decontamination pipeline (version 2).
#'
#' Performs celda's decontamination pipeline on the raw data counts of each sample. If estimated, the HTO doublets or
#'   any other doublets are removed in order to estimate more accurately the ambient RNA. This version performs decontX
#'   in the first step of the QC process.
#' @param data list. A Seurat object.
#' @param id character. An id to be used in the filenames of the stored plots.
#' @param outdir character. The folder that the plots will be stored.
#' @param background list. A seurat object with the raw_barcodes information from 10x. This is the background that celda
#'  will use to decontaminate the cells. This is especially useful when cells that contributed to the ambient RNA are not
#'  accurately represented in the filtered count matrix containing the cells. Default is NULL (only the filtered cells
#'  are used).
#' @param markers list. A list of markers to be visualized before and after decontamination. The format must be
#'   list(CellType1=c("Gene_1","Gene_2","Gene_3"),CellType2=c("Gene_10","Gene_20","Gene_30"),...). Default is NULL.
#' @param top_contaminants numeric. The number of genes with that will be visualized for decontamination. Default is 9
#'   (to plot a 3x3 panel of figures).
#' @param pt.size numeric. The size of dots in the UMAP plot. Default is 1. 
#' @param filter list. A set of indices specifying low-quality cells that need to be removed before decontamination.
#'   Default is NULL.
#' @param doublet.char character. A vector of IDs that specify which cells are to be considerd as doublets and removed.
#'   This option removes only non-HTO doublets. The HTO doublets are removed by default. Default is NULL.
#' @param remove.negatives logical. If TRUE (default), the HTO Nehatives are removed before decontamination.
#' @param do.postfiltering logical. If TRUE (default), it filters cells with low features and total counts after decontamination.
#' @param feature.cut numeric. The minimum number of features for post-filtering. Default is 200.
#' @param count.cut numeric. The minimum number of total counts for post-filtering. Default is 200.
#' @param plot.height, plot.width numeric. The height and the width of the plot. Default is 7 each.
#' @param displayName character. The column name of 'rowData(x)' that specifies the display names for the features. Default 'NULL', 
#'   which displays the row names. Only works if 'x' is a SingleCellExperiment object. Overwrites 'headers'. If FALSE (default), a 
#'   headers argument is activated and shown in the plots.
#' @keywords celda_decontamination2
#' @return An updated list with the decontaminated counts and the decontX object that can be used for additional plotting.
#'

celda_decontamination2<-function(data,id,outdir,background=NULL,markers=NULL,top_contaminants=9,pt.size=1,
				 filter=NULL,doublet.char=NULL,remove.negatives=TRUE,do.postfiltering=TRUE,
				 feature.cut=200,count.cut=200,plot.height=7,plot.width=7,displayName=FALSE){

    if(!is.list(data)){
	stop("Parameters data, filter (if provided) and background (if provided) should be a named list!")
    }

    if(!is.null(filter)){
        if(is.null(names(filter))){
            stop("Parameter filter should be named list. The names should match the names of data.")
        }
        ide<-identical(sort(names(data)),sort(names(filter)))
        if(!ide){
            stop("The names of data and filter should be identical.")
        }
        sl<-sort.list(names(data))
        data<-data[sl]
        sl<-sort.list(names(filter))
        filter<-filter[sl]
    }
    
    if(!is.null(markers)){
	if(is.null(names(markers))){
		stop("Parameter markers should be named list. The names should match the names of data.")
    	}
    }

    if(!is.null(background)){
        if(is.null(names(background))){
            stop("Parameter background should be named list. The names should match the names of data.")
        }
        ide<-identical(sort(names(data)),sort(names(background)))
        if(!ide){
            stop("The names of data and background should be identical.")
        }
        sl<-sort.list(names(data))
        data<-data[sl]
        sl<-sort.list(names(background))
        background<-background[sl]
    }
    
    dX<-as.list(rep(0,length(data)))
    names(dX)<-names(data)

    for(i in 1:length(data)){

        # remove the HTO doublets and negatives or the consensus doublets
        if(length(which(colnames(data[[i]]@meta.data)=="hash.ID"))>0){

            if(remove.negatives){
                ww<-which(data[[i]]@meta.data$hash.ID=="Doublet" | data[[i]]@meta.data$hash.ID=="Negative")
            } else {
                ww<-which(data[[i]]@meta.data$hash.ID=="Doublet")
            }
            if(!is.null(filter)){
                ww<-unique(c(ww,filter[[i]]))
            }

            if(length(ww)>0){
                data[[i]]<-data[[i]][,-ww]
            }

        }

        # remove the doublets from Scrublet / Souporcell
        if(!is.null(doublet.char)){

            if(length(which(colnames(data[[i]]@meta.data)=="Consensus_doublet"))>0){
                ww<-which(data[[i]]@meta.data$Consensus_doublet==doublet.char)
                if(!is.null(filter)){
                    ww<-unique(c(ww,filter[[i]]))
                }

                if(length(ww)>0){
                    data[[i]]<-data[[i]][,-ww]
                }
            } else {

                stop("The estimated doublets should be in the Consensus_doublet column of the meta.data slot.")
            }
        }

        # decontX
        cou<-data[[i]]@assays$RNA@counts
        sce <- SingleCellExperiment(list(counts=as.matrix(cou)),colData=colnames(cou),rowData=rownames(cou))

        if(!is.null(background)){
            backcou<-background[[i]]@assays$RNA@counts
	    ii<-intersect(rownames(cou),rownames(backcou))
	    backcou<-backcou[match(ii,rownames(backcou)),]
            backsce<-SingleCellExperiment(list(counts=as.matrix(backcou)),colData=colnames(backcou),rowData=rownames(backcou))
            print("Running decontX with the defined background!")
            decontX_sce <- decontX(x = sce,background=backsce)
        } else {
            print("Running decontX without background!")
            decontX_sce <- decontX(x = sce)
        }
	rownames(decontX_sce)<-rowData(decontX_sce)$X
	decontX_sce <- logNormCounts(decontX_sce)
	decontX_sce2<-decontX_sce
	decontX_sce2 <- logNormCounts(decontX_sce2,exprs_values = "decontXcounts")
	dX[[i]]<-decontX_sce	

 	umap <- reducedDim(decontX_sce)
       	genecounts<-apply(decontX_sce2@assays@data$logcounts,1,mean)
        genecounts_before<-apply(decontX_sce@assays@data$logcounts,1,mean)
	genediff<-genecounts_before-genecounts
	genediff<-genediff[sort.list(genediff,decreasing=T)]
	genediff<-genediff[1:top_contaminants]
	genediff<-genediff[sort.list(genediff,decreasing=F)]
	df<-data.frame(Gene=names(genediff),Diff=genediff)
	df[,1]<-GeneNames(df[,1])
	df[,1]<-factor(df[,1],levels=df[,1])
	df[,2]<-as.numeric(as.character(df[,2])) 
	df1<-as.matrix(df)      
	ww<-which(df1[,1]=="---")
	if(length(ww)>0){
	   for(j in 1:length(ww)){
		df1[ww[j],1]<-GeneNames(rownames(df)[ww[j]],what="Ensg")
	   }
	}
	df1<-data.frame(df1)
	colnames(df1)<-colnames(df)
	df<-df1
	df$Diff<-as.numeric(as.character(df$Diff))
	df$Gene<-factor(df$Gene,levels=df$Gene)	


	decontX_sce3<-decontX_sce2
	decontX_sce3@assays@data$logcounts<-decontX_sce@assays@data$logcounts-decontX_sce2@assays@data$logcounts

        pdf(paste(outdir,"DecontX_",id[i],".pdf",sep=""),height=plot.height,width=plot.width)
            p1<-plotDecontXContamination(decontX_sce)
	    p2<-plotDimReduceCluster(x=decontX_sce$decontX_clusters, dim1 = umap[, 1],dim2=umap[, 2])
	    p3<-ggplot(df, aes(x=Gene,y=Diff)) + geom_bar(stat="identity") +
                  xlab("") + ylab("log10 {Average before decontX - Average after DecontX}") +
                  coord_flip() + theme(axis.text = element_text(size = 8))
	    p4<-plotDimReduceFeature(as.matrix(logcounts(decontX_sce)),dim1 = umap[, 1],dim2 = umap[, 2],features = rownames(df),size=pt.size,displayName=displayName,headers=paste(GeneNames(rownames(df)),"(preX)",sep=""))
	    p5<-plotDimReduceFeature(as.matrix(logcounts(decontX_sce2)),dim1 = umap[, 1],dim2 = umap[, 2],features = rownames(df),size=pt.size,displayName=displayName,headers=paste(GeneNames(rownames(df)),"(postX)",sep=""))
	    p6<-plotDimReduceFeature(as.matrix(logcounts(decontX_sce3)),dim1 = umap[, 1],dim2 = umap[, 2],features = rownames(df),size=pt.size,displayName=displayName,headers=paste(GeneNames(rownames(df)),"(preX-postX)",sep=""))
	    print(p1);print(p2);print(p3);print(p4);print(p5);print(p6)

	    if(!is.null(markers)){
		p7<-plotDimReduceFeature(as.matrix(logcounts(decontX_sce)),dim1 = umap[, 1],dim2 = umap[, 2],features = unlist(markers),size=pt.size,displayName=displayName,headers=paste(GeneNames(unlist(markers)),"(preX)",sep=""))
		p8<-plotDimReduceFeature(as.matrix(logcounts(decontX_sce2)),dim1 = umap[, 1],dim2 = umap[, 2],features = unlist(markers),size=pt.size,displayName=displayName,headers=paste(GeneNames(unlist(markers)),"(postX)",sep=""))
                p9<-plotDimReduceFeature(as.matrix(logcounts(decontX_sce3)),dim1 = umap[, 1],dim2 = umap[, 2],features = unlist(markers),size=pt.size,displayName=displayName,headers=paste(GeneNames(unlist(markers)),"(preX-postX)",sep=""))
		p10<-plotDecontXMarkerPercentage(decontX_sce, markers = markers, assayName = "counts")
                p11<-plotDecontXMarkerPercentage(decontX_sce, markers = markers,assayName = "decontXcounts")
                p12<-plotDecontXMarkerPercentage(decontX_sce, markers = markers,assayName = c("counts", "decontXcounts"))
                p13<-plotDecontXMarkerExpression(decontX_sce, unlist(markers))

		print(p7);print(p8);print(p9);print(p10);print(p11);print(p12);print(p13)

            }
        dev.off()
        
        # message
        print(paste("Download plot: ",outdir,"DecontX_",id,".pdf",sep=""))

        
        res<-decontXcounts(decontX_sce)
        rownames(res)<-rownames(cou)
        data[[i]]@assays$RNA@counts<-round(res)
        data[[i]]@meta.data<-cbind(data[[i]]@meta.data,decontX_contamination=colData(decontX_sce)[,2])

         # postfiltering
        if(do.postfiltering){
            ss1<-colSums(data[[i]]@assays$RNA@counts)
            II<-I(as.matrix(data[[i]]@assays$RNA@counts)>0)
            II<-ifelse(II==TRUE,1,0)
            ss2<-colSums(II)
            ww<-which(ss1<count.cut | ss2<feature.cut)
            if(length(ww)>0){
                data[[i]]<-data[[i]][,-ww]
            }
        }
    }

   return(list(Data=data,DecontX=dX))
}





#' Performs Seurat's HTO demultiplexing pipeline.
#'
#' Performs Seurat's HTO demultiplexing pipeline. It should be used only when HTO is required.
#' @param obj list. A list with the UMI (counts, feature names and barcodes) and HTO output for each sample.
#'   Typically, this is the output of read10xRNAs() function with a specified hto_folder.
#' @param outdir character. A foldet to store the plots.
#' @param id character. An id to use at the plot file names.
#' @param typeid character. An ID describing the type of data for HTO plotting. It is used the the filename of the 
#'   various plots. Default is filtered. The aother possible alternative is raw.
#' @param min.cells numeric. The minimum number of cells that a gene should be expressed in order to be kept in the
#'   analysis. Default is 3.
#' @param min.features numeric. The minimu number of genes that a cell should be expressed in order to be kept in
#'   the analysis. Default is 200.
#' @param regress.out character. One or more variables of the meta.data slot to regress in the SCTransform. 
#'   Default is NULL.
#' @param filter numeric. The minimum number of counts that a barcode should have to be kept in the analysis.
#'   Default is 100. The barcodes with less counts than the cutoff are removed from the UMI matrix, the HTO
#'   matrix and the barcode.names slot.
#' @param method character. The HTO demupliplexing method. One of Seurat (default) that uses Seurat's HTODemux()
#'   function or deMULTIplex that uses McGinnis' MULTIseqDemux() function. Both are implemented in Seurat.
#' @param q numeric. The positive quantile parameter of the HTODemux() or MULTIseqDemux() functions of Seurat. 
#'   Note that for a given q, HTODemux() and MULTIseqDemux() give very different results. The default q=0.99
#'   refers to HTODemux() default value. To obtain comparable results with MULTIseqDemux(), one should a lower q
#'   (close to 0.7). 
#' @param perpl numeric. The perplexity, i.e. expected number of neighbors for the tSNE dimensiolity reduction.
#'   Default is 30.
#' @param ncells numeric. Number of cells to plot. Default is to choose 5000 cells by random subsampling, to
#'   avoid having to draw exceptionally large heatmaps.
#' @param ch.dupl logical. Whether RunTSNE will check for duplicates, i.e. cells with the same PCA lodings. If TRUE
#'   and duplicates exist the function will stop with an error instructing the user to remove the duplicates. Default
#'   is FALSE.
#' @param tSNE_legend logical. If TRUE (default), the tSNE legend appears.
#' @param tSNE_goi character. Which features to show in the tSNE heatmap. Default is the first 6 HTO IDs.
#' @param do.hdbscan logical. If TRUE, hdbscan will cluster and annotate the data in order to improve the separation of singlets, 
#'   doublets and negatives. Default is FALSE. 
#' @param do.3d logical. If TRUE (default), a 3rd dimension is added in the HTO tSNE plot that contains the difference in the 
#'   normalized HTO values between the maxID HTO and the secondID HTO. The subsequent HDBSCAN clustering is then done in 3 dimensions. 
#' @param do.flexmix logical. Whether to run the flexmix clustering or not. Default is TRUE.
#' @param hdbscan.min.points numeric. Each value, acts as a minimum cluster size to detect, but also as a "smoothing" factor of the 
#'   density estimates implicitly computed from HDBSCAN. The algorithm iterates across the values and selects the one that gives
#'   the largest decrease in the number of clusters. Default is seq(10,100,5).
#' @param max.hdbscan.clusters numeric. HDBSCAN will iterate in the series of hdbscan.min.points and keep for further analysis 
#'   and plotting the (unique) ones that give less than max.hdbscan.clusters. Default is 10.
#' @param flex.k numeric. The number of flexmix cluters to be estimated from the HTO_margin ~ nCount_RNA model. Default is 3, i.e.
#'   HTO-specific, Doublets and Negatives.
#' @keywords Seurat_demux
#' @return An updated Seurat UMI object with the demultiplexing information and the estimated Singlets / Doublets.
#'
Seurat_demux<-function(obj,outdir,id,typeid="filtered",regress.out=NULL,min.cells=3,min.features=200,filter=100,
		       method="Seurat",q=0.99,perpl=30,ncells=5000,ch.dupl=TRUE,tSNE_legend=TRUE,tSNE_goi=c("HHTO1","HHTO2","HHTO3","HHTO4","HHTO5","HHTO6"),
		       do.hdbscan=FALSE,do.3d=TRUE,do.flexmix=TRUE,hdbscan.min.points=seq(10,100,5),max.hdbscan.clusters=10,flex.k=3){

    umiobj<-obj$UMI
    htoobj<-obj$HTO
    
    if(length(obj$HTO[[1]])==1){
        stop("The HTO component was not detected in this dataset. Skip this function.")
    }
    
    for(i in 1:length(umiobj)){

	ss<-colSums(umiobj[[i]]$mat)
	ww<-which(ss<filter)
	desi<-NULL
	if(length(ww)>0){
            umiobj[[i]]$mat<-umiobj[[i]]$mat[,-ww]
            htoobj[[i]]$mat<-htoobj[[i]]$mat[,-ww]
            umiobj[[i]]$barcode.names<-umiobj[[i]]$barcode.names[-ww,]
	    keepCC<-umiobj[[i]]$barcode.names
	    if(!is.null(umiobj[[i]]$design)){   
	    	desi<-data.frame(umiobj[[i]]$design[-ww,])
	    	colnames(desi)<-colnames(umiobj[[i]]$design)
	    }
	} else {
	    keepCC<-umiobj[[i]]$barcode.names
	    if(!is.null(umiobj[[i]]$design)){
		desi<-data.frame(umiobj[[i]]$design)
		colnames(desi)<-colnames(umiobj[[i]]$design)
	    }
	}

	# visualisation HTO
	sumH<-rowSums(htoobj[[i]]$mat)
	sumH<-data.frame(Name=names(sumH),Count=sumH)
	p<-ggplot(sumH,aes(x=Name,y=Count,fill=Name)) + geom_bar(stat="identity") + labs(y="Sum of counts",x="HTO") + ggtitle(paste("Sample ",names(umiobj)[i],sep=""))
	pdf(paste(outdir,"HTO_LibrarySize_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))
	    print(p)
	dev.off()
	# message
	print(paste("Download plot: ",outdir,"HTO_LibrarySize_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))

    	fn<-umiobj[[i]]$feature.names
    	umiobj[[i]]<-CreateSeuratObject(counts = umiobj[[i]]$mat,min.cells=min.cells,min.features=min.features)
    	umiobj[[i]]@assays$RNA@meta.features<-fn[match(rownames(umiobj[[i]]@assays$RNA@counts),rownames(fn)),]
    
	if(!is.null(desi)){
	    if(is.data.frame(keepCC)){
	    	mm<-match(rownames(umiobj[[i]]@meta.data),as.character(keepCC$common.barcodes),nomatch=0)
	    } else {
		mm<-match(rownames(umiobj[[i]]@meta.data),as.character(keepCC),nomatch=0)
	    }
	    umiobj[[i]]@meta.data<-cbind(umiobj[[i]]@meta.data,desi[mm,])
	    colnames(umiobj[[i]]@meta.data)[ncol(umiobj[[i]]@meta.data):(ncol(umiobj[[i]]@meta.data)-ncol(desi)+1)]<-colnames(desi)
	}
   	umiobj[[i]]<-SCTransform(umiobj[[i]],vars.to.regress=regress.out,method = "glmGamPoi")

	mm<-match(rownames(umiobj[[i]]@meta.data),colnames(htoobj[[i]]$mat),nomatch=0)
    	umiobj[[i]][["HTO"]]<-CreateAssayObject(counts = htoobj[[i]]$mat[,mm])
    	umiobj[[i]]<-NormalizeData(umiobj[[i]], assay = "HTO", normalization.method = "CLR")
	
	if(method=="Seurat"){
	    print(paste("Demultiplexing with HTODemux with q = ",q," (default is q = 0.99)",sep=""))
            umiobj[[i]]<-HTODemux(umiobj[[i]], assay = "HTO", positive.quantile = q)
	} else {
	    print(paste("Demultiplexing with MULTIseqDemux with q = ",q," (default is q = 0.70)",sep=""))
	    a<-MULTIseqDemux(object=umiobj[[i]],assay = "HTO",quantile = q)
	    umiobj[[i]]@meta.data$HTO_maxID<-a@meta.data$MULTI_ID
	    umiobj[[i]]@meta.data$HTO_secondID<-a@meta.data$MULTI_ID
	    umiobj[[i]]@meta.data$HTO_margin<-NA
	    umiobj[[i]]@meta.data$HTO_classification<-a@meta.data$MULTI_classification
	    b<-as.character(a@meta.data$MULTI_classification)
	    b[grep("_HHTO",b)]<-"Doublet"
	    umiobj[[i]]@meta.data$hash.ID<-factor(b)
	    b[grep("HHTO",b)]<-"Singlet"
	    umiobj[[i]]@meta.data$HTO_classification.global<-factor(b)
	}
    	umiobj[[i]]@meta.data$orig.ident<-names(umiobj)[i]
	
	mm<-match(as.character(umiobj[[i]]@meta.data$hash.ID),as.character(htoobj[[i]]$design[,1]))
	dd<-htoobj[[i]]$design[mm,]
	dd[is.na(dd)]<-"---"
	umiobj[[i]]@meta.data<-cbind(umiobj[[i]]@meta.data,HTO_Annotation=dd[,-1])        
      
	# visualisation1
        Idents(umiobj[[i]]) <- "HTO_maxID"
            
        pdf(paste(outdir,"HTO_Ridge_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))
            for(j in 1:length(rownames(umiobj[[i]][["HTO"]]))){
                p<-RidgePlot(umiobj[[i]], assay = "HTO", features = sort(rownames(umiobj[[i]][["HTO"]]))[j], ncol = 1) + theme(legend.position = "none")
                print(p)
            }
        dev.off()
     	
	# message       
        print(paste("Download plot: ",outdir,"HTO_Ridge_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))
   

        pdf(paste(outdir,"HTO_Signals_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))
            for(j1 in 1:(length(rownames(umiobj[[i]][["HTO"]]))-1)){
                for(j2 in (j1+1):length(rownames(umiobj[[i]][["HTO"]]))){
                    p<-FeatureScatter(umiobj[[i]], feature1=paste("hto_",rownames(umiobj[[i]][["HTO"]])[j1],sep=""),
                                                   feature2=paste("hto_",rownames(umiobj[[i]][["HTO"]])[j2],sep=""))
                    print(p)
                }
            }
        dev.off()

        # message       
        print(paste("Download plot: ",outdir,"HTO_Signals_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))


        # visualisation2
        Idents(umiobj[[i]]) <- "HTO_classification.global"
        
        pdf(paste(outdir,"HTO_RNA_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))
        p<-VlnPlot(umiobj[[i]], features = "nCount_RNA", pt.size = 0.1, log = TRUE)
            print(p)
            p<-VlnPlot(umiobj[[i]], features = "nFeature_RNA", pt.size = 0.1, log = TRUE)
            print(p)
        dev.off()
            
        # message       
        print(paste("Download plot: ",outdir,"HTO_RNA_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))


        # visualisation3
        DefaultAssay(umiobj[[i]]) <- "HTO"
        umiobj[[i]] <- ScaleData(umiobj[[i]], features = rownames(umiobj[[i]][["HTO"]]),verbose = FALSE)
        umiobj[[i]] <- RunPCA(umiobj[[i]], features = rownames(umiobj[[i]][["HTO"]]), approx = FALSE)
        umiobj[[i]] <- RunTSNE(umiobj[[i]], dims = 1:length(rownames(umiobj[[i]][["HTO"]])), perplexity = perpl,check_duplicates = ch.dupl)
        
        hmtsneout<-hmtsneout2<-NULL

	# HDBSCAN implementation
	if(do.hdbscan){
	   print("Running HDBSCAN...")
	   x<-cbind(umiobj[[i]]@reductions$tsne@cell.embeddings,HTO_margin=umiobj[[i]]$HTO_margin,nCount_RNA=umiobj[[i]]$nCount_RNA)
	   x<-data.frame(x)
   
	   cl<-as.list(rep(0,length(hdbscan.min.points)))
	   number.of.cl<-rep(0,length(hdbscan.min.points))
	   for(j in 1:length(hdbscan.min.points)){
		if(do.3d){
	   	   cl[[j]] <- hdbscan(x[,1:3], minPts = hdbscan.min.points[j])
		} else {
		   cl[[j]] <- hdbscan(x[,1:2], minPts = hdbscan.min.points[j])
		}
	   	number.of.cl[j]<-length(unique(cl[[j]][[1]]))
	    	print(paste("Completed HDBSCAN with minPts = ",hdbscan.min.points[j]," (iteration ",j," of ",length(hdbscan.min.points),"): ",number.of.cl[j]," clusters",sep=""))
	   }
	   noc<-paste(range(number.of.cl),collapse=",")


	   feats<-3
	   o<-which(number.of.cl<feats | number.of.cl>max.hdbscan.clusters)
	   if(length(o)==length(number.of.cl)){
	   	o<-which(number.of.cl<feats)
	  	if(length(o)==length(number.of.cl)){
		   stop("The number of clusters are less than the examined features (HTOs, doublets, negative). Decrease the minimum of hdbscan.min.points")
		}
		if(length(o)>0){
	   	   number.of.cl<-number.of.cl[-o]
	   	   hdbscan.min.points<- hdbscan.min.points[-o]
	   	   cl<-cl[-o]
		}
	   	max.hdbscan.clusters<-min(number.of.cl)
	   	o<-which(number.of.cl<feats | number.of.cl>max.hdbscan.clusters)
	   	print(paste("The HDBSCAN clusters range in [",noc,"]. None of the clusters satisfies the criteria. Updating max.hdbscan.clusters to ",max.hdbscan.clusters,".",sep=""))
	   }
	   if(length(o)>0){
	   	hdbscan.min.points<-hdbscan.min.points[-o]
	   	number.of.cl<-number.of.cl[-o]
	   	cl<-cl[-o]
	   }
	   
	   if(do.flexmix){
	   	flex<-flexmix(HTO_margin~nCount_RNA,data=x,k=flex.k)
	   	flex<-clusters(flex)
	   } else {
	  	flex<-rep(1,nrow(x))
	   }
	   umiobj[[i]]@meta.data<-cbind(umiobj[[i]]@meta.data,Flexmix_clusters=flex)
	   umiobj[[i]]$Flexmix_clusters<-factor(umiobj[[i]]$Flexmix_clusters)

	   print(paste("These number of clusters (possibly with different hdbscan.min.points combinations) will be highlighted on the tSNE: ",paste(sort(unique(number.of.cl)),collapse=","),sep=""))
	   
	   #x<- umiobj[[i]]
	   #x@meta.data<-cbind(x@meta.data,HDBSCAN_clusters=cl[[1]][[1]])

           hmtsneout<-hmtsneout1<-hmtsneout2<-as.list(rep(0,length(cl)))
           nn<-rep(0,length(hmtsneout))
           heattsne_dims <- RunTSNE(umiobj[[i]], dims = 1, dim.embed=1,perplexity = perpl,check_duplicates = ch.dupl)
	   umiobj[[i]]@meta.data<-cbind(umiobj[[i]]@meta.data,tsne1d=heattsne_dims@reductions$tsne@cell.embeddings)
           #pdf(paste(outdir,"HTO_tSNEHeatmap_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""),width=10,height=10)
              for(j in 1:length(cl)){

		   hmtsneout2[[j]] <- tsnehm2(obj= umiobj[[i]],
                                       goi=tSNE_goi,
				       number.of.cl= number.of.cl[j],hdbscan.min.points=hdbscan.min.points[j],
                                       tsne_embedding=heattsne_dims@reductions$tsne@cell.embeddings,
                                       cell_labels=cl[[j]][[1]])
                   pdf(paste(outdir,"HTO_tSNEHeatmap2_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,"_page",j,".pdf",sep=""))
                      print(hmtsneout2[[j]][[2]])
                   dev.off()
		
	   
		   cc<-hmtsneout2[[j]][[1]]@meta.data$tsne1d.cl.simplified
		   #cc<-cc[match(rownames(umiobj[[i]]@meta.data),rownames(cc))]

                   hmtsneout[[j]] <- tsnehm1(expression_matrix= umiobj[[i]][['HTO']]@data,
                                       metadata=umiobj[[i]]$hash.ID,
                                       goi=tSNE_goi,
                                       cell_labels=cl[[j]][[1]],extra_cell_labels=cc)
                   pdf(paste(outdir,"HTO_tSNEHeatmap_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,"_page",j,".pdf",sep=""))
                      grid::grid.rect(gp = grid::gpar("fill", col = NA))
                      grid::grid.draw(hmtsneout[[j]]$gtable)
                      print(hmtsneout[[j]])
                   dev.off()

		   
		   cc<-as.numeric(as.character(hmtsneout2[[j]][[1]]@meta.data$tsne1d.cl.order))
		   sl<-order(cc,hmtsneout2[[j]][[1]]$hash.ID)
		   new.cc<-hmtsneout2[[j]][[1]]@meta.data$tsne1d.cl.simplified[sl]
		   new.data<-umiobj[[i]][['HTO']]@data[,sl]
		   new.meta<-umiobj[[i]]$hash.ID[sl]
	   	   new.cell_labels<-cl[[j]][[1]][sl]
		   hmtsneout1[[j]] <- tsnehm1(expression_matrix=new.data,
                                       metadata=new.meta,
                                       goi=tSNE_goi,
                                       cell_labels=new.cell_labels,extra_cell_labels=new.cc,ordering=FALSE)
                   pdf(paste(outdir,"HTO_tSNEHeatmap1_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,"_page",j,".pdf",sep=""))
                      grid::grid.rect(gp = grid::gpar("fill", col = NA))
                      grid::grid.draw(hmtsneout1[[j]]$gtable)
                      print(hmtsneout1[[j]])
                   dev.off()
		 

                   nn[j]<-paste("tSNE_Heatmap_with_",number.of.cl[j],"_clusters_and_",hdbscan.min.points[j],"_minPts",sep="")

              }
	
	      pflex<-ggplot(umiobj[[i]]@meta.data,aes(x=nCount_RNA,y=HTO_margin,color=Flexmix_clusters)) + geom_point()
	      pdf(paste(outdir,"HTO_flex_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))
		print(pflex)
              dev.off()

           names(hmtsneout)<-nn
	   pdf_combine(c(paste(outdir,"HTO_tSNEHeatmap_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,"_page",1:length(cl),".pdf",sep=""),
			 paste(outdir,"HTO_tSNEHeatmap1_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,"_page",1:length(cl),".pdf",sep=""),
			 paste(outdir,"HTO_tSNEHeatmap2_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,"_page",1:length(cl),".pdf",sep=""),
			 paste(outdir,"HTO_flex_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep="")),
			 output = paste(outdir,"HTO_tSNEHeatmap_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))  

	   for(j in 1:length(cl)){
		unlink(paste(outdir,"HTO_tSNEHeatmap_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,"_page",j,".pdf",sep=""))
		unlink(paste(outdir,"HTO_tSNEHeatmap1_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,"_page",j,".pdf",sep=""))
		unlink(paste(outdir,"HTO_tSNEHeatmap2_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,"_page",j,".pdf",sep=""))
	   }
	   unlink(paste(outdir,"HTO_flex_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))

	   # message       
           print(paste("Download plot: ",outdir,"HTO_tSNEHeatmap_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))
	   
	   umiobj[[i]]<-hmtsneout2[[1]][[1]]

	   for(j in 2:length(hmtsneout2)){
		gg<-grep("tsne1d.cl",colnames(hmtsneout2[[j]][[1]]@meta.data))
		umiobj[[i]]@meta.data<-cbind(umiobj[[i]]@meta.data,hmtsneout2[[j]][[1]]@meta.data[,gg])
	   }
	
	   for(j in 1:length(number.of.cl)){
	   	umiobj[[i]]@meta.data<-cbind(umiobj[[i]]@meta.data,cl[[j]][[1]])
	   	l1<-paste("hdbscan_clusters_",number.of.cl[j],"_",hdbscan.min.points[j],sep="")
	   	colnames(umiobj[[i]]@meta.data)[ncol(umiobj[[i]]@meta.data)]<-l1
	   	labs<-apply(cbind(as.character(umiobj[[i]]$hash.ID),
				  paste("C",umiobj[[i]]@meta.data[,which(colnames(umiobj[[i]]@meta.data)==l1)],sep=""),
				  paste("F",umiobj[[i]]@meta.data[,which(colnames(umiobj[[i]]@meta.data)=="Flexmix_clusters")],sep="")),1,paste,collapse=":")

		new<-aggregate(x$HTO_margin,list(labs),quantile,c(0.25,0.75))
		new1<-rep(0,length(labs))
		for(s in 1:nrow(new)){
		   new1[labs==new[s,1]]<-paste("[",round(as.numeric(as.character(new[s,2][1])),2),",",round(as.numeric(as.character(new[s,2][2])),2),"]",sep="")
		}
		labs<-apply(cbind(labs,new1),1,paste,collapse=":")

	   	umiobj[[i]]@meta.data<-cbind(umiobj[[i]]@meta.data,labs)
           	colnames(umiobj[[i]]@meta.data)[ncol(umiobj[[i]]@meta.data)]<-paste("hdbscan_HTO_labels_",number.of.cl[j],"_",hdbscan.min.points[j],sep="")
	   	labs<-apply(cbind(as.character(umiobj[[i]]$HTO_classification.global),
				  paste("C",umiobj[[i]]@meta.data[,which(colnames(umiobj[[i]]@meta.data)==l1)],sep=""),
				  paste("F",umiobj[[i]]@meta.data[,which(colnames(umiobj[[i]]@meta.data)=="Flexmix_clusters")],sep="")),1,paste,collapse=":")

                new<-aggregate(x$HTO_margin,list(labs),quantile,c(0.25,0.75))
                new1<-rep(0,length(labs))
                for(s in 1:nrow(new)){
                   new1[labs==new[s,1]]<-paste("[",round(as.numeric(as.character(new[s,2][1])),2),",",round(as.numeric(as.character(new[s,2][2])),2),"]",sep="")
                }
                labs<-apply(cbind(labs,new1),1,paste,collapse=":")
		
           	umiobj[[i]]@meta.data<-cbind(umiobj[[i]]@meta.data,labs)
           	colnames(umiobj[[i]]@meta.data)[ncol(umiobj[[i]]@meta.data)]<-paste("hdbscan_GlobalHTO_labels_",number.of.cl[j],"_",hdbscan.min.points[j],sep="")
	   }
	
	
           pdf(paste(outdir,"HTO_tSNE_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""),width=10,height=10)
            	p<-DimPlot(umiobj[[i]],label=TRUE)
            	print(p)
	    	ww1<-grep("hdbscan_HTO_labels_",colnames(umiobj[[i]]@meta.data))
            	ww2<-grep("hdbscan_GlobalHTO_labels_",colnames(umiobj[[i]]@meta.data))
	    	for(j in 1:length(ww1)){
		   
		   u1<-umiobj[[i]]@meta.data[,ww1[j]]
		   if(tSNE_legend){
	    	      p<-DimPlot(umiobj[[i]],group.by=colnames(umiobj[[i]]@meta.data)[ww1[j]],label=TRUE,label.size = 2)+theme(legend.text=element_text(size=3))
		   } else {
                      p<-DimPlot(umiobj[[i]],group.by=colnames(umiobj[[i]]@meta.data)[ww1[j]],label=TRUE,label.size = 2)+NoLegend()
		   }
	    	   print(p)

		   u2<-umiobj[[i]]@meta.data[,ww2[j]]
		   if(tSNE_legend){
			p<-DimPlot(umiobj[[i]],group.by=colnames(umiobj[[i]]@meta.data)[ww2[j]],label=TRUE,label.size = 2) + theme(legend.text=element_text(size=3))
		   } else {
                        p<-DimPlot(umiobj[[i]],group.by=colnames(umiobj[[i]]@meta.data)[ww2[j]],label=TRUE,label.size = 2) + NoLegend()
		   }
                   print(p)
		   
	    	}
		
		plot(x$nCount_RNA,x$HTO_margin,pch=20,cex=0.6,col=flex)
		cols<-c("black","red","green","blue","cyan","purple","yellow")
		p<-DimPlot(umiobj[[i]],group.by="Flexmix_clusters",label=TRUE,label.size=2) + scale_color_manual(values=cols[1:length(unique(flex))])
		print(p)

	   dev.off()

	} else {
	   pdf(paste(outdir,"HTO_tSNE_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))
           	p<-DimPlot(umiobj[[i]],label=TRUE)
               	print(p)
	   dev.off()   
	}

        # message       
        print(paste("Download plot: ",outdir,"HTO_tSNE_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))


        # visualisation 4
        pdf(paste(outdir,"HTO_Heat_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))
            p<-HTOHeatmap(umiobj[[i]], assay = "HTO", ncells = ncells)
            print(p)
        dev.off()

        # message       
        print(paste("Download plot: ",outdir,"HTO_Heat_",id,"_",names(umiobj)[i],"_",typeid,"_q",q*100,".pdf",sep=""))


    }
    
    w<-which(colnames(umiobj[[i]]@meta.data)=="HTO_classification.global")
    colnames(umiobj[[i]]@meta.data)[w]<-"HTO_doublet"
 
    w1<-which(umiobj[[i]]@meta.data$HTO_doublet=="Doublet")
    w2<-which(umiobj[[i]]@meta.data$HTO_doublet=="Singlet")
    w3<-which(umiobj[[i]]@meta.data$HTO_doublet=="Negative")  
    umiobj[[i]]@meta.data$HTO_doublet[w1]<-"doublet"
    umiobj[[i]]@meta.data$HTO_doublet[w2]<-"singlet"
    umiobj[[i]]@meta.data$HTO_doublet[w3]<-"unassigned"
       
 return(umiobj)
}




#' Compute t-SNE Heatmap
#'
#' Experimental version of t-SNE heatmaps codes
#'
#' @param expression_matrix data frame. The expressoins to be plotted. typically the data slot of the seurat object.
#' @param goi character. The genes of interest to be shown in the heatmap rows.
#' @param tsne_embedding numeric. The tSNE 1st dimension.
#' @param cell_labels numeric. Typically these are the cluster assignments for each cell obtained by tSNE clustering with 
#'   a density-clutering method such as HDBSCAN.
#' @param extra_cell_labels numeric. Typically these are the cluster assignments for each cell obtained by an additional method
#'   such as the flexmix model on HTO_margin~nCount_RNA. 
#' @param ordering logical. If TRUE (default), it orders the columns of the heatmap by metadata, extra_cell_labels (the labels
#'   obtained from the tSNE heatmap) and cell_labels (the labels obtained from HDBSCAN). If FALSE, the data are assumed ordered
#'   and on'y a secondary ordering of the metadata within the extra_cell_labels is performed.
#' @param metadata character. A vector of values from the meta.data of the seurat object to be depicted in the heatmap.
#' @keywords tsnehm1
#' @return A heatmap tsne
#'
tsnehm1 <- function(expression_matrix, goi, cell_labels,extra_cell_labels,metadata,ordering=T){
  
  nonempty_genes <- rowSums(expression_matrix) > 0;
  expression_matrix <- expression_matrix[nonempty_genes,]
  
  notinrows <- !(goi%in% rownames(expression_matrix));
  if (sum(notinrows) > 0){
    print(sprintf("The following rows are not in the matrix: %s", paste(goi[notinrows])))
  }
  goi <- goi[!notinrows]
  expression_matrix <- expression_matrix[goi,]
  
 
  clabs<-data.frame(cbind(as.character(metadata),factor(extra_cell_labels),factor(cell_labels)))
  row.names(clabs)<-colnames(expression_matrix)
  colnames(clabs)<-c("hashID","tSNEheat","dbscan")
  cal_z_score <- function(x){
  	(x - mean(x))
  }
 
  mat <- t(apply(expression_matrix, 1, cal_z_score))

  if(ordering){
  	oo<-order(clabs[,1],as.numeric(as.character(clabs[,2])),as.numeric(as.character(clabs[,3])))
  	mat1<-mat[,oo]
  	p <- pheatmap(as.matrix(mat1),annotation_col = clabs,cluster_cols = FALSE,annotation_names_col=FALSE,show_colnames=FALSE,fontsize=5,main="All cells, hashID ordered")
  	dev.off()
   } else {
	clabs<-clabs[,c(2,1,3)]	
	p <- pheatmap(as.matrix(mat),annotation_col = clabs,cluster_cols = FALSE,annotation_names_col=FALSE,show_colnames=FALSE,fontsize=5,main="All cells, tSNEdendro ordered")	
   }


 return(p) 

}



#' Compute t-SNE Heatmap
#'
#' Experimental version of t-SNE heatmaps codes
#'
#' @param obj object. The seurat object whose HTOs will be interrogated.
#' @param goi character. The genes of interest to be shown in the heatmap rows.
#' @param number.of.cl numeric. The number of clusters found by HDBSCAN.
#' @param hdbscan.min.points numeric. The minimum number of cells in the DBSCAN clusters.
#' @param tsne_embedding numeric. The tSNE 1st dimension.
#' @param cell_labels numeric. Typically these are the cluster assignments for each cell obtained by tSNE clustering with 
#'   a density-clutering method such as HDBSCAN.
#' @param breaks numeric. Number of bins. Default is 100.
#' @param slope numeric. For better visualization, transform the values with a logistic function. This is the slope of that function.
#'   Default is 50
#' @param intercept numeric. For better visualization, transform the values with a logistic function. This is the intercept of that function.
#'   Defaur is 0.05.
#' @keywords tsnehm2
#' @return A heatmap tsne
#'
tsnehm2 <- function(obj,goi,number.of.cl,hdbscan.min.points, tsne_embedding, cell_labels, breaks=100, slope=50, intercept=0.05){
  
  expression_matrix<-obj[['HTO']]@data
  nonempty_genes <- rowSums(expression_matrix) > 0;
  expression_matrix <- expression_matrix[nonempty_genes,]
  
  notinrows <- !(goi%in% rownames(expression_matrix));
  if (sum(notinrows) > 0){
    print(sprintf("The following rows are not in the matrix: %s", paste(goi[notinrows])))
  }
  goi <- goi[!notinrows]
  expression_matrix <- expression_matrix[goi,]
  
  tsne_bins <- cut(tsne_embedding, breaks = breaks)
  bin_counts <- aggregate.Matrix(t(expression_matrix), tsne_bins)
  empty_bins <- levels(tsne_bins)[!levels(tsne_bins)  %in% rownames(bin_counts)]
  empty_bins_matrix <- matrix(0, nrow = length(empty_bins), ncol = ncol(bin_counts))
  rownames(empty_bins_matrix) <- empty_bins
  bin_counts <- rbind(bin_counts, empty_bins_matrix)
  bin_counts <- bin_counts[levels(tsne_bins), ]
  bin_counts_s <- t(t(bin_counts) / rowSums(t(bin_counts)))
  
  #assign a label to each column based on which of the cell_labels is the most common
  dbscan_tsne <- data.frame(x=tsne_embedding, y=cell_labels)
  dbscan_group <- split(dbscan_tsne, cut(dbscan_tsne[,1], breaks = breaks))
  Mode <- function(x) {
    ux <- unique(x)
    ux[which.max(tabulate(match(x, ux)))]
  }
  group_labels <- unlist(lapply(dbscan_group, function(x) Mode(x[,2])))
  rownames(bin_counts_s) <- sprintf("bin:%s, label: %d", rownames(bin_counts_s), group_labels)
  group_labels[is.na(group_labels)] <- NA
  #if (enrich > 0){
  #  gene_colors <- rep(0, length(enriched_genes));
  # }else{
    gene_colors <-c();
  #}
  gene_colors[colnames(bin_counts_s) %in% goi] <- 1
  
  my_palette <- colorRampPalette(c("white", "red"))(n = 1000)
  row_color_palette <- colorRampPalette(c("white", "blue"))
  col_color_palette <- colorRampPalette(brewer.pal(n = max(group_labels+1,na.rm=TRUE),"Spectral"))
  toplot <- t(bin_counts_s)
  
  toplot2 <- 1/(1+exp(slope*intercept-slope*toplot))
  return_list <- list()

  p<-pheatmap(as.matrix(toplot2),cluster_cols = TRUE,annotation_names_col=FALSE,show_colnames=FALSE,fontsize=5)
  ocl<-p$tree_col$order
  toplot2<-toplot2[,ocl]
  toplot3<-toplot2
  group_labels<-group_labels[ocl]
  group_labels<-data.frame(matrix(group_labels,ncol=1))
  rownames(group_labels)<-colnames(toplot3)
  colnames(group_labels)<-"tsne1d.cl"
  group_labels[,1]<-factor(group_labels[,1])

  ll<-t(matrix(unlist(strsplit(as.character(colnames(toplot3)),"],",fixed=T)),nrow=2))[,1]
  ll<-t(matrix(unlist(strsplit(as.character(ll),":(",fixed=T)),nrow=2))[,2]
  ll<-t(matrix(unlist(strsplit(as.character(ll),",",fixed=T)),nrow=2))
  tsne1d.cl<-matrix(0,nrow(obj@meta.data),2)
  for(j in 1:nrow(ll)){
	w<-which(as.numeric(as.character(obj@meta.data$tSNE_1))>as.numeric(as.character(ll[j,1])) & as.numeric(as.character(obj@meta.data$tSNE_1))<=as.numeric(as.character(ll[j,2])))
	tsne1d.cl[w,1]<-colnames(toplot3)[j]
	tsne1d.cl[w,2]<-j
  }

  ll<-as.numeric(as.character(t(matrix(unlist(strsplit(as.character(tsne1d.cl[,1]),":",fixed=T)),nrow=3))[,3]))
  obj@meta.data<-cbind(obj@meta.data,tsne1d.cl[,1],ll,tsne1d.cl[,2])
  colnames(obj@meta.data)[(ncol(obj@meta.data)-2):ncol(obj@meta.data)]<-c(paste("tsne1d.cl_",number.of.cl,"_",hdbscan.min.points,sep=""),
									  paste("tsne1d.cl.simplified_",number.of.cl,"_",hdbscan.min.points,sep=""),
									  paste("tsne1d.cl.order_",number.of.cl,"_",hdbscan.min.points,sep=""))

  return_list$heatmap<-pheatmap(as.matrix(toplot3),annotation_col = group_labels,cluster_cols = FALSE,annotation_names_col=FALSE,show_colnames=FALSE,fontsize=5,main="tSNEheatmap")
  dev.off()
 
  return(list(obj,return_list$heatmap))
}

genes_tsne_vecs <- function(expression_matrix, tsne_embedding, breaks=100 ){
  
  if (class(expression_matrix) != "dgCMatrix") {
    expression_matrix <- as(expression_matrix, "dgCMatrix")
  }
  
  nonempty_cells <- colSums(expression_matrix) > 0;
  expression_matrix <- expression_matrix[,nonempty_cells]
  tsne_embedding <- tsne_embedding[nonempty_cells]
  
  nonempty_genes <- rowSums(expression_matrix) > 0;
  expression_matrix <- expression_matrix[nonempty_genes,]
  
  tsne_bins <- cut(tsne_embedding, breaks = breaks)
  bin_counts <- aggregate.Matrix(t(expression_matrix), tsne_bins)
  empty_bins <- levels(tsne_bins)[!levels(tsne_bins)  %in% rownames(bin_counts)]
  empty_bins_matrix <- matrix(0, nrow = length(empty_bins), ncol = ncol(bin_counts))
  rownames(empty_bins_matrix) <- empty_bins
  bin_counts <- rbind(bin_counts, empty_bins_matrix)
  bin_counts <- bin_counts[levels(tsne_bins), ]

  outmat <- t(t(bin_counts) / rowSums(t(bin_counts)))
  colnames(outmat) <- rownames(expression_matrix)
  outmat
}






#' Combines the barcode call of the filtered and raw cellranger data and subsequently filters out doublets and,
#'   if desirable, negatives to generate an intermediate list of barcodes for further processing.
#'
#' Combines the barcode call of the filtered and raw cellranger data and subsequently filters out doublets and,
#'   if desirable, negatives to generate an intermediate list of barcodes for further processing. The use of raw data
#'   requires HTOs. In such case, the user may decide if the negativs are to be filtered out. If HTOs are not available,
#'   the algorithm will filter out doublets generated by Souporcell or other similar algorithms. Thus HTOs and Souporcell
#'   type of estimation are strictly equired for this function to be applied.
#' @param filtered object. A Seurat object with the barcodes of the filtered cellranger data. Typically the output
#'   of the Seurat_demux() function on the 'filtered_features_bc_matrix' folder.
#' @param raw object. A Seurat object with the barcodes of the raw cellranger data. Typically the output of the 
#'   Seurat_demux() function on the 'raw_features_bc_matrix' folder. Default is NULL.
#' @param remove.negatives logical. If TRUE (default), the negative labeled cells of the HTO analysis will be filtered out.
#' @param regress.out character. One or more variables of the meta.data slot to regress in the SCTransform. 
#'   Default is NULL.
#' @param min.cells numeric. The minimum number of cells that a gene should be expressed in order to be kept in the
#'   analysis. Applicable only if the raw!=NULL where the Seurat matrix is updated. Default is 3.
#' @param min.features numeric. The minimu number of genes that a cell should be expressed in order to be kept in
#'   the analysis. Applicable only if the raw!=NULL where the Seurat matrix is updated. Default is 200.
#' @keywords final.bCall
#' @return An updated Seurat object with the final barcodes.
#'   
final.bCall<-function(filtered,raw=NULL,remove.negatives=TRUE,regress.out=NULL,min.cells=3,min.features=200){
    
    if(!is.null(raw)){
        
        ide<-identical(sort(names(filtered)),sort(names(raw)))
        if(!ide){
            stop("The names of the filtered and raw objects must match.")
        }
        sl<-sort.list(names(raw))
        raw<-raw[sl]
        sl<-sort.list(names(filtered))
        filtered<-filtered[sl]
        
        for(i in 1:length(raw)){
            
            if(length(which(colnames(filtered[[i]]@meta.data)=="hash.ID"))==0){
                stop("This function is used only when HTO data are available.")
            }

            oo_raw<-raw[[i]]@meta.data[raw[[i]]@meta.data$hash.ID!="Doublet" &
                                       raw[[i]]@meta.data$hash.ID!="Negative",]
            ss<-setdiff(rownames(oo_raw),rownames(filtered[[i]]@meta.data))
            
            if(length(ss)>0){
                cou_filt<-filtered[[i]]@assays$RNA@counts
                cou_raw<-raw[[i]]@assays$RNA@counts
                mm1<-match(rownames(cou_filt),rownames(cou_raw),nomatch=0)
                mm2<-match(ss,colnames(cou_raw),nomatch=0)
                cou_filt<-cbind(cou_filt,cou_raw[mm1,mm2])
                qq<-c(rep("in",nrow(filtered[[i]]@meta.data)),rep("out",nrow(raw[[i]]@meta.data[mm2,])))
                meta<-cbind(rbind(filtered[[i]]@meta.data,raw[[i]]@meta.data[mm2,]),cellrangerQC=qq)
                
                print("Updating the Seurat object with the final barcode calling.")
                new<-CreateSeuratObject(counts = cou_filt,min.cells=min.cells,min.features=min.features)
                new<-SCTransform(new,vars.to.regress=regress.out,method = "glmGamPoi")
                ss<-setdiff(colnames(meta),colnames(new@meta.data))
                new@meta.data<-cbind(new@meta.data,meta[,match(ss,colnames(meta))])
                filtered[[i]]<-new
            }

        }
        
    }
        
    for(i in 1:length(filtered)){
        
        if(length(which(colnames(filtered[[i]]@meta.data)=="hash.ID"))>0){
            
            if(remove.negatives){
                w<-which(filtered[[i]]@meta.data$hash.ID=="Doublet" | filtered[[i]]@meta.data$hash.ID=="Negative")
                if(length(w)>0){
                    filtered[[i]]<-filtered[[i]][,-w]
                }
            } else {
                w<-which(filtered[[i]]@meta.data$hash.ID=="Doublet")
                if(length(w)>0){
                    filtered[[i]]<-filtered[[i]][,-w]
                }
            }
        }
            
        if(length(which(colnames(filtered[[i]]@meta.data)=="Souporcell_doublet"))>0){
            w<-which(filtered[[i]]@meta.data$Souporcell_doublet=="doublet" | filtered[[i]]@meta.data$Souporcell_doublet=="Doublet")
            if(length(w)>0){
                filtered[[i]]<-filtered[[i]][,-w]
            }
        }
    
    }
  return(filtered)
}




#' Generates interactive plotly dotplots of sorted metric values to determine appropriate QC cutoffs.
#'
#' Generates interactive plotly dotplots of sorted metric values to determine appropriate QC cutoffs. It considers the metrics
#'   nFeature_RNA, nCount_RNA, percent.mt and percent.hb. All of them are calulated internally in Seurat_QC() function.
#' @param summary_data data frame. A data fram with the values of above metrics for each cell.
#' @param plot.filename character. The filename (and the appropriate path) to store the plots
#' @param inspect numeric. The percentage of extreme cells to inspect (up and down separately) for each metric
#'   in order to determine the cutoffs. These cells are colored differently.
#' @param pcex numeric. A value defining the size of the plotted dots.
#' @keywords SeuratQC_idotplot
#' @return A set of interactive dotplots. The user can apply the zoom in utility and select the cutoffs of interest.
#'
SeuratQC_idotplot<-function(summary_data,plot.filename,inspect=0.2,pcex=0.2){
    
    p<-as.list(rep(0,ncol(summary_data)))
    for(i in 1:ncol(summary_data)){

        tit<-c()
        if(colnames(summary_data)[i]=="nFeature_RNA"){
            tit<-"Remove low & high"
        }
        if(colnames(summary_data)[i]=="nCount_RNA"){
            tit<-"Remove low & high"
        }
        if(colnames(summary_data)[i]=="percent.mt"){
            tit<-"Ignore low & Remove high"
        }
        if(colnames(summary_data)[i]=="percent.hb"){
            tit<-"Ignore low & Remove high"
        }

        xaxis<- list(
            title = "Cells",
            zeroline = FALSE,
            showline = FALSE,
            showticklabels = TRUE,
            showgrid = FALSE)

        yaxis<- list(
            title = colnames(summary_data)[i],
            zeroline = FALSE,
            showline = FALSE,
            showticklabels = TRUE,
            showgrid = FALSE)

        s1<-sort(as.numeric(as.character(summary_data[,i])))
        qq<-quantile(s1,c(inspect,1-inspect))
        cols<-rep("black",nrow(summary_data))
        cols[s1<=qq[[1]]]<-"#00B0F6"
        cols[s1>=qq[[2]]]<-"#F8766D"
        data.all<-data.frame(X=1:length(s1),Data=s1,Colors=cols)

        p[[i]]<-plot_ly(data=data.all,
                        x=~X,
                        y=~Data,
                        type="scatter",
                        mode = "markers", marker = list(color = ~Colors,size=pcex*10),
                        text=colnames(summary_data)[i],
                        name=colnames(summary_data)[i],
                        showlegend=FALSE) %>%
                        layout(title = "",xaxis = xaxis,yaxis = yaxis) %>%
                        add_annotations(
                                        x=median(data.all$X),
                                        y=0.8*max(data.all$Data),
                                        xref = "x",
                                        yref = "y",
                                        text = paste("<b>",colnames(summary_data)[i],":</b> <br>",tit,sep=""),
                                        xanchor = 'center',
                                        showarrow = F)
    
    }
    p1234<-subplot(p[[1]],p[[2]],p[[3]],p[[4]],nrows=2,titleY = FALSE, shareX = TRUE)
    saveWidget(p1234,plot.filename,selfcontained = FALSE)

  return(p1234)
}


#' Generates noninteractive ggplot2 dotplots of sorted metric values to determine appropriate QC cutoffs.
#'
#' Generates noninteractive ggplot2 dotplots of sorted metric values to determine appropriate QC cutoffs. It considers the metrics
#'   nFeature_RNA, nCount_RNA, percent.mt, percent.hb and decontX_contamination. All of them are calulated internally in Seurat_QC() 
#'   function.
#' @param summary_data data frame. A data fram with the values of above metrics for each cell.
#' @param plot.filename character. The filename (nd the appropriate path) to store the plots
#' @param inspect numeric. The percentage of extreme cells to inspect (up and down separately) for each metric
#'   in order to determine the cutoffs. These cells are plotted in separate plots.
#' @param pcex numeric. A value defining the size of the plotted dots.
#' @keywords SeuratQC_dotplot
#' @return A set of noninteractive dotplots. The user can select the cutoffs of interest with the aid of the horizontal lines.
#'
SeuratQC_dotplot<-function(summary_data,inspect,pcex,plot.filename){

    pdf(plot.filename)
        par(mfrow=c(1,3))
        for(i in 1:ncol(summary_data)){

            s1<-sort(as.numeric(as.character(summary_data[,i])))
            qq<-quantile(s1,c(inspect,1-inspect))
            cols<-rep("black",nrow(summary_data))
            cols[s1<=qq[[1]]]<-"#00B0F6"
            cols[s1>=qq[[2]]]<-"#F8766D"
            plot(s1,cex=pcex,col=cols,xlab="Number of barcodes",ylab=colnames(summary_data)[i])

            tit<-rep("",3)
            if(colnames(summary_data)[i]=="nFeature_RNA"){
                tit[2]<-"Remove low"
                tit[3]<-"Remove high"
            }
            if(colnames(summary_data)[i]=="nCount_RNA"){
                tit[2]<-"Remove low"
                tit[3]<-"Remove high"
            }
            if(colnames(summary_data)[i]=="percent.mt"){
                tit[2]<-"Ignore low"
                tit[3]<-"Remove high"
            }
            if(colnames(summary_data)[i]=="percent.hb"){
                tit[2]<-"Ignore low"
                tit[3]<-"Remove high"
            }

	    if(colnames(summary_data)[i]=="decontX_contamination"){
                tit[2]<-"Ignore low"
                tit[3]<-"Remove high"
            }

            bot<-s1[s1<=qq[[1]]]
            plot(bot,cex=pcex,xlab=paste("Number of barcodes (bottom ",100*inspect,"%)",sep=""),ylab=colnames(summary_data)[i],col="#00B0F6",main=tit[2])
            dd<-diff(bot)
            qbottom<-quantile(dd,0.99)
            qbottom<-bot[which(dd>qbottom)]
            abline(h=qbottom,lty="dashed",col="gray")
            axis(side=4, at=qbottom, labels = FALSE)
            if(length(qbottom)>0){
                text(par("usr")[1], qbottom, labels = qbottom, pos=4, offset=5,xpd = TRUE,cex=0.6)
            }
            
            top<-s1[s1>=qq[[2]]]
            plot(top,cex=pcex,xlab=paste("Number of barcodes (top ",100*inspect,"%)",sep=""),ylab=colnames(summary_data)[i],col="#F8766D",main=tit[3])
            dd<-diff(top)
            qtop<-quantile(dd,0.99)
            qtop<-top[which(dd>qtop)]
            abline(h=qtop,lty="dashed",col="gray")
            axis(side=4, at=qtop, labels = FALSE)
            if(length(qtop)>0){
                text(par("usr")[1], qtop, labels = qtop, pos = 4, offset=5, xpd = TRUE,cex=0.6)
            }
        }
	
	
	cols<-rep("gray",nrow(summary_data))
	ww<-which(colnames(summary_data)=="decontX_contamination")
	if(length(ww)>0){
	    summary_data[,ww]<-as.numeric(as.character(summary_data[,ww]))
	    p1<-ggplot(summary_data,aes(x=nFeature_RNA,y=percent.mt,colour=decontX_contamination)) + geom_point(size=0.6,shape=20) +
		theme(legend.position="none") + labs(x="nFeature_RNA",y="percent.mt") + 
  		scale_colour_gradient(low="gray", high="#F8766D") + theme_bw()

	    p2<-ggplot(summary_data,aes(x=nCount_RNA,y=percent.mt,colour=decontX_contamination)) + geom_point(size=0.6,shape=20) +
                theme(legend.position="none") + labs(x="nCount_RNA",y="percent.mt") +
                scale_colour_gradient(low="gray", high="#F8766D") + theme_bw()

	    p3<-ggplot(summary_data,aes(x=nCount_RNA,y=nFeature_RNA,colour=decontX_contamination)) + geom_point(size=0.6,shape=20) +
                theme(legend.position="none") + labs(x="nCount_RNA",y="nFeature_RNA") +
                scale_colour_gradient(low="gray", high="#F8766D") + theme_bw()

	} else {
	    p1<-ggplot(summary_data,aes(x=nFeature_RNA,y=percent.mt,colour="gray")) + geom_point(size=0.6,shape=20) +
                theme(legend.position="none") + labs(x="nFeature_RNA",y="percent.mt") +
		theme_bw()

	    p2<-ggplot(summary_data,aes(x=nCount_RNA,y=percent.mt,colour="gray")) + geom_point(size=0.6,shape=20) +
                theme(legend.position="none") + labs(x="nCount_RNA",y="percent.mt") +
                theme_bw()

	    p3<-ggplot(summary_data,aes(x=nCount_RNA,y=nFeature_RNA,colour="gray")) + geom_point(size=0.6,shape=20) +
                theme(legend.position="none") + labs(x="nCount_RNA",y="nFeature_RNA") +
                theme_bw()

	}
	print(p1)
	print(p2)
	print(p3)


    dev.off()

}



#' Flags the low quality cells using a set of user-defined cutoffs.
#'
#' Flags the low quality cells using a set of user-defined cutoffs for the metrics nFeature_RNA, nCount_RNA, percent.mt
#'   hbCout_RNA and decontX_contamination. To select the cutoffs the user need to run Seurat_QC() with cutoffs = NULL and 
#'   select appropriate values. This function is called by Seurat_QC() with cutoffs = <a list of cutoffs>.
#' @param obj object. A seurat object with the data to be filtered.
#' @param cutoffs list. A list of cutoffs. It contains 4 components named nFeature_RNA, nCount_RNA, percent.mt and percent.hb.
#'   Each component should contain a low value and a high value. The cells with values in-between the range are kept for further
#'   analysis.
#' @keywords applyCutoffs
#' @return A list consisting of an updated Seurat object with the flag information for each cell and each metric and the associated
#'   cutoffs.
#'
applyCutoffs<-function(obj,cutoffs){
    
    nn<-names(cutoffs)
    if(is.null(nn)){
        stop("Parameter cutoff should be an annotated list with components: nFeature_RNA, nCount_RNA, percent.mt, percent.hb, decontX_contamination")
    }


    cutlist<-c("nFeature_RNA","nCount_RNA","percent.mt","percent.hb","decontX_contamination")
    ww<-match(cutlist,nn,nomatch=0)
    plottingCuts<-plottingCols<-as.list(rep(0,length(cutlist)))

    for(i in 1:length(ww)){
        
	mm<-match(cutlist[i],colnames(obj@meta.data),nomatch=0)
	if(mm>0){
            rang<-range(obj@meta.data[,mm])
	} else {
	    rang<-c(-1,-1)
	}
        if(ww[i]==0 | max(rang)<0){
            print(paste("No filtering cutoff for ",cutlist[i]," was found.",sep=""))
            cutoffs<-c(cutoffs,list(rang))
            names(cutoffs)[length(cutoffs)]<-cutlist[i]
            ww[i]<-length(cutoffs)
        } else {
            if(unique(is.null(cutoffs[[ww[i]]]))){
                print(paste("No filtering cutoff for ",nn[[ww[i]]]," was found.",sep=""))
                cutoffs[[ww[i]]]<- rang
            }
            uu<-unique(is.na(cutoffs[[ww[i]]]))
            if(length(uu)>1){
                cutoffs[[ww[i]]]<-cutoffs[[ww[i]]][!is.na(cutoffs[[ww[i]]])]
            } else {
                if(length(uu)>0){
                    if(uu){
                        print(paste("No filtering cutoff for ",nn[[ww[i]]]," was found.",sep=""))
                        cutoffs[[ww[i]]]<- rang
                    }
                }
            }
        }
        if(!is.null(cutoffs[[ww[i]]]) & length(cutoffs[[ww[i]]])==1){
            cutoffs[[ww[i]]]<-c(0,cutoffs[[ww[i]]])
            print(paste("Auto-setting the lower bound of ",nn[[ww[i]]]," at 0.",sep=""))
        }
        plottingCuts[[ww[i]]]<-cutoffs[[ww[i]]][cutoffs[[ww[i]]]>0]
        plottingCols[[ww[i]]]<-c("#00B0F6","#F8766D")[cutoffs[[ww[i]]]>0]

    }
    
    for(i in 1:length(cutlist)){
        res<-rep("FAIL",nrow(obj@meta.data))
        m1<-match(cutlist[i],names(cutoffs))
        c1<-sort(cutoffs[[m1]])
	m2<-match(cutlist[i],colnames(obj@meta.data),nomatch=0)
	if(m2>0){
            d1<-obj@meta.data[,m2]
	
	# pass anything within the cutoffs
	    res[d1 >= c1[1] & d1 <= c1[2]]<-"PASS"	

	# keep anything with low counts / features that it is singlet
	#if(names(cutoffs)[i]=="nFeature_RNA" | names(cutoffs)[i]=="nCount_RNA"){
	#    if(match("hash.ID",colnames(obj@meta.data),nomatch=0)>0){
	#    	res[d1 < c1[1] & obj@meta.data$HTO_doublet=="singlet"]<-"PASS"
	#    } 
	#}

            cutoffs[[m1]]<-c1
            obj@meta.data<-cbind(obj@meta.data,res)
            colnames(obj@meta.data)[ncol(obj@meta.data)]<-paste(cutlist[i],"_filter",sep="")
	}
    }


    ff<-c("nFeature_RNA_filter","nCount_RNA_filter","percent.mt_filter","percent.hb_filter","decontX_contamination_filter")
    ff<-match(ff,colnames(obj@meta.data),nomatch=0)
    ff<-ff[ff>0]
    res<-apply(obj@meta.data[,ff],1,function(x) length(which(x=="FAIL")))
    res<-ifelse(res>0,"FAIL","PASS")
    obj@meta.data<-cbind(obj@meta.data,Consensus_filter=res)
    Misc(object =obj, slot = "Cutoffs") <- cutoffs

  return(list(obj,plottingCuts,plottingCols))
}



#' Generates interactive plotly violin plots with the specified QC cutoffs.
#'
#' Generates interactive plotly violin plots with the specified QC cutoffs. It considers the metrics nFeature_RNA,
#'   nCount_RNA, percent.mt and percent.hb. This is a helper function of the main SeuratQC_iVplots() that wraps up
#'   various function to meet this end.
#' @param obj object. An updated Seurat object with the flag information for each cell and each metric and the associated
#'   cutoffs. Typically the output of applyCutoffs() function.
#' @param name character. One of nFeature_RNA, nCount_RNA, percent.mt and percent.hb.
#' @param pcex numeric. A value defining the size of the plotted dots.
#' @param cutoffs list. A reformatted list of cutoffs used for plotting.
#' @param colors character. A color for the violin plot.
#' @keywords QCiViolin
#' @return An interactive violin plot.
#'
QCiViolin<-function(obj,name,pcex,cutoffs,color){

    a <- list(
              title = "",
              showticklabels = TRUE,
              tickmode= "array",
              ticktext = unique(obj@meta.data$orig.ident),
              tickvals = c(1:length(unique(obj@meta.data$orig.ident))))

    p<-plot_ly(data=obj@meta.data,
               x=rep(1,nrow(obj@meta.data)),
               y=as.formula(paste("~",name,sep="")),
               type="violin",
               spanmode="hard",
               text=paste("<b>nFeature_RNA: </b>",obj@meta.data$nFeature_RNA_filter,
                          "<br> <b>nCount_RNA: </b>",obj@meta.data$nCount_RNA_filter,
                          "<br> <b>percent.mt: </b>",obj@meta.data$percent.mt_filter,
                          "<br> <b>percent.hb: </b>",obj@meta.data$percent.hb_filter,
                          sep=""),
               box=list(visible=T),
               meanline=list(visible=T),
               points="all",
               marker=list(size=10*pcex),
               color=I(color),
               name=name) %>% layout(xaxis=a)

    ww<-which(names(cutoffs)==name)
    for(i in 1:length(cutoffs[[ww]])){
        p <- p %>% add_segments(x = 0.5,xend = 1.5, y = cutoffs[[ww]][i],
                                    yend = as.formula(paste("~",cutoffs[[ww]][i])),
                                    text=name,
                                    alpha = 0.1,
                                    line = list(dash = "dash",color="black",width=1),
                                    showlegend=FALSE)
    }

  return(p)
}




#' Generates interactive plotly violin plots with the specified QC cutoffs.
#'
#' Generates interactive plotly violin plots with the specified QC cutoffs. It considers the metrics nFeature_RNA,
#'   nCount_RNA, percent.mt and percent.hb.
#' @param obj object. An updated Seurat object with the flag information for each cell and each metric and the associated
#'   cutoffs. Typically the output of applyCutoffs() function.
#' @param sampleID character. A sample ID to be used in the plot filename.
#' @param pcex numeric. A value defining the size of the plotted dots.
#' @param cutoffs list. A reformatted list of cutoffs used for plotting.
#' @param plot.filename character. The filename (and the appropriate path) to store the plots.
#' @keywords SeuratQC_iVplots
#' @return An updated Seurat object and a set of noninteractive violin plots and two dotplots showing the association among
#'   the nFeature_RNA, the nCount_RNA and the percent.mt.
#'
SeuratQC_iVplots<-function(obj,sampleID,cutoffs,pcex,plot.filename){
    
    oo<-applyCutoffs(obj=obj,cutoffs=cutoffs)
    obj<-oo[[1]]
    plottingCuts<-oo[[2]]
    names(plottingCuts)<-names(cutoffs)
    plottingCols<-oo[[3]]
    
    p1a<-QCiViolin(obj=obj,name="nFeature_RNA",pcex=0.2,cutoffs=plottingCuts,color="#00B7C2")
    p1b<-QCiViolin(obj=obj,name="nCount_RNA",pcex=0.2,cutoffs=plottingCuts,color="#FF9C71")
    p1c<-QCiViolin(obj=obj,name="percent.mt",pcex=0.2,cutoffs=plottingCuts,color="#81b214")
    p1d<-QCiViolin(obj=obj,name="percent.hb",pcex=0.2,cutoffs=plottingCuts,color="#BBCFFF")
    
    cor1<-cor(obj[['nCount_RNA']],obj[['percent.mt']],method="spearman")
    cor2<-cor(obj[['nCount_RNA']],obj[['nFeature_RNA']],method="spearman")
    
    cc<-rep("#AAAAAA",nrow(obj@meta.data))
    cc[obj@meta.data$Consensus_filter=="FAIL"]<-"red"
    
    p2<-plot_ly(data=obj@meta.data,
                     x=~nCount_RNA,
                     y=~percent.mt,
                     type="scatter",
                     mode = "markers", marker = list(color = cc,size=4),
                     text=paste("<b>nFeature_RNA: </b>",obj@meta.data$nFeature_RNA_filter,
                                "<br> <b>nCount_RNA: </b>",obj@meta.data$nCount_RNA_filter,
                                "<br> <b>percent.mt: </b>",obj@meta.data$percent.mt_filter,
                                "<br> <b>percent.hb: </b>",obj@meta.data$percent.hb_filter,
                                sep=""),
                     name="nCount vs % mt",
                     showlegend=TRUE) %>%
                     layout(title = "") %>%
                     add_annotations(
                                    x=0.8*max(obj@meta.data$nCount_RNA),
                                    y=0.8*max(obj@meta.data$percent.mt),
                                    xref = "x",
                                    yref = "y",
                                    text = paste("Spearman rho = ",round(cor1,3),sep=""),
                                    xanchor = 'center',
                                    showarrow = F)

    p3<-plot_ly(data=obj@meta.data,
                      x=~nCount_RNA,
                      y=~nFeature_RNA,
                      type="scatter",
                      mode = "markers", marker = list(color = cc,size=4),
                      text=paste("<b>nFeature_RNA: </b>",obj@meta.data$nFeature_RNA_filter,
                                 "<br> <b>nCount_RNA: </b>",obj@meta.data$nCount_RNA_filter,
                                 "<br> <b>percent.mt: </b>",obj@meta.data$percent.mt_filter,
                                 "<br> <b>percent.hb: </b>",obj@meta.data$percent.hb_filter,
                                 sep=""),
                      name="nCount vs nFeature",
                      showlegend=TRUE) %>%
                      layout(title = "") %>%
                      add_annotations(
                                    x=0.8*max(obj@meta.data$nCount_RNA),
                                    y=0.2*max(obj@meta.data$nFeature_RNA),
                                    xref = "x",
                                    yref = "y",
                                    text = paste("Spearman rho = ",round(cor2,3),sep=""),
                                    xanchor = 'center',
                                    showarrow = F)

    p<-subplot(p1a,p1b,p2,p1c,p1d,p3,nrows=2)
    saveWidget(p,plot.filename,selfcontained = FALSE)

  return(obj)
}






#' Generates noninteractive ggplot2 violin plots with the specified QC cutoffs.
#'
#' Generates noninteractive ggplot2 violin plots with the specified QC cutoffs. It considers the metrics nFeature_RNA,
#'   nCount_RNA, percent.mt and percent.hb.
#' @param obj object. An updated Seurat object with the flag information for each cell and each metric and the associated
#'   cutoffs. Typically the output of applyCutoffs() function.
#' @param sampleID character. A sample ID to be used in the plot filename.
#' @param plot.filename character. The filename (and the appropriate path) to store the plots.
#' @param cutoffs list. A reformatted list of cutoffs used for plotting.
#' @param pcex numeric. A value defining the size of the plotted dots.
#' @keywords SeuratQC_Vplot
#' @return An updated Seurat object and a set of noninteractive violin plots and two dotplots showing the association among 
#'   the nFeature_RNA, the nCount_RNA and the percent.mt.
#'
SeuratQC_Vplot<-function(obj,sampleID,cutoffs,pcex,plot.filename){
    
    oo<-applyCutoffs(obj=obj,cutoffs=cutoffs)
    obj<-oo[[1]]
    plottingCuts<-oo[[2]]
    plottingCols<-oo[[3]]
    
    p1a<-VlnPlot(obj,features ="nFeature_RNA",ncol=1,pt.size=pcex) + geom_violin(fill="#00B7C2") +
         ggtitle(paste("Number of features for ",sampleID,sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
         geom_hline(yintercept=plottingCuts[[1]], linetype="dashed", color=plottingCols[[1]]) +
         scale_y_continuous(breaks = sort(c(seq(0, max(obj[["nFeature_RNA"]]), length.out=5), plottingCuts[[1]])))
    p1b<-VlnPlot(obj,features ="nCount_RNA",ncol=1,pt.size=pcex) + geom_violin(fill="#FF9C71") +
         ggtitle(paste("Library size for ",sampleID,sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
         geom_hline(yintercept=plottingCuts[[2]], linetype="dashed", color=plottingCols[[2]]) +
         scale_y_continuous(breaks = sort(c(seq(0, max(obj[["nCount_RNA"]]), length.out=5), plottingCuts[[2]])))
    p1c<-VlnPlot(obj,features ="percent.mt",ncol=1,pt.size=pcex) + geom_violin(fill="#81b214") +
         ggtitle(paste("% of MT rna reads for ",sampleID,sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
         geom_hline(yintercept=plottingCuts[[3]], linetype="dashed", color=plottingCols[[3]]) +
         scale_y_continuous(breaks = sort(c(seq(0, max(obj[["percent.mt"]]), length.out=5), plottingCuts[[3]])))
    p1d<-VlnPlot(obj,features ="percent.hb",ncol=1,pt.size=pcex) + geom_violin(fill="#BBCFFF") +
         ggtitle(paste("% of HB rna reads for ",sampleID,sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
         geom_hline(yintercept=plottingCuts[[4]], linetype="dashed", color=plottingCols[[4]]) +
         scale_y_continuous(breaks = sort(c(seq(0, max(obj[["percent.hb"]]), length.out=5), plottingCuts[[4]])))
    
    ww<-which(colnames(obj@meta.data)=="decontX_contamination")
    if(length(ww)>0){
    	p1e<-VlnPlot(obj,features ="decontX_contamination",ncol=1,pt.size=pcex) + geom_violin(fill="#BBCFFF") +
             ggtitle(paste("Contamination rate for ",sampleID,sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
             geom_hline(yintercept=plottingCuts[[5]], linetype="dashed", color=plottingCols[[5]]) +
             scale_y_continuous(breaks = sort(c(seq(0, max(obj[["decontX_contamination"]]), length.out=5), plottingCuts[[5]])))
    } else {
	p1e<-NULL
    }

    cor1<-cor(obj[['nCount_RNA']],obj[['percent.mt']],method="spearman")
    cor2<-cor(obj[['nCount_RNA']],obj[['nFeature_RNA']],method="spearman")
    p2<-ggplot(obj@meta.data,aes(x=nCount_RNA,y=percent.mt,color=Consensus_filter))+geom_point(size=0.7,shape=20)+
        labs(x="nCount",y="MT percent")+
        ggtitle(paste("nCount vs MT percent for ",sampleID," (Spearman rho = ",round(cor1,3),")",sep="")) +
        theme(plot.title = element_text(size = 11)) +
        scale_color_manual(values=c("red","#AAAAAA"))
    p3<-ggplot(obj@meta.data,aes(x=nCount_RNA,y=nFeature_RNA,color=Consensus_filter))+geom_point(size=0.7,shape=20)+
        labs(x="nCount",y="nFeature")+
        ggtitle(paste("nCount vs nFeature for ",sampleID," (Spearman rho = ",round(cor2,3),")",sep="")) +
        theme(plot.title = element_text(size = 11)) +
        scale_color_manual(values=c("red","#AAAAAA"))
    
    pdf(plot.filename)
         print(p1a)
         print(p1b)
         print(p1c)
         print(p1d)
	 print(p1e)
         print(p2)
         print(p3)
     dev.off()
         
  return(obj)
}






#' Runs Seurat's QC and estimates the parameters required for cell filtering.
#'
#' Runs Seurat's QC through a series of informative plots. It enables the user to specify
#'   meaningful cutoffs for cell filtering. Essentially, a first pass of the function is suggested
#'   with cutoffs = NULL and plot.cutoffs = TRUE. The generated plots will show a series of cutoffs
#'   that the user may choose. Next, the cutoffs vector need to be specified and the main QC analysis
#'   can be utilised by re-running the function with with plot.cutoffs = FALSE.
#' @param obj object. A Seurat object generated by the celda_decontamination() or the Seurat_demux() or simply 
#'   by the read10xRNAs() function.
#' @param sampleID character. A sample ID to be used in the plot filename.
#' @param outdir character. A folder to store the plots.
#' @param cutoffs list. A list with the cutoffs of the nFeature_RNA, nCount_RNA and percent.mt. The values 
#'   are provided by the user after inspection of the relevant plots. If NULL (default) a series of plots is 
#'   returned that enable the user to define the cutoffs.
#' @param inspect numeric. The percentage of extreme cells to inspect (up and down separately) for each metric
#'   in order to determine the cutoffs. These cells are plotted in separate plots. Default is 0.2 (20%).
#' @param pcex numeric. A value defining the size of the plotted dots. Default is 0.2.
#' @param min.cells numeric. The minimum number of cells that a gene should be expressed in order to be kept in the
#'   analysis. Default is 3.
#' @param min.features numeric. The minimu number of genes that a cell should be expressed in order to be kept in
#'   the analysis. Default is 200.
#' @param mt.pattern character. An identifier for the mitochondrial genes. Default is ':MT-" (rownames containing this
#'   character are associated to mitochondrial genes). 
#' @param hemo.pattern character. An identifier for the hemoglobin genes. 
#' @keywords Seurat_QC
#' @return An updated Seurat object list with the cutoffs and the QC filtering. The associated plots are automatically 
#'   stored in the defined outdir folder.
#'
Seurat_QC<-function(obj,sampleID,cutoffs,outdir,
		    min.cells=3,min.features=200,inspect=0.2,pcex=0.2,
		    mt.pattern=":MT-",hemo.pattern=c(":HBA",":HBB",":HBP",":HBD",":HBG",":HBE",":HBQ"),
		    type="Interactive"){
 
	if(names(obj)[1]=="mat" & names(obj)[2]=="feature.names" & names(obj)[3]=="barcode.names"){
	    umiobj<-CreateSeuratObject(counts = obj$mat,min.cells=min.cells,min.features=min.features)
	    if(!is.null(obj$design)){
		mm<-match(rownames(umiobj@meta.data),rownames(obj$design))
		obj$design<-obj$design[mm,]
	    	umiobj@meta.data<-cbind(umiobj@meta.data,obj$design)
	    }
	    obj<-umiobj
	    obj@meta.data$orig.ident<-sampleID
	}
	Idents(obj)<-obj@meta.data$orig.ident

        if(is.null(cutoffs)){
	    
            obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = mt.pattern,assay="RNA")
	    dd<-obj@assays$RNA@counts[grep(hemo.pattern[1],rownames(obj)),]
	    for(i in 2:length(hemo.pattern)){
		dd<-rbind(dd,obj@assays$RNA@counts[grep(hemo.pattern[i],rownames(obj)),])
	    }
	    dd<-100*apply(dd,2,sum)/apply(obj@assays$RNA@counts,2,sum)
	    obj[["percent.hb"]]<-data.frame(dd)
	    ww<-which(colnames(obj@meta.data)=="nCount_RNA" | colnames(obj@meta.data)=="nFeature_RNA" | 
		      colnames(obj@meta.data)=="percent.mt" | colnames(obj@meta.data)=="percent.hb" |
		      colnames(obj@meta.data)=="decontX_contamination")
            summary_data<-obj@meta.data[,ww]

        }
        
  
        if(is.null(cutoffs)){
	    if(type=="Interactive"){

	        plotnam<-paste(outdir,"SearchCutoffs_",sampleID,".html",sep="")
		p<-SeuratQC_idotplot(summary_data=summary_data,inspect=inspect,pcex=pcex,plot.filename=plotnam)
		
		#message
		print(paste("Download plot: ",outdir,"SearchCutoffs_",sampleID,"*",sep=""))
	
	    } else {

		plotnam<-paste(outdir,"SearchCutoffs_",sampleID,".pdf",sep="")
		p<-SeuratQC_dotplot(summary_data=summary_data,inspect=inspect,pcex=pcex,plot.filename=plotnam)

		#message
                print(paste("Download plot: ",outdir,"SearchCutoffs_",sampleID,".pdf",sep=""))

	    }

	} else {
	    if(type=="Interactive"){

		plotnam<-paste(outdir,"EstCutoffs_",sampleID,".html",sep="")
		obj<-SeuratQC_iVplots(obj=obj,sampleID=sampleID,cutoffs=cutoffs,pcex=pcex,plot.filename=plotnam)
   
		#message
                print(paste("Download plot: ",outdir,"EstCutoffs_",sampleID,"*",sep=""))

            } else {

                plotnam<-paste(outdir,"EstCutoffs_",sampleID,".pdf",sep="")
		obj<-SeuratQC_Vplot(obj=obj,sampleID=sampleID,cutoffs=cutoffs,pcex=pcex,plot.filename=plotnam)

		#message
                print(paste("Download plot: ",outdir,"EstCutoffs_",sampleID,".pdf",sep=""))

            }
	}
           
  return(obj)
}




#' Runs a preliminary UMAP and clustering on high-quality data of all singlets. To be used with HTO data only!
#'
#' Runs a preliminary UMAP and clustering on high-quality data of all singlets. The objective is to check 
#'   how the HTO Negatives are distrivuted in the clusters and decide if some of them should remain in the 
#'   analysis.
#' @param obj object. A Seurat object, typically generated from the Seurat_demux() function.
#' @param sampleID character. A sample ID to be used in the plot filename.
#' @param outdir.plot character. A folder to store the plots.
#' @param outdir.data character. A folder to store the data.
#' @param vars character. Variables of the meta.data slot to be plotted. 
#' @param cut.cells numeric. The minimum number of cells that a gene should be expressed in order to be kept in the
#'   analysis. Default is 3.
#' @param cut.counts numeric. The minimum number of counts (library size) that a cell should have in order to be kept 
#'   in the analysis. Default is 200.
#' @param cut.features numeric. The minimum number of genes that a cell should be expressed in order to be kept in
#'   the analysis. Default is 200.
#' @param cut.mt numeric. The maximum percentage of reads mapped to the MT genome acceptable for a cell to be kept in
#'   the analysis. Default is 10.
#' @param mt.pattern character. An identifier for the mitochondrial genes. Default is ':MT-" (rownames containing this
#'   character are associated to mitochondrial genes). 
#' @param hemo.pattern character. An identifier for the hemoglobin genes. 
#' @param dims numeric. The number of PCs used to generate the UMAP. Default is 50.
#' @param resolution numeric. The UMAP clustering resolution. Default is 0.8.
#' @keywords negativeCheck
#' @return An updated Seurat object with the necessary information.
#' 
negativeCheck<-function(obj,sampleID,outdir.plot,outdir.data,hto.number,vars,cut.cells=3,cut.counts=200,cut.features=200,cut.mt=10,
                        mt.pattern=":MT-",hemo.pattern=c(":HBA",":HBB",":HBP",":HBD",":HBG",":HBE",":HBQ"),
			dims=50,resolution=0.8){
    
    obj<-Seurat_QC(obj=obj,sampleID=sampleID,
                    cutoffs=NULL,outdir=outdir.plot,
                    inspect=0.25,pcex=0.2,min.cells=cut.cells,min.features=cut.features,
                    mt.pattern=mt.pattern,hemo.pattern=hemo.pattern,
                    type="Noninteractive")
    out<-which(obj@meta.data$hash.ID=="Doublet" |
                obj@meta.data$nCount_RNA<cut.counts |
                obj@meta.data$nFeature_RNA<cut.features |
                obj@meta.data$percent.mt>cut.mt)
    obj.negs<-obj[,-out]

    out<-which(obj@meta.data$hash.ID=="Doublet" |
		obj@meta.data$hash.ID=="Negative" |
                obj@meta.data$nCount_RNA<cut.counts |
                obj@meta.data$nFeature_RNA<cut.features |
                obj@meta.data$percent.mt>cut.mt)
    obj.nonegs<-obj[,-out]

    
    obj.negs <- SCTransform(obj.negs,vars.to.regress=NULL,method = "glmGamPoi")
    obj.nonegs <- SCTransform(obj.nonegs,vars.to.regress=NULL,method = "glmGamPoi")
    obj.negs <- RunPCA(obj.negs)
    obj.nonegs <- RunPCA(obj.nonegs)
    obj.negs <- FindNeighbors(obj.negs, dims = 1:dims)
    obj.nonegs <- FindNeighbors(obj.nonegs, dims = 1:dims)
    obj.negs <- FindClusters(obj.negs, resolution = resolution)
    obj.nonegs <- FindClusters(obj.nonegs, resolution = resolution)
    obj.negs <- RunUMAP(obj.negs, dims = 1:dims)
    obj.nonegs <- RunUMAP(obj.nonegs, dims = 1:dims)
	
    if(length(vars)==2){
	w1<-which(colnames(obj.negs@meta.data)==vars[1])
	w2<-which(colnames(obj.negs@meta.data)==vars[2])
	ss<-apply(cbind(obj.negs@meta.data[,w1],obj.negs@meta.data[,w2]),1,paste,collapse="_")	
	obj.negs@meta.data<-cbind(obj.negs@meta.data,TimeCondition=ss)
	
        w1<-which(colnames(obj.nonegs@meta.data)==vars[1])
        w2<-which(colnames(obj.nonegs@meta.data)==vars[2])
        ss<-apply(cbind(obj.nonegs@meta.data[,w1],obj.nonegs@meta.data[,w2]),1,paste,collapse="_")
        obj.nonegs@meta.data<-cbind(obj.nonegs@meta.data,TimeCondition=ss)
    }
    if(length(vars)==1){
	w1<-which(colnames(obj.negs@meta.data)==vars[1])
	obj.negs@meta.data<-cbind(obj.negs@meta.data,TimeCondition=obj.negs@meta.data[,w1])
	
	w1<-which(colnames(obj.nonegs@meta.data)==vars[1])
        obj.nonegs@meta.data<-cbind(obj.nonegs@meta.data,TimeCondition=obj.nonegs@meta.data[,w1])
    }
    if(is.null(vars) | length(vars)>2){
	stop("Variable vars should have length 1 or 2.")
    }

    tt.negs<-table(obj.negs@meta.data$seurat_clusters,obj.negs@meta.data$hash.ID)
    tt.negs<-tt.negs[,-1]
    tt.negs<-tt.negs[,match(c("Negative",paste("HHTO",1:hto.number,sep="")),colnames(tt.negs))]
    tt2.negs<-matrix(0,1,3)
    for(i in 1:nrow(tt.negs)){
        tt2.negs<-rbind(tt2.negs,cbind(rep(as.character(rownames(tt.negs)[i]),ncol(tt.negs)),
                             100*as.numeric(as.character(tt.negs[i,]))/apply(tt.negs,2,sum),
                             colnames(tt.negs)))
    }
    tt2.negs<-tt2.negs[-1,]
    tt2.negs<-data.frame(tt2.negs)
    colnames(tt2.negs)<-c("Cluster","pCells","hashID")
    tt2.negs$Cluster<-factor(tt2.negs$Cluster)
    tt2.negs$hashID<-factor(tt2.negs$hashID)
    tt2.negs$pCells<-as.numeric(as.character(tt2.negs$pCells))

    tt.nonegs<-table(obj.nonegs@meta.data$seurat_clusters,obj.nonegs@meta.data$hash.ID)
    tt.nonegs<-tt.nonegs[,-which(colnames(tt.nonegs)=="Doublet" | colnames(tt.nonegs)=="Negative")]
    tt.nonegs<-tt.nonegs[,match(c(paste("HHTO",1:hto.number,sep="")),colnames(tt.nonegs))]
    tt2.nonegs<-matrix(0,1,3)
    for(i in 1:nrow(tt.nonegs)){
        tt2.nonegs<-rbind(tt2.nonegs,cbind(rep(as.character(rownames(tt.nonegs)[i]),ncol(tt.nonegs)),
                             100*as.numeric(as.character(tt.nonegs[i,]))/apply(tt.nonegs,2,sum),
                             colnames(tt.nonegs)))
    }
    tt2.nonegs<-tt2.nonegs[-1,]
    tt2.nonegs<-data.frame(tt2.nonegs)
    colnames(tt2.nonegs)<-c("Cluster","pCells","hashID")
    tt2.nonegs$Cluster<-factor(tt2.nonegs$Cluster)
    tt2.nonegs$hashID<-factor(tt2.nonegs$hashID)
    tt2.nonegs$pCells<-as.numeric(as.character(tt2.nonegs$pCells))

    sums.negs<-apply(tt.negs,2,sum)
    sums.negs<-data.frame(hashID=names(sums.negs),nCells=sums.negs)
    sums.negs$hashID<-factor(sums.negs$hashID)
    sums.negs$nCells<-as.numeric(as.character(sums.negs$nCells))

    sums.nonegs<-apply(tt.nonegs,2,sum)
    sums.nonegs<-data.frame(hashID=names(sums.nonegs),nCells=sums.nonegs)
    sums.nonegs$hashID<-factor(sums.nonegs$hashID)
    sums.nonegs$nCells<-as.numeric(as.character(sums.nonegs$nCells))


    tc.negs<-table(obj.negs@meta.data$seurat_clusters,obj.negs@meta.data$TimeCondition)
    colnames(tc.negs)[1]<-"Negative"
    tc2.negs<-matrix(0,1,3)
    for(i in 1:nrow(tc.negs)){
        tc2.negs<-rbind(tc2.negs,cbind(rep(as.character(rownames(tc.negs)[i]),ncol(tc.negs)),
                             100*as.numeric(as.character(tc.negs[i,]))/apply(tc.negs,2,sum),
                             colnames(tc.negs)))
    }
    tc2.negs<-tc2.negs[-1,]
    tc2.negs<-data.frame(tc2.negs)
    colnames(tc2.negs)<-c("Cluster","pCells","TimeCondition")
    tc2.negs$Cluster<-factor(tc2.negs$Cluster)
    tc2.negs$TimeCondition<-factor(tc2.negs$TimeCondition)
    tc2.negs$pCells<-as.numeric(as.character(tc2.negs$pCells))

    tc.nonegs<-table(obj.nonegs@meta.data$seurat_clusters,obj.nonegs@meta.data$TimeCondition)
    tc2.nonegs<-matrix(0,1,3)
    for(i in 1:nrow(tc.nonegs)){
        tc2.nonegs<-rbind(tc2.nonegs,cbind(rep(as.character(rownames(tc.nonegs)[i]),ncol(tc.nonegs)),
                             100*as.numeric(as.character(tc.nonegs[i,]))/apply(tc.nonegs,2,sum),
                             colnames(tc.nonegs)))
    }
    tc2.nonegs<-tc2.nonegs[-1,]
    tc2.nonegs<-data.frame(tc2.nonegs)
    colnames(tc2.nonegs)<-c("Cluster","pCells","TimeCondition")
    tc2.nonegs$Cluster<-factor(tc2.nonegs$Cluster)
    tc2.nonegs$TimeCondition<-factor(tc2.nonegs$TimeCondition)
    tc2.nonegs$pCells<-as.numeric(as.character(tc2.nonegs$pCells))

    sumsc.negs<-apply(tc.negs,2,sum)
    sumsc.negs<-data.frame(TimeCondition=names(sumsc.negs),nCells=sumsc.negs)
    sumsc.negs$TimeCondition<-factor(sumsc.negs$TimeCondition)
    sumsc.negs$nCells<-as.numeric(as.character(sumsc.negs$nCells))

    sumsc.nonegs<-apply(tc.nonegs,2,sum)
    sumsc.nonegs<-data.frame(TimeCondition=names(sumsc.nonegs),nCells=sumsc.nonegs)
    sumsc.nonegs$TimeCondition<-factor(sumsc.nonegs$TimeCondition)
    sumsc.nonegs$nCells<-as.numeric(as.character(sumsc.nonegs$nCells))



    p0.negs<-DimPlot(obj.negs, reduction = "umap",label=TRUE) + ggtitle(paste("Clusters with Negatives for ",sampleID,sep=""))
    p0.nonegs<-DimPlot(obj.nonegs, reduction = "umap",label=TRUE) + ggtitle(paste("Clusters without Negatives for ",sampleID,sep=""))

    Idents(obj.negs)<-obj.negs@meta.data$hash.ID
    Idents(obj.nonegs)<-obj.nonegs@meta.data$hash.ID
    p1.negs<-DimPlot(obj.negs, reduction = "umap",label=FALSE) + ggtitle(paste("hash.IDs with Negatives for ",sampleID,sep=""))
    p1.nonegs<-DimPlot(obj.nonegs, reduction = "umap",label=FALSE) + ggtitle(paste("hash.IDs without Negatives for ",sampleID,sep=""))

    Idents(obj.negs)<-obj.negs@meta.data$TimeCondition
    p2.negs<-DimPlot(obj.negs, reduction = "umap",label=FALSE) + ggtitle(paste("Time and Condition with Negatives for ",sampleID,sep=""))

    Idents(obj.nonegs)<-obj.nonegs@meta.data$TimeCondition
    p2.nonegs<-DimPlot(obj.nonegs, reduction = "umap",label=FALSE) + ggtitle(paste("Time and Condition without Negatives for ",sampleID,sep=""))


    p21.negs<-FeaturePlot(obj.negs,feature="nFeature_RNA") + ggtitle(paste("Number of features with Negatives for ",sampleID,sep=""))
    p22.negs<-FeaturePlot(obj.negs,feature="nCount_RNA") + ggtitle(paste("Library size with Negatives for ",sampleID,sep=""))

    p3.negs<-ggplot(data=tt2.negs, aes(x=Cluster, y=pCells, fill=hashID)) + labs(x="Seurat clusters",y="% of Cells in cluster c") + 
		    geom_bar(stat="identity", position=position_dodge()) + ggtitle(paste("% of cells by cluster with Negatives for ",sampleID,sep=""))
    p3.nonegs<-ggplot(data=tt2.nonegs, aes(x=Cluster, y=pCells, fill=hashID)) + labs(x="Seurat clusters",y="% of Cells in cluster c") + 
		    geom_bar(stat="identity", position=position_dodge()) + ggtitle(paste("% of cells by cluster without Negatives for ",sampleID,sep=""))

    p4.negs<-ggplot(data=sums.negs, aes(x=hashID, y=nCells)) + labs(x="Hash ID",y="# of Cells") + geom_bar(stat="identity") + ggtitle(paste("# of cells by hashID with Negatives for ",sampleID,sep=""))
    p4.nonegs<-ggplot(data=sums.nonegs, aes(x=hashID, y=nCells)) + labs(x="Hash ID",y="# of Cells") + geom_bar(stat="identity") + ggtitle(paste("# of cells by hashID without Negatives for ",sampleID,sep=""))

    p5.negs<-ggplot(data=tc2.negs, aes(x=Cluster, y=pCells, fill=TimeCondition)) + labs(x="Seurat clusters",y="% of Cells in cluster c") +
                    geom_bar(stat="identity", position=position_dodge()) + ggtitle(paste("% of cells by cluster with Negatives for ",sampleID,sep=""))
    p5.nonegs<-ggplot(data=tc2.nonegs, aes(x=Cluster, y=pCells, fill=TimeCondition)) + labs(x="Seurat clusters",y="% of Cells in cluster c") +
                    geom_bar(stat="identity", position=position_dodge()) + ggtitle(paste("% of cells by cluster without Negatives for ",sampleID,sep=""))

    p6.negs<-ggplot(data=sumsc.negs, aes(x=TimeCondition, y=nCells)) + labs(x="Time and Condition",y="# of Cells") + geom_bar(stat="identity") + 
			ggtitle(paste("# of cells by TimeCondition with Negatives for ",sampleID,sep=""))
    p6.nonegs<-ggplot(data=sumsc.nonegs, aes(x=TimeCondition, y=nCells)) + labs(x="Time and Condition",y="# of Cells") + geom_bar(stat="identity") + 
			ggtitle(paste("# of cells by TimeCondition without Negatives for ",sampleID,sep=""))

   
    tab.negs<-cbind(Cluster=rownames(tt.negs),tt.negs)
    write.table(tab.negs,paste(outdir.data,"ProcessedData/hashID_check_Negatives_",sampleID,".txt",sep=""),sep="\t",row.names=F,quote=F)
    tab.nonegs<-cbind(Cluster=rownames(tt.nonegs),tt.nonegs)
    write.table(tab.nonegs,paste(outdir.data,"ProcessedData/hashID_check_noNegatives_",sampleID,".txt",sep=""),sep="\t",row.names=F,quote=F)

    # message
    print(paste("Download data: ",outdir.data,"hashID_check_Negatives_",sampleID,".txt",sep=""))
    print(paste("Download data: ",outdir.data,"hashID_check_noNegatives_",sampleID,".txt",sep=""))
	

    oo<-obj.negs@meta.data
    ee<-obj.negs@assays$RNA@counts
    ee1<-ee[,oo$hash.ID=="Negative"]
    ee2<-ee[,oo$hash.ID!="Negative"]
    det1<-log(apply(ee1,2,function(x) length(which(x>0))))
    det2<-log(apply(ee2,2,function(x) length(which(x>0))))
    lib1<-log(apply(ee1,2,sum))
    lib2<-log(apply(ee2,2,sum))
    df<-data.frame(rbind(cbind(det1,lib1,rep("Negative",length(det1))),
			 cbind(det2,lib2,rep("Singlet",length(det2)))))
    colnames(df)<-c("Detected_Genes","Library_Size","Type")
    df$Detected_Genes<-as.numeric(as.character(df$Detected_Genes))
    df$Library_Size<-as.numeric(as.character(df$Library_Size))
    p7<-ggplot(df, aes(x=Detected_Genes, fill=Type)) + geom_density(alpha=0.4)
    p8<-ggplot(df, aes(x=Library_Size, fill=Type)) + geom_density(alpha=0.4)


    pdf(paste(outdir.plot,"hashID_check_",sampleID,".pdf",sep=""))
        print(p0.negs)
        print(p0.nonegs)
        print(p1.negs)
        print(p1.nonegs)
        print(p2.negs)
        print(p2.nonegs)
	print(p21.negs)
	print(p22.negs)
        print(p3.negs)
        print(p3.nonegs)
        print(p4.negs)
        print(p4.nonegs)
        print(p5.negs)
        print(p5.nonegs)
        print(p6.negs)
        print(p6.nonegs)
	print(p7)
	print(p8)
    dev.off()

    # message
    print(paste("Download plot: ",outdir.plot,"hashID_check_",sampleID,".pdf",sep=""))


  return(list(Obj_with_negatives=obj.negs,Obj_without_negatives=obj.nonegs))
}


#' Matches the columns of the @meta.data slot of a Seurat object to those of a template Seurat object and, if required,
#'   splits the original object into sub-objects.
#'
#' Matches the columns of the @meta.data slot of a Seurat object to those of a template Seurat object and, if required,
#'   splits the original object into sub-objects. The split variable must be a column of the @meta.data slot.
#' @param obj object. A Seurat object to be matched to a template and if required, split into sub-objects.
#' @param templ object.  A Seurat object to act as th template for matching.
#' @param split.by character. A column of the @meta.data slot of the obj object. If NULL (default) the object is not split.
#' @param index character. Part of the modified name of the split object.
#' @keywords adjust.meta
#' @return A Seurat (split) object with adjusted @meta.data.
#'
adjust.meta<-function(obj,templ,split.by=NULL,index="_I"){
    
    for(i in 1:length(obj)){
        mm<-match(colnames(templ@meta.data),colnames(obj[[i]]@meta.data),nomatch=0)
        obj[[i]]@meta.data<-obj[[i]]@meta.data[,mm]
        if(!is.null(split.by)){
            ww<-which(colnames(obj[[i]]@meta.data)==split.by)
            if(length(ww)==0){
                stop("Column by does not exist in the @meta.data slot.")
            }
            ff<-unique(obj[[i]]@meta.data[,ww])
            oo<-as.list(rep(0,length(ff)))
            names(oo)<-paste(names(obj)[i],index,as.character(ff),sep="")
            for(j in 1:length(oo)){
                oo[[j]]<-obj[[i]][,which(obj[[i]]@meta.data[,ww]==ff[j])]
            }
        } else {
            oo<-obj[[i]]
        }
    }
    
  return(oo)
}



#' Runs a UMAP / clustering analysis for each sample using all cells of the cellranger pipeline.
#'
#' Runs a UMAP / clustering analysis for each sample using all cells of the cellranger pipeline in order to determine
#'   potential clusters of low quality cells (associated to the low-quality cells that have been derived by the Seurat_QC()
#'   function). The counts are normalised with the SCTransform method.
#' @param obj list. A list with components being the output of Seurat_QC with specified cutoffs.
#' @param outdir character. A folder to store the plots.
#' @param regress.out character. One or more variables of the meta.data slot to regress in the SCTransform. Default is NULL.
#' @param other.vars character. By default the function plot the resuts of nFeature_RNA, nCount_RNA, percent.mt and percent.hb.
#'   Here the user can select additional variables for plotting. Default is NULL.
#' @param genes2show character. A vector of gehes whose expression is to be plotted in the UMAP. Default is NULL.
#' @param log.it logical. If TRUE (default), the nFeature_RNA and nCount_RNA metrics to be plotted are log-transformed.
#' @param pcex numeric. A value defining the size of the plotted dots. Default is 0.2. 
#' @param dims numeric. The number of principal components for dimensinality reduction. Default is 50.
#' @param resolution numeric. Value of the resolution parameter, use a value above (below) 1.0 if you want to obtain a larger 
#'   (smaller) number of communities. Default is 0.8.
#' @keywords Seurat_preliminaryClustering
#' @return A list with components being the updated Seurat_QC objects with highlighted low- and high- quality cells.
#' 
Seurat_preliminaryClustering<-function(obj,outdir,regress.out=NULL,other.vars=NULL,genes2show=NULL,log.it=TRUE,pcex=0.2,dims=50,resolution=0.8){
    
    if(is.null(names(obj))){
        stop("Add names to the obj list components that will serve as sample IDs.")
    }
    
    pdf(paste(outdir,"Seurat_preliminaryQC_",names(obj),".pdf",sep=""))
        for(i in 1:length(obj)){
            obj[[i]] <- SCTransform(obj[[i]],vars.to.regress=regress.out,method = "glmGamPoi")
            obj[[i]] <- RunPCA(obj[[i]])
            obj[[i]] <- FindNeighbors(obj[[i]], dims = 1:dims)
            obj[[i]] <- FindClusters(obj[[i]], resolution = resolution)
            obj[[i]] <- RunUMAP(obj[[i]], dims = 1:dims)

	    # the basic plot            
            p1<-DimPlot(obj[[i]], reduction = "umap",label=TRUE) + ggtitle(paste(names(obj)[i]," QC clusters",sep=""))
            print(p1)

	    if(log.it){
		newobj<-obj[[i]]
		newobj$nFeature_RNA<-log(newobj$nFeature_RNA,10)
		newobj$nCount_RNA<-log(newobj$nCount_RNA,10)
	    } else {
		newobj<-obj[[i]]
	    }
	    # the standard QCs
            p2a<-FeaturePlot(object = newobj, features = "percent.mt",label = TRUE) + ggtitle(paste(names(obj)[i]," percent.mt",sep=""))
            print(p2a)
            p2b<-FeaturePlot(object = newobj, features = "nFeature_RNA",label = TRUE) + ggtitle(paste(names(obj)[i]," nFeature_RNA",sep=""))
            print(p2b)
            p2c<-FeaturePlot(object = newobj, features = "nCount_RNA",label = TRUE) + ggtitle(paste(names(obj)[i]," nCount_RNA",sep=""))
            print(p2c)
            p2d<-FeaturePlot(object = newobj, features = "percent.hb",label = TRUE) + ggtitle(paste(names(obj)[i]," percent.hb",sep=""))
            print(p2d)

	    # the standard QC cutoffs
            p3a<-DimPlot(object = newobj, group.by = "percent.mt_filter") + ggtitle(paste(names(obj)[i]," percent.mt (cutoffs)",sep=""))
            print(p3a)
            p3b<-DimPlot(object = newobj, group.by = "nFeature_RNA_filter") + ggtitle(paste(names(obj)[i]," nFeature_RNA (cutoffs)",sep=""))
            print(p3b)
            p3c<-DimPlot(object = newobj, group.by = "nCount_RNA_filter") + ggtitle(paste(names(obj)[i]," nCount_RNA (cutoffs)",sep=""))
            print(p3c)
	    p3d<-DimPlot(object = newobj, group.by = "percent.hb_filter") + ggtitle(paste(names(obj)[i]," percent.hb (cutoffs)",sep=""))
            print(p3d)

	    # the extra plots
	    if(!is.null(other.vars)){
                for(j in 1:length(other.vars)){
                    ww<-which(colnames(obj[[i]]@meta.data)==other.vars[j])
                    if(length(ww)==0){
                        print(paste(other.vars[j]," does not exist in the dataset and it will not be included in this analysis.",sep=""))
                    } else {
                        v<-obj[[i]]@meta.data[,ww]
                        if(length(unique(v))>20){
                            extra<-FeaturePlot(object = obj[[i]], features = other.vars[j]) + ggtitle(paste(names(obj)[i]," ",other.vars[j],sep=""))
                            print(extra)
                        } else {
                            extra<-DimPlot(object = obj[[i]], group.by = other.vars[j]) + ggtitle(paste(names(obj)[i]," ",other.vars[j],sep=""))
                            print(extra)
                        }
                    }
                }
            }

	    if(!is.null(genes2show)){
        	mm<-match(genes2show,rownames(obj[[i]]@assays$SCT@data),nomatch=0)
        	if(length(mm[mm>0])==0){
            	    stop("None of the genes2show is found in the data")
        	} else {
		    if(length(mm[mm>0])==1){
			a<-obj[[i]]@assays$SCT@data[mm,]
		    } else {
    		        a<-t(obj[[i]]@assays$SCT@data[mm,])
		    }
		    colnames(a)<-GeneNames(colnames(a))
            	    obj[[i]]@meta.data<-cbind(obj[[i]]@meta.data,a)
            	    extra<-FeaturePlot(object = obj[[i]], features = GeneNames(genes2show),combine=FALSE,label=TRUE)
                    print(extra)
                }
    	    }
		
	
	    # the violins by standard grouping
	    plottingCuts<-obj[[i]]@misc$Cutoffs
	    if(log.it){
		for(k in 1:length(plottingCuts)){
		    for(kk in 1:length(plottingCuts[[k]])){
			if(!is.null(plottingCuts[[k]])){
			    if(plottingCuts[[k]][kk]>1 & names(plottingCuts)[k]!="percent.mt" & names(plottingCuts)[k]!="percent.hb" & names(plottingCuts)[k]!="decontX_contamination"){
			    	plottingCuts[[k]][kk]<-log(plottingCuts[[k]][kk],10)
			    }
			}
		    }
		}
	    }
	    p4a<-VlnPlot(newobj,features ="nFeature_RNA",ncol=1,pt.size=pcex,group.by="seurat_clusters") +
         	 ggtitle(paste("Number of features for ",names(obj)[i]," per cluster",sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
         	 geom_hline(yintercept=plottingCuts[[1]], linetype="dashed", color="black") +
         	 scale_y_continuous(breaks = sort(c(seq(0, max(newobj[["nFeature_RNA"]]), length.out=5), plottingCuts[[1]])))
		 print(p4a)

	    p4b<-VlnPlot(newobj,features ="nCount_RNA",ncol=1,pt.size=pcex,group.by="seurat_clusters") +
                 ggtitle(paste("Number of counts for ",names(obj)[i]," per cluster",sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
                 geom_hline(yintercept=plottingCuts[[2]], linetype="dashed", color="black") +
                 scale_y_continuous(breaks = sort(c(seq(0, max(newobj[["nCount_RNA"]]), length.out=5), plottingCuts[[2]])))
		 print(p4b)

            p4c<-VlnPlot(obj[[i]],features ="percent.mt",ncol=1,pt.size=pcex,group.by="seurat_clusters") +
                 ggtitle(paste("% of MT reads for ",names(obj)[i]," per cluster",sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
                 geom_hline(yintercept=plottingCuts[[3]], linetype="dashed", color="black") +
                 scale_y_continuous(breaks = sort(c(seq(0, max(obj[[i]][["percent.mt"]]), length.out=5), plottingCuts[[3]])))
                 print(p4c)

            p4d<-VlnPlot(obj[[i]],features ="percent.hb",ncol=1,pt.size=pcex,group.by="seurat_clusters") +
                 ggtitle(paste("% of HB reads for ",names(obj)[i]," per cluster",sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
                 geom_hline(yintercept=plottingCuts[[4]], linetype="dashed", color="black") +
                 scale_y_continuous(breaks = sort(c(seq(0, max(obj[[i]][["percent.hb"]]), length.out=5), plottingCuts[[4]])))
                 print(p4d)


	    # the violins by extra grouping
	    if(!is.null(other.vars)){
                for(j in 1:length(other.vars)){
                    ww<-which(colnames(obj[[i]]@meta.data)==other.vars[j])
                    if(length(ww)>0){
			v<-obj[[i]]@meta.data[,ww]
                        if(length(unique(v))>20){
                            extra1<-VlnPlot(obj[[i]],features =other.vars[j],ncol=1,pt.size=pcex,group.by="seurat_clusters") +
                 		   ggtitle(paste(other.vars[j]," for ",names(obj)[i]," per cluster",sep="")) + theme(plot.title = element_text(size = 12),legend.position="none")
                            print(extra1)
                        } else {
                 	    extra1<-VlnPlot(obj[[i]],features ="nFeature_RNA",ncol=1,pt.size=pcex,group.by=other.vars[j]) +
                 		   ggtitle(paste("Number of features for ",names(obj)[i]," per ",other.vars[j]," levels",sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
                 		   geom_hline(yintercept=plottingCuts[[1]], linetype="dashed", color="black") +
                 		   scale_y_continuous(breaks = sort(c(seq(0, max(obj[[i]][["nFeature_RNA"]]), length.out=5), plottingCuts[[1]])))           
                            print(extra1)

			    extra2<-VlnPlot(obj[[i]],features ="nCount_RNA",ncol=1,pt.size=pcex,group.by=other.vars[j]) +
                                   ggtitle(paste("Number of counts for ",names(obj)[i]," per ",other.vars[j]," levels",sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
                                   geom_hline(yintercept=plottingCuts[[2]], linetype="dashed", color="black") +
                                   scale_y_continuous(breaks = sort(c(seq(0, max(obj[[i]][["nCount_RNA"]]), length.out=5), plottingCuts[[2]])))
                            print(extra2)

                            extra3<-VlnPlot(obj[[i]],features ="percent.mt",ncol=1,pt.size=pcex,group.by=other.vars[j]) +
                                   ggtitle(paste("% of MT reads for ",names(obj)[i]," per ",other.vars[j]," levels",sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
                                   geom_hline(yintercept=plottingCuts[[3]], linetype="dashed", color="black") +
                                   scale_y_continuous(breaks = sort(c(seq(0, max(obj[[i]][["percent.mt"]]), length.out=5), plottingCuts[[3]])))
                            print(extra3)

                            extra4<-VlnPlot(obj[[i]],features ="percent.hb",ncol=1,pt.size=pcex,group.by=other.vars[j]) +
                                   ggtitle(paste("% of HB reads for ",names(obj)[i]," per ",other.vars[j]," levels",sep="")) + theme(plot.title = element_text(size = 12),legend.position="none") +
                                   geom_hline(yintercept=plottingCuts[[4]], linetype="dashed", color="black") +
                                   scale_y_continuous(breaks = sort(c(seq(0, max(obj[[i]][["percent.hb"]]), length.out=5), plottingCuts[[4]])))
                            print(extra4)
                        }
                    }
		}
	    }
 
       }
    dev.off()
 
    # message   
    print(paste("Download plot: ",outdir,"Seurat_preliminaryQC_",names(obj),".pdf",sep=""))

  return(obj)
}




#' Performs the Seurat QC and a preliminary clustering to remove the low-quality cells.
#'
#' Performs the Seurat QC and a preliminary clustering to remove the low-quality cells. Essentially
#'   it is a wrapper of the Seurat_QC() and Seurat_preliminaryClustering() functions. The user may
#'   follow this strategy: run the analysis for a series of cutoffs, inspect the first-step SeuratQC()
#'   plot (SearchCutoffs*) to assign a maximum cutoff and the Seurat_preliminaryClustering() to assign
#'   a minimum cutoff and finally rerun this function with the final cutoffs.
#' @param obj object. A Seurat object.
#' @param sampleID character. A sample ID to be used in the plot filename.
#' @param outdir character. A folder to store the plots.
#' @param cutoffs list. A list with the cutoffs of the nFeature_RNA, nCount_RNA and percent.mt. The values
#'   are provided by the user after inspection of the relevant plots. If NULL (default) a series of plots is
#'   returned that enable the user to define the cutoffs.
#' @param inspect numeric. The percentage of extreme cells to inspect (up and down separately) for each metric
#'   in order to determine the cutoffs. These cells are plotted in separate plots. Default is 0.2 (20%).
#' @param pcex numeric. A value defining the size of the plotted dots. Default is 0.2.
#' @param min.cells numeric. The minimum number of cells that a gene should be expressed in order to be kept in the
#'   analysis. Default is 3.
#' @param min.features numeric. The minimum number of genes that a cell should be expressed in order to be kept in
#'   the analysis. It is used only in the first SeuratQC() step. Default is 200.
#' @param mt.pattern character. An identifier for the mitochondrial genes. Default is ':MT-" (rownames containing this
#'   character are associated to mitochondrial genes).
#' @param hemo.pattern character. An identifier for the hemoglobin genes.
#' @param type character. Only Noninteractive (default) is currently supported.
#' @param feature.cut numeric. A vector of min.features to be examined in order to identify the optimal cutoff. To be
#'   used in Seurat_preliminaryClustering().
#' @param count.cut numeric. A vector of count cutoffs to be examined in order to identify the optimal cutoff. To be
#'   used in the Seurat_preliminaryClustering().
#' @param mt.cut numeric. The percent.mt cutoff after inspecting the SeuratQC()'s plot (SearchCutoffs*).
#' @param hb.cut numeric. The percent.hb cutoff after inspecting the SeuratQC()'s plot (SearchCutoffs*).
#' @param seqcond.qc logical. Whether to rerun the QC pipeline after additionl data manipulation. If needed, it can be used 
#'   after the celda_decontamination() function. Default is FALSE.
#' @param log.it logical. If TRUE (default), the nFeature_RNA and nCount_RNA metrics to be plotted are log-transformed.
#' @param regress.out character. One or more variables of the meta.data slot to regress in the SCTransform. Default is NULL.
#' @param other.vars character. By default the function plot the resuts of nFeature_RNA, nCount_RNA, percent.mt and percent.hb.
#'   Here the user can select additional variables for plotting. Default is NULL.
#' @param genes2show character. A vector of gehes whose expression is to be plotted in the UMAP. Default is NULL.
#' @param dims numeric. The number of principal components for dimensinality reduction. Default is 50.
#' @param resolution numeric. Value of the resolution parameter, use a value above (below) 1.0 if you want to obtain a larger
#'   (smaller) number of communities. Default is 0.8.
#' @keywords Seurat_preliminaryQC
#' @return A Seurat object with the cutoffs and a vector separating the low and high quality cells.
#'
Seurat_preliminaryQC<-function(obj,sampleID,outdir,feature.cut,count.cut,mt.cut,hb.cut,
                                cutoffs=NULL,inspect=0.2,pcex=0.2,min.cells=3,min.features=200,
                                mt.pattern=":MT-",second.qc=FALSE,
                                hemo.pattern=c(":HBA",":HBB",":HBP",":HBD",":HBG",":HBE",":HBQ"),
                                type="Noninteractive",
                                log.it=TRUE,regress.out="percent.mt",other.vars=NULL,genes2show=NULL,
                                dims=50,resolution=0.8){
    
    templ<-obj
    if(second.qc){
	meta<-obj@meta.data
	obj <-CreateSeuratObject(counts = obj@assays$RNA@counts,min.cells=min.cells,min.features=min.features)
	if(!is.null(other.vars)){
	   mm<-match(other.vars,colnames(meta),nomatch=0)
	   oo<-other.vars[mm>0]
	   mm<-mm[mm>0]
	   if(length(mm)>0){
 	   	obj@meta.data<-cbind(obj@meta.data,meta[,mm])
		colnames(obj@meta.data)[ncol(obj@meta.data):(ncol(obj@meta.data)-length(mm)+1)]<-oo
		obj$orig.ident<-meta$orig.ident
	   }
	}
    }

    cutoffs<-Seurat_QC(obj=obj,sampleID=sampleID,
            cutoffs=NULL,outdir=outdir,
            inspect=inspect,pcex=pcex,min.cells=min.cells,min.features=min.features,
            mt.pattern=mt.pattern,hemo.pattern=hemo.pattern,
            type=type)

    cc<-list(nFeature_RNA=feature.cut,
                nCount_RNA=count.cut,
                percent.mt=mt.cut,
                percent.hb=hb.cut,
                decontX_contamination=NULL)

    obj<-Seurat_QC(obj=cutoffs,sampleID=sampleID,
                cutoffs=cc,outdir=outdir,
                inspect=inspect,pcex=pcex,min.cells=min.cells,min.features=min(feature.cut),
                mt.pattern=mt.pattern,hemo.pattern=hemo.pattern,
                type=type)
        
    oo<-list(obj)
    names(oo)<-sampleID
    obj<-Seurat_preliminaryClustering(obj=oo,pcex=pcex,log.it=log.it,regress.out=regress.out,
                other.vars=other.vars,genes2show=genes2show,outdir=outdir,dims=dims,resolution=resolution)

    if(second.qc){
	dd<-setdiff(colnames(meta),colnames(obj[[1]]@meta.data))
	ii<-intersect(rownames(obj[[1]]@meta.data),rownames(meta))
	meta2<-meta[match(ii,rownames(meta)),]
	meta2<-meta2[,match(dd,colnames(meta),nomatch=0)]
	obj[[1]]@meta.data<-cbind(obj[[1]]@meta.data,meta2)
	obj[[1]]@meta.data<-obj[[1]]@meta.data[,match(colnames(templ@meta.data),colnames(obj[[1]]@meta.data))]
    }

    if(length(feature.cut)>2 | length(count.cut)>2 | length(mt.cut)>1 | length(hb.cut)>1){
	print(paste("*** Seurat_preliminaryQC() was run in a trial cutoff mode. The object has not been updated. Please check the plots to determine the cutoffs of sample ",sampleID," and rerun the function. ***",sep=""))	
	obj<-list(templ,Seu=obj)
	names(obj)<-sampleID
    }

 return(obj)
}
    


#' Prepares the input data for scrublet.
#'
#' Prepares the input data for scrublet and DoubletFinder. Currently, the .mtx data are copied to a local folder for the python
#'   scrublet software to work.
#' @param obj list. A list with a Seurat object for each sample. Typically the output of Seurat_QC() function. It contains all
#'   data to be stored in the @assays$RNA@counts slot.
#' @param filter numeric. The barcodes to remove from the analysis.
#' @param outdir character. A folder to store the filtered data.
#' @keywords filteredData_prep
#' @return A message the the data have been stored in the appropriate folder.
#' 
filteredData_prep<-function(obj,filter,outdir){
    
    if(is.null(names(filter))){
	stop("The filter must be a list whose names match the obj names.")
    }
    ide<-identical(sort(names(obj)),sort(names(filter)))
    if(!ide){
	stop("The names of filter and obj must be the same.")
    }
    sl<-sort.list(names(obj))
    obj<-obj[sl]
    sl<-sort.list(names(filter))
    filter<-filter[sl]

    for(i in 1:length(obj)){
        
	#sctmat<-obj[[i]]@assays$SCT@counts
	mat<-obj[[i]]@assays$RNA@counts
	#mat<-mat[match(as.character(rownames(sctmat)),as.character(rownames(mat)),nomatch=0),-filter[[i]]]
	mat<-mat[,-filter[[i]]]
        write10xCounts(paste(outdir,"ProcessedData/filteredData_prep_",names(obj)[i],"/",sep=""),mat,version="2")
     
	paste("Filtered data stored at ",outdir,"ProcessedData/filteredData_prep_",names(obj)[i],sep="")   
    }
    
  return(paste("Filtered data stored at ",outdir,"ProcessedData/filteredData_prep_",names(obj)[i],sep=""))
}



#' Extracts the information from the scrublet doublet_repred_* results of each sample.
#'
#' Extracts the information from the scrublet doublet_repred_* results of each sample. Specifically, it summarises into
#'   a list of data frames (one component per sample) the barcode IDs and the doublet identification. Note that ONLY
#'   THE SAMPLES THAT PASSED THE QC FILTERING HAVE BEEN PROCESSED!
#' @param input_folder character. A vector with the named folders where the doublet_repred_* is located. Names serve as the
#'   sample ID.
#' @param obj list. A list with a Seurat object for each sample. Typically the output of Seurat_QC() function.
#' @param filter list. The barcodes that have passed filtering. The same filter that was used in filteredData_prep().
#' @keywords scrublet_stats
#' @return An updated Seurat object with the information of the scrublet output for each sample.
#'  
scrublet_stats<-function(input_folder,obj,filter){

    if(is.null(names(input_folder))){
        stop("Parameter input_folder should be a named vector. The names are to be used as sampleIDs!")
    }
    
    ide<-identical(sort(names(obj)),sort(names(input_folder)))
    if(!ide){
         stop("The obj names do not match the names of the input folder.")
    }
    sl<-sort.list(names(obj))
    obj<-obj[sl]
    sl<-sort.list(names(input_folder))
    input_folder<-input_folder[sl]
    
    for(i in 1:length(obj)){
        
	keep<-colnames(obj[[i]])[-filter[[i]]]
        ff1<-list.files(input_folder[i],pattern="doublet_repred",full.names=T)
	if(length(ff1)==0){
	    ff1<-list.files(input_folder[i],pattern="doublet_pred",full.names=T)
	}
        ff1<-ifelse(scan(ff1)==0,"singlet","doublet")
	colu1<-rep("unassigned",nrow(obj[[i]]@meta.data))
	colu1[match(keep,rownames(obj[[i]]@meta.data))]<-ff1
	ff2<-list.files(input_folder[i],pattern="doublet_scores",full.names=T)
	ff2<-scan(ff2)
	colu2<-rep(-999,nrow(obj[[i]]@meta.data))
        colu2[match(keep,rownames(obj[[i]]@meta.data))]<-ff2
        scr<-data.frame(cbind(Ind=colu1,Ind2=colu2))
	colnames(scr)<-c("Scrublet_doublet","Scrublet_scores")
	obj[[i]]@meta.data<-cbind(obj[[i]]@meta.data,scr)

    }

 return(obj)
}




#' Prepares the input data for DoubletFinder.
#'
#' Prepares the input data for DoubletFinder. It depends on the output of scrublet_prep() function because it uses the
#'   QC-passed samples and the constructed matrix.mtx, genes.tsv and barcodes.tsv.
#' @param input_folder character. A vector with the named folders where scrublet's input files are located. Names serve as the
#'   sample ID.
#' @param min.cells numeric. The minimum number of cells that a gene should be expressed in order to be kept in the
#'   analysis. Default is 3.
#' @param min.features numeric. The minimu number of genes that a cell should be expressed in order to be kept in
#'   the analysis. Default is 200.
#' @param dims numeric. The number of principal components for dimensinality reduction. Default is 50.
#' @param resolution numeric. Value of the resolution parameter, use a value above (below) 1.0 if you want to obtain a larger 
#'   (smaller) number of communities. Default is 0.8.
#' @param doublet_rate list. A list of expected doublet rates for each sample. The values can be based on estimation from another algorithm
#'   such as Souporcell or Scrublet. Their effect on the final doublet estimation is not strong.
#' @param individuals list. A list with the predicted individuals from Souporcell or other method. In each component, the first column is the
#'   barcodes and the second the individual ID. For simplification, unassigned barcodes (to individuals) are converted into -1. The effect 
#'   will be removed from the data in the normalisation step. It is NULL if it does not exist.
#' @param mt.symbol character. A symbol for the identification of mitochondrial genes. The percentage of MT reads is a confounding factor
#'   whose effect is removed from the data in the normalisation step.   
#' @keywords DoubletFinder_prep
#' @return A list with one component for each sample. Each component contains a Seurat object with the clustering and UMAP results,
#'   the BCmvn, the proportion of homotypic doublets and the nExp_poi an nExp_poi.adj metrics. 
#' 
DoubletFinder_prep<-function(input_folder,min.cells=3,min.features=200,dims=50,resolution=0.8,doublet_rate=0.1,individuals=NULL,mt.symbol=":MT-"){

    if(is.null(names(input_folder))){
        stop("Parameter input_folder should be a named vector. The names are to be used as sampleIDs!")
    }
    if(is.null(names(doublet_rate))){
        stop("Parameter doublet_rate should be a named vector. The names are to be used as sampleIDs!")
    }
    ide<-identical(sort(names(input_folder)),sort(names(doublet_rate)))
    if(!ide){
        stop("The doublet_rate names do not match the names of the input folder.")
    }
    sl<-sort.list(names(doublet_rate))
    doublet_rate<-doublet_rate[sl]
    sl<-sort.list(names(input_folder))
    input_folder<-input_folder[sl]

    if(!is.null(individuals)){
    	ide<-identical(sort(names(input_folder)),sort(names(individuals)))
    	if(!ide){
            stop("The individual names do not match the names of the input folder.")
    	}
    	sl<-sort.list(names(individuals))
    	individuals<-individuals[sl]
    }
    
    newobj<-bcmvn<-homotypic.prop<-nExp_poi<-nExp_poi.adj<-as.list(rep(0,length(input_folder)))
    names(newobj)<-names(bcmvn)<-names(homotypic.prop)<-names(nExp_poi)<-names(nExp_poi.adj)<-names(input_folder)
    
    for(i in 1:length(input_folder)){
    
        mat <- readMM(file = paste(input_folder[i],"matrix.mtx",sep=""))
        feature.names <- read.delim(paste(input_folder[i],"genes.tsv",sep=""),header = FALSE,stringsAsFactors = FALSE)
        barcode.names <- read.delim(paste(input_folder[i],"barcodes.tsv",sep=""),header = FALSE,stringsAsFactors = FALSE)
        colnames(mat) = barcode.names$V1
        rownames(mat) = feature.names$V1

        newobj[[i]] <- CreateSeuratObject(counts = mat,min.cells=min.cells,min.features=min.features)
	newobj[[i]] <- PercentageFeatureSet(newobj[[i]], pattern = mt.symbol, col.name = "percent.mt")

	if(!is.null(individuals)){
	    ind<-individuals[[i]]
	    mm<-match(as.character(rownames(newobj[[i]]@meta.data)),as.character(ind[,1]),nomatch=0)
	    newobj[[i]]@meta.data<-cbind(newobj[[i]]@meta.data,Individuals=ind[mm,2])	    
	    newobj[[i]] <- SCTransform(newobj[[i]],vars.to.regress=c("percent.mt","Individuals"),method = "glmGamPoi")   
	} else {
	    newobj[[i]] <- SCTransform(newobj[[i]],vars.to.regress=c("percent.mt"),method = "glmGamPoi")
	}

        newobj[[i]] <- RunPCA(newobj[[i]])
        newobj[[i]] <- RunUMAP(newobj[[i]], dims = 1:dims)

        sweep <- paramSweep_v3(newobj[[i]], PCs = 1:dims, sct = TRUE)
        sweep.stats <- summarizeSweep(sweep, GT = FALSE)
        bcmvn[[i]] <- find.pK(sweep.stats)

        newobj[[i]] <- FindNeighbors(newobj[[i]], dims = 1:dims)
        newobj[[i]] <- FindClusters(newobj[[i]], resolution = resolution)

        annotations<-newobj[[i]]@meta.data$seurat_clusters

        homotypic.prop[[i]] <- modelHomotypic(annotations)
        nExp_poi[[i]] <- round(doublet_rate[i]*nrow(newobj[[i]]@meta.data))
        nExp_poi.adj[[i]] <- round(nExp_poi[[i]]*(1-homotypic.prop[[i]]))
    
    }

    return(list(Obj=newobj,BCmvn=bcmvn,Homotypic.Proportion=homotypic.prop,nExp_poi=nExp_poi,nExp_poi.adj=nExp_poi.adj))
}


#' Performs the doublet estimation with DoubletFinder.
#'
#' Performs the doublet estimation with DoubletFinder based on the output of the DoubletFinder_prep() function.
#' @param dfobj list. A list of various components containing the necessary estimates to run doublet detection with DoubleFinder. Typically, it is the output
#'   of DoubletFinder_prep() function.
#' @param dims numeric. The number of principal components for dimensinality reduction. Default is 50.
#' @param pN numeric. The number of generated artificial doublets, expressed as a proportion of the merged real-artificial data. Default is set to 0.25, based on 
#'   observation that DoubletFinder performance is largely pN-invariant.
#' @param reuse.pANN logical. If TRUE (default), it performs doublet estimation in two steps (aka updates the initial estimates).
#' @keywords DoubletFinderID
#' @return An updated Seurat object with the important information from DoubletFinder's doublet estimation for each sample.
#'       
DoubletFinderID<-function(dfobj,obj,filter,dims=50,pN=0.25,reuse.pANN=TRUE){
    
    ide<-identical(sort(names(dfobj$BCmvn)),sort(names(obj)))
    if(!ide){
        stop("The obj names should be identical to the dfobj names.")
    }

    sl<-sort.list(names(dfobj$BCmvn))
    for(i in 1:length(dfobj)){
        dfobj[[i]]<-dfobj[[i]][sl]
    }
    sl<-sort.list(names(obj))
    obj<-obj[sl]   
    
    for(i in 1:length(dfobj$BCmvn)){
        
        pk<-as.numeric(as.character(dfobj$BCmvn[[i]]$pK[which.max(dfobj$BCmvn[[i]]$BCmetric)[1]]))
        dfobj$Obj[[i]] <- doubletFinder_v3(dfobj$Obj[[i]],PCs=1:dims, 
					   pN=pN,pK=pk,nExp=dfobj$nExp_poi[[i]],
					   reuse.pANN=FALSE,sct=TRUE)
    	
	gg<-grep("pANN_",colnames(dfobj$Obj[[i]]@meta.data))    

        if(reuse.pANN){
            dfobj$Obj[[i]] <- doubletFinder_v3(dfobj$Obj[[i]],PCs=1:dims, 
					       pN=pN,pK=pk,nExp=dfobj$nExp_poi.adj[[i]], 
					       reuse.pANN=colnames(dfobj$Obj[[i]]@meta.data)[gg],
					       sct = TRUE)
        }

	
        keep<-colnames(obj[[i]])[-filter[[i]]]
	ff1<-as.character(dfobj$Obj[[i]]@meta.data[,ncol(dfobj$Obj[[i]]@meta.data)])
        ff1<-ifelse(ff1=="Singlet","singlet","doublet")
        colu1<-rep("unassigned",nrow(obj[[i]]@meta.data))
        colu1[match(keep,rownames(obj[[i]]@meta.data))]<-ff1
        ff2<-as.numeric(as.character(dfobj$Obj[[i]]@meta.data[,gg]))
        colu2<-rep(-999,nrow(obj[[i]]@meta.data))
        colu2[match(keep,rownames(obj[[i]]@meta.data))]<-ff2
        df<-data.frame(cbind(Ind=colu1,Ind2=colu2))
        colnames(df)<-c("DF_doublet","DF_scores")
        obj[[i]]@meta.data<-cbind(obj[[i]]@meta.data,df)
       
    }
    
  return(obj)
}



#' Summarises the barcode estimates and enables visualisation of the doublet estimates.
#'
#' Summarises the barcode estimates (indivisuals, QC and doublets) and enables visualisation of the doublet estimates. The output is useful for cell filtering.
#' @param obj list. A list of Seurat object. The first component must always be the object with the full barcode set and must be called Full. The others are the 
#'   Seurat objects that have been generated in the subsequet analysis, for example using the SeuratQC(), the celda_decontamination(), any of the doublet identification 
#'   functions etc. One of the objects should be called Ref and contain the data to be kept for further analysis. For example Ref can be a set of filtered (high quality)
#'   cells. If doublet identification has been performed the respective objects should have the names Souporcell, Scrublet and DF. 
#' @param outdir character. A folder to store the plots.
#' @keywords doubletViz
#' @return A list with an updated Seurat object for each sample.
#'  
doubletViz<-function(obj,outdir){
   
    type<-names(obj)    

    # collect all data
    for(i in 2:length(obj)){
	
	ide<-identical(sort(names(obj[[1]])),sort(names(obj[[i]])))
	if(!ide){
	    stop("The names of the obj components must match.")
	}
	sl<-sort.list(names(obj[[1]]))
	obj[[1]]<-obj[[1]][sl]
        sl<-sort.list(names(obj[[i]]))
        obj[[i]]<-obj[[i]][sl]

	for(j in 1:length(obj[[1]])){

	    ss<-setdiff(colnames(obj[[i]][[j]]@meta.data),colnames(obj[[1]][[j]]@meta.data))
	    if(length(ss)>0){
	    	var<-data.frame(matrix(NA,nrow(obj[[1]][[j]]@meta.data),length(ss)))	    	
	    	colnames(var)<-ss
	    
	    	for(k in 1:length(ss)){
		    mm<-match(rownames(obj[[i]][[j]]@meta.data),rownames(obj[[1]][[j]]@meta.data))
		    var[mm,k]<-obj[[i]][[j]]@meta.data[,which(colnames(obj[[i]][[j]]@meta.data)==ss[k])]
	    	}
	   	 obj[[1]][[j]]@meta.data<-cbind(obj[[1]][[j]]@meta.data,var)
	    }

	}

    }


    ref<-obj[[which(names(obj)=="Ref")]]
    obj<-obj[[1]]

    for(i in 1:length(obj)){
	
        ss<-setdiff(colnames(obj[[i]]@meta.data),colnames(ref[[i]]@meta.data))
	mm<-match(rownames(ref[[i]]@meta.data),rownames(obj[[i]]@meta.data),nomatch=0)
	var<-obj[[i]]@meta.data[mm,match(ss,colnames(obj[[i]]@meta.data))]
	ref[[i]]@meta.data<-cbind(ref[[i]]@meta.data,var)

    }

    
    d1<-d2<-d3<-NULL
    for(i in 1:length(ref)){

    	# visualise doublets and find doublet cutoffs
	pdf(paste(outdir,"Seurat_DoubletCuts_",names(ref)[i],".pdf",sep=""))
	    par(mfrow=c(1,2))
	    o1<-ref[[i]]@meta.data
	    if(match("Scrublet",type,nomatch=0)>0){
		d1<-doubletCuts(obj=ref[[i]],
				score.col=which(colnames(ref[[i]]@meta.data)=="Scrublet_scores"),
				doublet.col=which(colnames(ref[[i]]@meta.data)=="Scrublet_doublet"),
				method="Scrublet",
				sampleID=names(ref)[i])
	    }
          
	    if(match("DF",type,nomatch=0)>0){   
		d2<-doubletCuts(obj=ref[[i]],
                                score.col=which(colnames(ref[[i]]@meta.data)=="DF_scores"),
                                doublet.col=which(colnames(ref[[i]]@meta.data)=="DF_doublet"),
                                method="DF",
                                sampleID=names(ref)[i])
	    }

	    if(match("Souporcell",type,nomatch=0)>0){
		p3<-DimPlot(object = ref[[i]], group.by = "Souporcell_doublet") + ggtitle(paste("Souporcell doublets in sample ",names(ref)[i],sep=""))
        	print(p3)
	    }
	    
	    ll<-c("Scrublet_doublet","DF_doublet","Souporcell_doublet")
	    mm<-match(ll,colnames(o1),nomatch=0)
	    o1<-o1[,mm]
	    if(is.null(dim(o1))){
		o1<-matrix(o1,ncol=1)
	    	colnames(o1)<-ll[mm>0]
	    }
	    cons<-apply(o1,1,consensusD,name=colnames(o1))
	    ref[[i]]@meta.data<-cbind(ref[[i]]@meta.data,Consensus_doublet=factor(cons))
	    p4<-DimPlot(object = ref[[i]], group.by = "Consensus_doublet") + ggtitle(paste("Doublets in sample ",names(ref)[i],sep=""))
            print(p4)
	dev.off()


        #message
        print(paste("Download plot: ", outdir,"Seurat_DoubletCuts_",names(ref)[i],".pdf",sep=""))



	# get doublet stats
	pdf(paste(outdir,"Seurat_DoubletStats_",names(ref)[i],".pdf",sep=""))
	    cons.list<-as.list(rep(0,ncol(o1)))
	    names(cons.list)<-colnames(o1)
	    for(j in 1:ncol(o1)){
		cons.list[[j]]<-rownames(o1)[o1[,j]=="doublet"]
	    }
	    if(ncol(o1)>1){
	    	ggv<-ggVennDiagram(cons.list) + ggtitle(paste("Doublets venn diagram in ",names(ref)[i],sep=""))
            	print(ggv)
	    }

	    for(j in 1:ncol(o1)){
		dd<-data.frame(cbind(ref[[i]]@meta.data$nCount_RNA,o1[,j]))
		dd[,2]<-ifelse(dd[,2]=="doublet","doublet","singlet/unassigned")
		dd[,1]<-as.numeric(as.character(dd[,1]))
		p <- ggplot(dd, aes(x=dd[,2], y=dd[,1],fill=factor(dd[,2]))) + geom_boxplot(outlier.shape=NA) +
			scale_fill_manual(values=c("#FF9C71", "gray")) + labs(x="Estimated ID",y="nCount_RNA") + 
			ggtitle(paste(unlist(strsplit(colnames(o1)[j],"_"))," in sample ",names(ref)[i],sep=""))
		print(p)

               dd<-data.frame(cbind(ref[[i]]@meta.data$nFeature_RNA,o1[,j]))
               dd[,2]<-ifelse(dd[,2]=="doublet","doublet","singlet/unassigned")
               dd[,1]<-as.numeric(as.character(dd[,1]))
               p <- ggplot(dd, aes(x=dd[,2], y=dd[,1],fill=factor(dd[,2]))) + geom_boxplot(outlier.shape=NA) +
                        scale_fill_manual(values=c("#FF9C71", "gray")) + labs(x="Estimated ID",y="nFeature_RNA") + 
                        ggtitle(paste(unlist(strsplit(colnames(o1)[j],"_"))," in sample ",names(ref)[i],sep=""))
               print(p)
	    }
	dev.off()	    

	#message
        print(paste("Download plot: ", outdir,"Seurat_DoubletStats_",names(ref)[i],".pdf",sep=""))


    }

  return(list(FullData=obj,FilteredData=ref))
}


#' Generates plots that help decide the best cutoffs for doublet identification.
#'
#' Generates plots that help decide the best cutoffs for doublet identification.
#' @param obj object. A Seurat object with the QC and doublet information.
#' @param score.col numeric. The column that holds the doublet scoring of a particular method.
#' @param doublet.col numeric. The column that holds the doublet ID of a particular method.
#' @param method character. The method for doublet identification. Must be one of Scrublet or DF (shrt for DoubletFinder).
#' @param sampleID character. The sample name to be used in the plot legend.
#' @keywords doubletCuts
#' @return An filtered Seurat object with the doublets.
#'
doubletCuts<-function(obj,score.col,doublet.col,method,sampleID){

    x<-cbind(obj@meta.data[,score.col[1]],obj@meta.data[,doublet.col[1]])
    keep<-!is.na(x[,1])
    x<-x[keep,]
    x<-x[x[,1]>0,]
    cols<-rep("gray",nrow(x))
    cols[x[,2]=="doublet"]<-"#FF9C71"
    x<-cbind(x,cols)
    x<-x[sort.list(as.numeric(as.character(x[,1]))),]
    plot(as.numeric(as.character(x[,1])),cex=0.2,col=x[,3],
                xlab="Barcodes",ylab=paste("sorted ",method," scores",sep=""))
    minD<-min(as.numeric(as.character(x[x[,2]=="doublet",1])),na.rm=TRUE)
    top<-x[as.numeric(as.character(x[,1]))>=(minD-0.05),]
    plot(as.numeric(as.character(top[,1])),cex=0.2,col=top[,3],
                    xlab=paste("Barcodes (top ",method," scores)",sep=""),ylab=paste("sorted top ",method," scores",sep=""))
    dd<-diff(as.numeric(as.character(top[,1])))
    qtop<-as.numeric(quantile(dd,0.99))
    qtop<-as.numeric(top[which(dd>qtop),1])
    abline(h=qtop,lty="dashed",col="gray")
    axis(side=4, at=qtop, labels = FALSE)
    if(length(qtop)>0){
        text(par("usr")[1], round(qtop,3), labels = round(qtop,3), pos = 4, offset=5, xpd = TRUE,cex=0.6)
    }

    cuts<-sort(unique(c(round(qtop,2),round(seq(minD,max(as.numeric(as.character(x[,1]))),0.05),2))))
    o1<-obj
    for(j in 1:length(cuts)){
        o1@meta.data[as.numeric(as.character(o1@meta.data[,score.col[1]]))<cuts[j],score.col[1]]<-0
        if(j==1){
            keep<-o1
        }
        o1@meta.data[,score.col[1]]<-as.numeric(as.character(o1@meta.data[,score.col[1]]))
        p3<-FeaturePlot(object = o1, features = paste(method,"_scores",sep="")) + ggtitle(paste(method," scores > ",cuts[j]," in sample ",sampleID,sep=""))
        print(p3)
    }

return(keep)
}



#' Consensus of doublet identification across multiple methods.
#' 
#' Consensus of doublet identification across multiple methods. It combines the results of any method used
#'   to categorise the data into singlet or non-singlet.
#' @param data character.  A vector of data with each element being a doublet ID from a specific method.
#' @param name character. The method names.
#' @keywords consensusD
#' @return Signlet or the method(s) that report(s) a doublet.
#' 
consensusD<-function(data,name){
    
    w<-which(data=="doublet")
    if(length(w)>0){
        res<-paste(t(matrix(unlist(strsplit(name[w],"_")),nrow=2))[,1],collapse=":")
    } else {
        res<-"singlet/unassigned"
    }
    
  return(res)
}


#' Performs cell filtering.
#'
#' Performs cell filtering using the QC and the doublet criteria. The criteria are user-defined. Sugggested criteria
#'   are: (1) remove all QC-failed barcodes, (2) remove all Souporcell doublets, (3) remove all common doublets of
#'   DoubletFinder and Scrublet and (4) remove all high confidence doublet of each method (Scrublet and DoubletFinder).
#'   The high confidence doublets of the last step are found visually by inspecting the cutoffs of the plots produced by 
#'   the barcodeViz() function. If only one of DoubletFinder and Scrublet is available, skip step 3.
#' @param obj object. A seurat object to be filtered.
#' @param filter list. A list of the barcode numbers to be filtered (one component for each sample or nested factor if exists).
#' @param nested logical. If TRUE, it assumes that the obj is a nested list, i.e. a list within a list. That can be the case
#'   of processing the data per Individual within each sample. Default is FALSE.
#' @param outdir character. A folder to store the plot.
#' @keywords Seurat_cellFiltering
#' @return A filtered Seurat object.
#'  
Seurat_cellFiltering<-function(obj,filter,nested,outdir){
    
    if(is.null(names(obj))){
        stop("Assign names to the obj list to serve as sample IDs.")
    }
    if(is.null(names(filter))){
        stop("Assign names to the filter list to serve as sample IDs.")
    }
    
    ide<-identical(sort(names(obj)),sort(names(filter)))
    if(!ide){
         stop("The obj names do not match the names of the filter.")
    }
    sl<-sort.list(names(obj))
    obj<-obj[sl]
    sl<-sort.list(names(filter))
    filter<-filter[sl]
    
    if(!nested){    
    	ncols<-matrix(0,length(obj),2)
    	for(i in 1:length(obj)){
        
            ncols[i,1]<-ncol(obj[[i]])
	    if(length(filter[[i]])>0){
            	obj[[i]]<-obj[[i]][,-filter[[i]]]
	    }
            ncols[i,2]<-ncol(obj[[i]])
          
        }
    
        cells.table<-data.frame(Sample=rep(names(obj),2),Number_of_cells=c(ncols),Seurat_QC=rep(c("Before","After"),each=length(obj)))
        cells.table$Seurat_QC<-factor(cells.table$Seurat_QC,levels=c("Before","After"))
        p1<-ggplot(cells.table,aes(x=Sample,y=Number_of_cells,fill=Seurat_QC)) +
            geom_bar(stat = "identity",position=position_dodge()) +
            labs(y="Number of cells",x="Sample ID") +
            geom_text(aes(label=Number_of_cells), position=position_dodge(width=0.9), vjust=1.2)
    } else {
	ncols<-matrix(0,length(unlist(obj)),2)
	index<-0
	for(i in 1:length(obj)){
	    for(j in 1:length(obj[[i]])){
		
		index<-index+1
		ncols[index,1]<-ncol(obj[[i]][[j]])
		if(length(filter[[i]][[j]])>0){
		   obj[[i]][[j]]<-obj[[i]][[j]][,-filter[[i]][[j]]]
		}
		ncols[index,2]<-ncol(obj[[i]][[j]])

	    }
	}

	cells.table<-data.frame(Sample=rep(names(unlist(obj)),2),Number_of_cells=c(ncols),Seurat_QC=rep(c("Before","After"),each=length(unlist(obj))))
        cells.table$Seurat_QC<-factor(cells.table$Seurat_QC,levels=c("Before","After"))
        p1<-ggplot(cells.table,aes(x=Sample,y=Number_of_cells,fill=Seurat_QC)) +
            geom_bar(stat = "identity",position=position_dodge()) +
            labs(y="Number of cells",x="Sample ID") +
            geom_text(aes(label=Number_of_cells), position=position_dodge(width=0.9), vjust=1.2)

    }

    pdf(paste(outdir,"CellNumbers_",paste(names(obj),collapse="_"),".pdf",sep=""))
        print(p1)
    dev.off()

    # message
    print(paste("Download plot: ",outdir,"CellNumbers_",paste(names(obj),collapse="_"),".pdf",sep=""))

  return(obj)
}



#' Generates plots of the top expressed genes and the major sources of variability.
#'
#' Generates plots of the top expressed genes and the major sources of variability. It uses tools from the scater package.
#' @param obj list. A list of Seurat objects whose data will be analysed. typically, the output of Seurat_cellFiltering()
#'   function.
#' @param outdir character. A folder to store the plots.
#' @param vars character. A vector of variables included in the meta.data slot of obj to check for their contribution in
#'   explaining the data variability.
#' @param top.expr.genes numeric. The number of top expressed genes to show. Default is 50.
#' @param top.var.genes numeric. The number of top variable genes to include in the variance explained calculations.
#'   Default is 1000.
#' @keywords scater_QC
#' @return A scater object with the QC information.
#'
scater_QC<-function(obj,outdir,vars,top.expr.genes=50,top.var.genes=1000){

    for(i in 1:length(obj)){
        
        counts<-obj[[i]]@assays$RNA@counts
        sce <- SingleCellExperiment(list(counts=as.matrix(counts)),
                                         colData=obj[[i]]@meta.data,
                                         rowData=rownames(counts))
        rownames(sce)<-rownames(counts)
        
        p1<-plotHighestExprs(sce, exprs_values = "counts",n=top.expr.genes)
        sce <- logNormCounts(sce)
        vari<-apply(sce@assays@data$logcounts,1,var)
        sl<-sort.list(vari,decreasing=TRUE)
        vars <- getVarianceExplained(sce[sl[1:top.var.genes],],variables=vars)
        p2<-plotExplanatoryVariables(vars)
        
        pdf(paste(outdir,"scaterQC_",names(obj)[i],".pdf",sep=""))
            print(p1)
            print(p2)
        dev.off()
        
        #message
        print(paste("Download plot: ",outdir,"scaterQC_",names(obj)[i],".pdf",sep=""))
    
    }
    
 return(sce)
}


#' Normalises and joins RNA-seq data from different samples.
#'
#' Normalises and joins RNA-seq data from different samples. After removing the percent.mt and the individual (if available)
#'   effects from the SCTransformed data, the user can merge or integrate the data using Seurat's pipeline.
#' @param obj list. A list of Seurat objects to be joined.
#' @param outdir character. A folder to store the Mean vs Standard Deviation plot of the integrated data.
#' @param join character. One between merging, integrate, reference or none (default) that specifies how the data are to be joined.
#'   Note that the none option does not join the data.
#' @param normalised logical. If TRUE, the data are assumed to be normalised and the SCTransform is not necessary. 
#' @param pcex numeric. The size of the point in the plot. Default is 2.
#' @param add.cell.ids logical. If TRUE (default), appends the corresponding values to the start of each objects' cell
#'   names with the obj name.
#' @param dims numeric. Number of dimensions to use. Default is 50.
#' @param reference numeric. The dataset (obj component) to be used as reference for join if the join = 'reference' option is
#'   selected. Default is 1.
#' @param nfeatures numeric. The number of variable features to report. Default is 2000.
#' @param top.features numeric. The number of top variable features to highlight in the plot. Default is 10.
#' @param features2integrate. A vector of features (genes) whose data are to be corrected. If NULL (default) only the 
#'   anchor genes are corrected. The user can specify other features, even all of them, for correction.
#' @param regress.out character. A vector of factors (column names of the meta.data slot) whose effect are removed from the data.
#'   Default is percent.mt but the individuals may also need to be included if the information is present.
#' @param sampleID character. A project ID for the integrated data. Default is Dataset.
#' @keywords Seurat_normalisation
#' @return An integrated Seurat object.
#'  
Seurat_normalisation<-function(obj,outdir,join="none",normalised=FALSE,pcex=2,add.cell.ids=TRUE,dims=50,
                               reference=1,nfeatures=2000,top.features=10,features2integrate=NULL,
                               regress.out="percent.mt",sampleID="Dataset"){
    
    if(!is.list(obj)){
        obj<-list(obj)
        names(obj)<-sampleID
    }
    
    if(is.null(names(obj))){
         stop("Assign names to the obj list to serve as sample IDs.")
    }
    
    if(length(obj)==1){
        if(join!="none"){
            stop("Nothing to merge / integrate. Set join = none.")
        }
    }
    
    if(match(join,c("merging","integration","reference","none"),nomatch=0)==0){
        stop("The data should be joined with merging, integration or reference. Select none if joining is not relevant.")
    }
    
    integrated<-NULL
    p1<-as.list(rep(NA,length(obj)))
    
    for(i in 1:length(obj)){
        
        if(join!="merging"){
	    if(!normalised){
            	print(paste("Now applying SCTransform to ",names(obj)[i],sep=""))
            	obj[[i]]<-SCTransform(obj[[i]], vars.to.regress = regress.out, verbose = FALSE,method="glmGamPoi")
	    }
        }
        
        if(join=="none"){
            obj[[i]] <- FindVariableFeatures(obj[[i]], selection.method = "vst", nfeatures = nfeatures)
            #p1[[i]]<-VariableFeaturePlot(obj[[i]])
            #p1[[i]]<-LabelPoints(plot = p1[[i]], points = head(VariableFeatures(obj[[i]]), top.features), repel = TRUE,size=pcex) +
            #            ggtitle(paste("Mean vs StD for ",names(obj)[i],sep=""))
        }
    }
    
    if(join=="merging"){
        print("Now merging the samples.")
        if(add.cell.ids){
            integrated <- merge(x = obj[[1]], y = obj[2:length(obj)], add.cell.ids = names(obj), project = sampleID)
        } else {
            integrated <- merge(x = obj[[1]], y = obj[2:length(obj)],project = sampleID)
        }
	if(!normalised){
            print("Now applying SCTransform to the merged object.")
            integrated<-SCTransform(integrated, vars.to.regress = regress.out, verbose = FALSE,method="glmGamPoi")
	}
        integrated <- FindVariableFeatures(integrated, selection.method = "vst", nfeatures = nfeatures)
        #p1[[1]]<-VariableFeaturePlot(integrated)
        #p1[[1]]<-LabelPoints(plot = p1[[1]], points = head(VariableFeatures(integrated), top.features),  repel = TRUE,size=pcex) +
        #            ggtitle(paste("Mean vs StD for ",sampleID,sep=""))
    }
    
    if(join=="integration"){
        print("Now integrating the samples.")
        features <- SelectIntegrationFeatures(object.list = obj, nfeatures = nfeatures)
        list <- PrepSCTIntegration(object.list = obj, anchor.features = features)
        anchors <- FindIntegrationAnchors(object.list = list, normalization.method = "SCT",anchor.features = features,dims=1:dims)
        integrated <- IntegrateData(anchorset = anchors, normalization.method = "SCT",features.to.integrate=features2integrate,dims=1:dims)
    }
    
    if(join=="reference"){
        print("Now integrating the samples.")
        features <- SelectIntegrationFeatures(object.list = obj, nfeatures = nfeatures)
        list <- PrepSCTIntegration(object.list = obj, anchor.features = features)
        if(is.numeric(reference)){
            reference_dataset<-reference
        } else {
            reference_dataset<- match(reference,names(obj))
            if(length(reference_dataset)==0){
                print("The reference ID was not found in the obj names. Setting to reference = 1.")
            }
        }
        anchors <- FindIntegrationAnchors(object.list = list, normalization.method = "SCT",anchor.features = features, reference = reference_dataset,reduction = "rpca",dims=1:dims)
        integrated <- IntegrateData(anchorset = anchors, normalization.method = "SCT",dims=1:dims)
        #integrated <- FindVariableFeatures(integrated, selection.method = "vst", nfeatures = nfeatures)
        #p1[[1]]<-VariableFeaturePlot(integrated)
        #p1[[1]]<-LabelPoints(plot = p1[[1]], points = head(VariableFeatures(integrated), top.features), repel = TRUE,size=pcex) +
        #            ggtitle(paste("Mean vs StD for ",sampleID,sep=""))
    }
    
    pdf(paste(outdir,"Seurat_Norm_MeanVar_",sampleID,".pdf",sep=""))
        for(i in 1:length(obj)){
            if(!is.na(p1[[i]])){
                print(p1[[i]])
            }
        }
    dev.off()
 
    # message
    print(paste("Download plot: ",outdir,"Seurat_Norm_MeanVar_",sampleID,".pdf",sep=""))
       
  return(list(Integrated=integrated,Obj=obj))
}



#' Extracts the requested component from the rownames (gene IDs) of the Seurat object.
#' 
#' Extracts the requested component from the rownames (gene IDs) of the Seurat object. The gene IDs of the Seurat object
#'   have been formatted as EnsemblID:GeneName. The function will extract either the EnsemblID or the GeneName.
#' @param data character. A vector of gene IDs.
#' @param symbol character. The symbol that separates the EnsemblID from the GeneName. Defaut is ':'.
#' @param what character. If Names (default), the gene names will be extracted, otherwise the Ensembl IDs will be extracted.
#' @param remove.dot logical. If TRUE (default) and what != Names, the dot and what follows it from the Ensembl IDs will be 
#'   removed.
#' @keywords GeneNames
#' @return A vector with the extracted gene names or Ensembl IDs.
#' 
GeneNames<-function(data,symbol=":",what="Names",remove.dot=TRUE){
    ss<-strsplit(as.character(data), symbol)
    k<-ifelse(what=="Names",2,1)
    res<-rep(0,length(ss))
    for(i in 1:length(ss)){
        res[i]<-ss[[i]][min(k,length(ss[[i]]))]
        if(k==1 & remove.dot==TRUE){
            res[i]<-unlist(strsplit(as.character(res[i]),".",fixed=TRUE))[1]
        }
    }
    return(res)
}



#' Finds the optimal data dimensionality.
#'
#' Finds the optimal data dimensionality using JackStraw, Elbow and Heatmap plots.
#' @param obj object. An integrated Seurat object.
#' @param sampleID. An id to be used in plot filenames.
#' @param plot_outdir character. A folder to store the plots.
#' @param data_outdir character. A folder to store the data (PCA loadings) of all genes (top loadings are for genes that explain best the 
#'   variability of the ith component).
#' @param nfeatures numeric. The number of top features per PC whose loading will be highlighted in appropriate plots. Default is 100. 
#' @param cells numeric. The number of top variable cells that will be depicted in the heatmaps. Default is 500.
#' @param vizDims numeric. The number of PCs to be visualised / checked. A subset of them will be the optimal number. Default is 30.
#' @param dimensionality.search character. The method used to identify the optimal dimensionality. Options are Elbow (default) plot and JackStraw.
#'   More than one option can be used. Default is Elbow (faster). It is also advised that the user looks at the heatmap to see after which component 
#'   the separation is not obvious anymore.
#' @param ycex numeric. The dot size on the PCA loadings plots. Default is 5.
#' @param balanced logical. If TRUE (default), the top 500 most variable cells will be used in both sides of the heatmap.
#' @keywords Seurat_dimensionality
#' @return An updated Seurat object.
#'    
Seurat_dimensionality<-function(obj,sampleID,plot_outdir,data_outdir,nfeatures=100,cells=500,vizDims=30,dimensionality.search="Elbow",ycex=5,balanced=TRUE){
 
    mm<-match(dimensionality.search,c("JackStraw","Elbow","None"),nomatch=0)   
    if(length(which(mm>0))==0){
        stop("The dimensionality.search may take the value JackStraw, Elbow or None.")
    }

    obj <- RunPCA(obj,npcs = vizDims,ndims.print = 1:vizDims, nfeatures.print = nfeatures)
    write.table(obj@reductions$pca@feature.loadings,paste(data_outdir,"ProcessedData/Seurat_topGenes_byPC_",sampleID,".txt",sep=""),sep="\t")

    # message
    print(paste("Download data: ",data_outdir,"ProcessedData/Seurat_topGenes_byPC_",sampleID,".txt",sep=""))


    p1<-as.list(rep(0,vizDims))
    for(i in 1:vizDims){
        p1[[i]]<-VizDimLoadings(obj, dims = i, reduction = "pca", nfeatures = nfeatures) + theme(text = element_text(size=12),axis.text.x = element_text(size = 12),axis.text.y = element_text(size = ycex))
    }
    
    p2<-as.list(rep(0,vizDims))
    for(i in 1:vizDims){
        p2[[i]]<-DimHeatmap(obj, dims = i, nfeatures=nfeatures, cells=cells, balanced = balanced,fast=F) +
                    theme(text = element_text(size=12),axis.text.x = element_text(size = 12),axis.text.y = element_text(size = ycex))
    }

    if(match("JackStraw",dimensionality.search,nomatch=0)>0){

	print("Now running JackStraw")
        obj <- JackStraw(obj, num.replicate = 100)
        obj <- ScoreJackStraw(obj, dims = 1:vizDims)
        p3a<-JackStrawPlot(obj, dims = 1:vizDims)

    }
    if(match("Elbow",dimensionality.search,nomatch=0)>0){

	print("Now generating Elbow plot")
        p3b<-ElbowPlot(obj,ndims = vizDims, reduction = "pca")
    
    }
    
    pdf(paste(plot_outdir,"Seurat_DimViz_",sampleID,".pdf",sep=""))
        for(i in 1:length(p1)){
            
            print(p1[[i]])
            print(p2[[i]])
            
        }

	if(match("JackStraw",dimensionality.search,nomatch=0)>0){
            print(p3a)
	}

        if(match("Elbow",dimensionality.search,nomatch=0)>0){
            print(p3b)
        }

    dev.off()

    # message
    print(paste("Download plot: ",plot_outdir,"Seurat_DimViz_",sampleID,".pdf",sep=""))
   
  return(obj)
}



#' Performs the dimensionality reduction and cell clustering.
#'
#' Performs the dimensionality reduction and cell clustering.
#' @param obj object. A Seurat object with the normalised and, if needed, joined data.
#' @param outdir character. A folder to store the plots.
#' @param sampleID character. A sample ID to be used in the plot filename.
#' @param cluster.by character. Which FACTOR variables to highlight in the UMAP clusters. The cluser IDs 
#'   are always generated and need not be specified. Default is NULL (nothing is highlighted except for the 
#'   cluster IDs).
#' @param gradient.by character. Which CONTINUOUS variables to highlight in the UMAP clusters. Default is NULL
#'   (nothing is highlighted). 
#' @param dims numeric. The PCs to be used for UMAP. Default is 1:50 (the first 50). Note that this is not
#'   the number of PCs to be used. We specify exactly which PCs will be used in order to remove the effect
#'   of a PC that explains technical or other variability.
#' @param resolution numeric. Value of the resolution parameter, use a value above (below) 
#'   1.0 if you want to obtain a larger (smaller) number of communities. Default is 0.8.
#' @param genes.to.show character. A vector of genes whose gradient will be plotted on the UMAP. Default is
#'   NULL (no genes will be plotted). 
#' @keywords Seurat_cellClustering
#' @return An updated Seurat object.
#'  
Seurat_cellClustering<-function(obj,sampleID,outdir,cluster.by=NULL,gradient.by=NULL,dims=1:50,resolution=0.8,genes.to.show=NULL){
    
    obj <- FindNeighbors(obj, dims = dims)
    obj <- FindClusters(obj, resolution = resolution)
    obj <- RunUMAP(obj, dims = dims)
    
    pdf(paste(outdir,"Seurat_UMAPclustering_",sampleID,".pdf",sep=""))
        
        p1<-DimPlot(obj, reduction = "umap",label=TRUE)
        print(p1)
	
	if(!is.null(cluster.by)){
	    mm<-match(cluster.by,colnames(obj@meta.data),nomatch=0)
	    mm<-mm[mm>0]
	    if(length(mm)==0){
	    	stop("Please specify appropriate cluster.by variables")
	    }

	    for(i in 1:length(mm)){
        
            	p2<-DimPlot(obj, group.by=colnames(obj@meta.data)[mm[i]],reduction = "umap")
            	print(p2)

            }
 	}

       if(!is.null(gradient.by)){
            mm<-match(gradient.by,colnames(obj@meta.data),nomatch=0)
            mm<-mm[mm>0]
            if(length(mm)==0){
                stop("Please specify appropriate gradient.by variables")
            }

            for(i in 1:length(mm)){

                p3<-FeaturePlot(obj, features=colnames(obj@meta.data)[mm[i]],reduction = "umap")
                print(p3)

            }
        }


       if(!is.null(genes.to.show)){
	    p4a<-p4b<-as.list(rep(0,nrow(genes.to.show)))
	    mm<-match(genes.to.show[,1],rownames(obj@assays$RNA@data),nomatch=0)
    	    genes.to.show<-genes.to.show[mm>0,]
	    p4a<-p4b<-as.list(rep(0,nrow(genes.to.show)))
	    DefaultAssay(obj)<-"RNA"
	    obj@assays$RNA@data<-LogNormalize(obj@assays$RNA@data)
	    for(i in 1:nrow(genes.to.show)){
        
        	p4a[[i]]<-FeaturePlot(obj,features=genes.to.show[i,1],label=TRUE,order=TRUE) + 
		 ggtitle(paste(genes.to.show[i,1]," (",genes.to.show[i,2],")",sep=""))
        	p4b[[i]]<-VlnPlot(obj,features=genes.to.show[i,1]) + 
		 ggtitle(paste(genes.to.show[i,1]," (",genes.to.show[i,2],")",sep=""))
        
    	     }
	     print(p4a)
	     print(p4b)
	}

       
    dev.off()

    # message
    print(paste("Download plot: ",outdir,"Seurat_UMAPclustering_",sampleID,".pdf",sep=""))


  return(obj)
}



#' Generates plots showing the estimated cell cluster composition.
#'
#' Generates plots showing the estimated cell cluster composition. The composition of each cluster with 
#'   respect to a user-defined variable is produced, e.g. how many cells of cluster i come from dataset1 
#'   and how many from dataset2.
#' @param obj object. A Seurat object witht the cell clusters.
#' @param mixVar character. The levels of an additional variable to be tested.
#' @param mixVar.name character. A name for the additional variable (to be used in plot legends and file names).
#' @param what character. If dots (default), it generates a dotplot. If bars, it generates a barplot. 
#' @param outdir character. A folder to store the plots.
#' @keywords Cluster_mixing
#' @return The tabulated association between the clusters and the additional variable.
#'
Cluster_mixing<-function(obj,mixVar,mixVar.name,outdir,what="dots"){

    clusters<-Idents(obj)
    
    if(length(mixVar)<length(mixVar.name)){
        stop("The length of mixVar must be >= the length of mixVar.name.")
    }
    if(length(mixVar)>length(mixVar.name)){
        mixVar.name<-rep(mixVar.name[1],length(mixVar))
    }
    
    #p1<-p2<-p3<-as.list(rep(0,length(mixVar)))
    p1<-as.list(rep(0,length(mixVar)))
    pdf(paste(outdir,"ClusterMixing_",mixVar.name[1],".pdf",sep=""))

    for(k in 1:length(mixVar)){
	
	vv<-which(colnames(obj@meta.data)==mixVar[k])
        tt<-table(clusters,obj@meta.data[,vv])
	cpm.tt<-cpm(tt)
        sumrows<-apply(cpm.tt,1,sum)
        #sumcols<-apply(tt,2,sum)
        #wei<-sumcols/sum(sumcols)
        perc1<-cpm.tt/sumrows
        #perc2<-perc1
        #for(i in 1:ncol(perc1)){
        #   perc2[,i]<-perc1[,i]/wei[i]
        #}
        #perc2<-perc2/apply(perc2,1,sum)
        #perc3<-tt
        #for(i in 1:ncol(tt)){
        #    perc3[,i]<-tt[,i]/sumcols[i]
        #}

        cc<-colnames(cpm.tt)
        ctt<-c(tt)
        ctt1<-c(perc1)
        #ctt2<-c(perc2)
        #ctt3<-c(perc3)
        #tt<-data.frame(cbind(rep(rownames(tt),ncol(tt)),ctt,ctt1,ctt2,ctt3,rep(cc,each=nrow(tt))))
	tt<-data.frame(cbind(rep(rownames(tt),ncol(tt)),ctt,ctt1,rep(cc,each=nrow(tt))))
        #colnames(tt)<-c("Clusters","Cells","pCells1","pCells2","pCells3",mixVar.name[k])
	colnames(tt)<-c("Clusters","Cells","pCells1",mixVar.name[k])
	tt<-tt[sort.list(as.numeric(as.character(tt$Clusters))),]
        tt$Clusters<-factor(tt$Clusters,levels=unique(tt$Clusters))
        tt[,ncol(tt)]<-factor(tt[,ncol(tt)])
        tt$Cells<-as.numeric(as.character(tt$Cells))
        tt$pCells1<-100*as.numeric(as.character(tt$pCells1))
        #tt$pCells2<-100*as.numeric(as.character(tt$pCells2))
        #tt$pCells3<-100*as.numeric(as.character(tt$pCells3))

	if(what=="bars"){
           p1[[k]]<-ggplot(tt,aes(x=Clusters,y=pCells1,fill=tt[,ncol(tt)])) +
            	geom_bar(stat = "identity",position=position_dodge()) +
           	labs(y="% of cells",x="Cluster",title="% of cells per cluster (clusters sum to 100%)",fill = mixVar.name[k])+
            	geom_text(aes(label=Cells), position=position_dodge(width=0.9), vjust=1.2,size=2) +
            	scale_y_continuous(limits=c(0,max(tt$pCells1)))
	   print(p1[[k]])

         #  p2[[k]]<-ggplot(tt,aes(x=Clusters,y=pCells2,fill=tt[,ncol(tt)])) +
         #       geom_bar(stat = "identity",position=position_dodge()) +
         #       labs(y="% of cells",x="Cluster",title="% of cells per cluster normalised to sample size (clusters sum to 100%)",fill = mixVar.name[k])+
         #       geom_text(aes(label=Cells), position=position_dodge(width=0.9), vjust=1.2,size=2) +
         #       scale_y_continuous(limits=c(0,max(tt$pCells2)))
	 #  print(p2[[k]])

          # p3[[k]]<-ggplot(tt,aes(x=Clusters,y=pCells3,fill=tt[,ncol(tt)])) +
          #        geom_bar(stat = "identity",position=position_dodge()) +
          #        labs(y="% of cells",x="Cluster",title="% of cells per sample (samples sum to 100%)",fill = mixVar.name[k])+
          #        geom_text(aes(label=Cells), position=position_dodge(width=0.9), vjust=1.2,size=2) +
          #        scale_y_continuous(limits=c(0,max(tt$pCells3)))
	  # print(p3[[k]])

        } else {

	   p1[[k]]<-ggplot(tt,aes(x=Clusters,y=tt[,ncol(tt)],color=pCells1,size=2)) + geom_point() + scale_color_viridis_c(name = 'Percent') +
		    labs(x="Clusters",y=mixVar[k],title="% of cells per cluster (clusters sum to 100%)")
	   print(p1[[k]])
           #p2[[k]]<-ggplot(tt,aes(x=Clusters,y=tt[,ncol(tt)],color=pCells2,size=2)) + geom_point() + scale_color_viridis_c(name = 'Percent') +
           #         labs(x="Clusters",y=mixVar[k],title="% of cells per cluster normalised to sample size (clusters sum to 100%)")
           #print(p2[[k]])
	   #p3[[k]]<-ggplot(tt,aes(x=Clusters,y=tt[,ncol(tt)],color=pCells3,size=2)) + geom_point() + scale_color_viridis_c(name = 'Percent') +
           #         labs(x="Clusters",y=mixVar[k],title="% of cells per sample (samples sum to 100%)")
           #print(p3[[k]])

	}

	

    }
    
    dev.off()

    # message
    print(paste("Download plot: ",outdir,"ClusterMixing_",mixVar.name[1],".pdf",sep=""))

 return(obj)
}




#' Performs the subclustering of a user-specified set of clusters.
#'
#' Performs the subclustering of a user-specified set of clusters. It shows the subclusters in the reduced and the
#'   original UMAP dimensions.
#' @param obj object. A Seurat object with the UMAP adnd the clustering information to be processed. Typically, the
#'   output of Seurat_cellClustering() function.
#' @param clusters list. A list with components the clusters that are to be further separated into subclusters. A name
#'   for each component is required for plotting reasons.
#' @param sampleID character. A sample ID to be used in the plot filename.
#' @param cluster.by character. Which FACTOR variables to highlight in the UMAP clusters. The cluser IDs 
#'   are always generated and need not be specified. Default is NULL (nothing is highlighted except for the 
#'   cluster IDs).
#' @param gradient.by character. Which CONTINUOUS variables to highlight in the UMAP clusters. Default is NULL
#'   (nothing is highlighted). 
#' @param outdir character. A folder to store the plots.
#' @param dims numeric. The PCs to be used for UMAP. Default is 1:50 (the first 50). Note that this is not
#'   the number of PCs to be used. We specify exactly which PCs will be used in order to remove the effect
#'   of a PC that explains technical or other variability.
#' @param resolution numeric. Value of the resolution parameter, use a value above (below) 
#'   1.0 if you want to obtain a larger (smaller) number of communities. Default is 0.8.
#' @keywords Seurat_cellSubClustering
#' @return An updated Seurat object with the subclusters.
#' 
Seurat_cellSubClustering<-function(obj,clusters,sampleID,cluster.by,gradient.by,outdir,dims=1:50,resolution=0.8){
    
    if(is.null(names(clusters))){
        stop("The clusters should be a named list whise components contain the cluster(s) to be subclustered.")
    }
    
    obj_byDay<-as.list(rep(0,length(clusters)))
    names(obj_byDay)<-names(clusters)
    for(i in 1:length(clusters)){
        
        o1<-obj[,clusters[[i]]]
        o1updated<-Seurat_cellClustering(obj=o1,sampleID=paste(sampleID,"_",names(clusters)[i],"sub",sep=""),
                                         cluster.by=cluster.by,gradient.by=gradient.by,
                                         dims=dims,resolution=resolution,outdir=plotsOutput)
        obj_byDay[[i]]<-makeSubclusters(all=o1,sub=o1updated,sampleID=sampleID,index=names(clusters)[i],outdir=plotsOutput)
    }

    obj<-joinSubclusters(obj=obj,subs=obj_byDay,sampleID=sampleID,outdir=plotsOutput)
    
  return(obj)
}


#' It generates the subclusters of a given cell subset.
#'
#' It generates the subclusters of a given cell subset.
#' @param all object. A Seurat object with the original clustering of the chosen cell subset.
#' @param sub object. A Seurat object with the subclustering of the chosen cell subset.
#' @param sampleID character. A sample ID to be used in the plot filename.
#' @param index character. A sample ID to be used in the plot filename to indicate the specific 
#'   cell subset.
#' @param outdir character. A folder to store the plots.
#' @keywords makeSubclusters
#' @return A Seurat object with the subclusters for the chosen cell set.
#' 
makeSubclusters<-function(all,sub,sampleID,index,outdir){
    
    s<-sub@meta.data$seurat_clusters
    s<-paste(index,"_",s,sep="")
    all@meta.data<-cbind(all@meta.data,seurat_subclusters=s)
    p<-DimPlot(all, group.by="seurat_subclusters",reduction = "umap")
    
    pdf(paste(outdir,"Seurat_UMAPclustering_",sampleID,"_",index,".pdf",sep=""))
        print(p)
    dev.off()
    
    # message
    print(paste("Download plot: ",outdir,"Seurat_UMAPclustering_",sampleID,"_",index,".pdf",sep=""))
    
  return(all)
}


#' Joins the subclusters of various cell sets.
#'
#' Joins the subclusters of various cell sets.
#' @parameter obj object. A Seurat object with the original clusters of all cells.
#' @param subs list. A list of Seurat objects whose subclusters have been estimated.
#' @param sampleID character. A sample ID to be used in the plot filename.
#' @param outdir character. A folder to store the plots.
#' @keywords joinSubclusters
#' @return An updated Seurat object with the subclusters.
#'
joinSubclusters<-function(obj,subs,sampleID,outdir){
    
    if(length(subs)<2){
        stop("The length of subs must be > 1.")
    }
    
    cc<-cbind(rownames(subs[[1]]@meta.data),subs[[1]]@meta.data$seurat_subclusters)
    for(i in 2:length(subs)){
        cc<-rbind(cc,cbind(rownames(subs[[i]]@meta.data),subs[[i]]@meta.data$seurat_subclusters))
    }
    
    mm<-match(as.character(rownames(obj@meta.data)),cc[,1],nomatch=0)
    if(length(which(mm==0))){
        print("Some cells do not have subclusters assigned to them. The seurat_clusters will be used.")
        mm1<-match(as.character(rownames(obj@meta.data)),cc[,1])
        cc<-cc[mm,]
        cc[is.na(cc[,1]),2]<-obj@meta.data$seurat_clusters[is.na(cc[,1])]
    } else {
        cc<-cc[mm,]
    }
    obj@meta.data<-cbind(obj@meta.data,seurat_subclusters=factor(cc[,2]))
    
    p<-DimPlot(obj, group.by="seurat_subclusters",reduction = "umap")
    
    pdf(paste(outdir,"Seurat_UMAPclustering_",sampleID,"_withSubclusters.pdf",sep=""))
        print(p)
    dev.off()
    
    # message
    print(paste("Download plot: ",outdir,"Seurat_UMAPclustering_",sampleID,"_withSubclusters.pdf",sep=""))
    
  return(obj)
}



#' Splits the data in terms of a user-specified factor.
#'
#' Splits the data in terms of a user-specified factor such as the different individuals. Each sub-dataset
#'   will be treated individually in the downstream analysis. 
#' @param obj object. A seurat object with all the necessary information for the split includying the cell 
#'   clustering.
#' @param by character. The values of the variable that the split is based on (e.g. the different individuals).
#' @param outdir character. A folder to store the plots.
#' @keywords dataSplit
#' @return A list of Seurat objects after the split.
#'  
dataSplit<-function(obj,by,outdir){
    
    obji<-as.list(rep(0,length(unique(by))))
    names(obji)<-paste("I",sort(unique(by)),sep="")
    pdf(paste(outdir,"Seurat_SplitUMAP.pdf",sep=""))
        for(i in 1:length(obji)){
            obji[[i]]<-obj[,which(by==sort(unique(by))[i])]
	    oo<-obji[[i]]
            tt<-table(oo@meta.data$seurat_clusters)
            x<-as.numeric(as.character(oo@meta.data$seurat_clusters))
            for(j in 1:length(tt)){
                x[as.numeric(as.character(oo@meta.data$seurat_clusters))==names(tt)[j]]<-paste(names(tt)[j]," (",tt[j],")",sep="")
            }
            sl<-cbind(unique(x),t(matrix(unlist(strsplit(unique(x),"(",fixed=T)),nrow=2))[,1])
            sl<-sl[sort.list(as.numeric(as.character(sl[,2]))),]
            oo@meta.data$seurat_clusters<-factor(x,levels=as.character(sl[,1]))
            Idents(oo)<-oo@meta.data$seurat_clusters
            p<-DimPlot(oo,reduction="umap",label=TRUE) + ggtitle(paste("Seurat clusters for Individual ",
                                sort(unique(by))[i],sep=""))
            print(p)
        }
    dev.off()

  return(obji)
}


#' Generates a volcano plot with the top markers of the differential expression analysis.
#'
#' Generates a volcano plot with the top markers of the differential expression analysis.
#' @param de data frame. The differetial expression statistics of the pairwiseDE() or onevsallDE().
#' @param id character. An ID to be used in the filename of the stored volcano plot.
#' @param Pcut numeric. The adjusted p-value cutoff to detect differential expression.
#' @param avg_logfc.cut numeric. Limit testing to genes which show, on average, at least X-fold difference (log-scale)
#'   between the two groups of cells. Default is 0.25 Increasing logfc.threshold speeds up the function, but can miss
#'   weaker signals.
#' @param top.genes numeric. The number of genes to visualise in plots.
#' @param outdir character. A folder to store the volcano plot.
#' @param interactive logical. If TRUE, it generates an interactive plotly volcano.
#' @keywords doVolcano
#' @return A data frame that the volcano plot is based on.
#'
doVolcano<-function(de,id,Pcut,avg_logfc.cut,top.genes,outdir,interactive){

    x<-de[,c(1:3,6)]
    x$Sig<-rep(FALSE,nrow(x))
    x$Sig[as.numeric(as.character(x[,4]))<=Pcut & abs(as.numeric(as.character(x[,3])))>avg_logfc.cut]<-TRUE
    x[,2]<- -log(as.numeric(as.character(x[,2])),10)
    w.inf<-which(x[,2]=="Inf")
    if(length(w.inf)>0){
    	x[w.inf,2]<-max(as.numeric(as.character(x[-w.inf,2])))+50
    }
    x$show<-FALSE

    x1<-x[x$Sig==TRUE,]
    x2<-x[x$Sig==FALSE,]
    if(nrow(x1)>0){
	x1up<-x1[as.numeric(as.character(x1[,3]))>0,]
	x1down<-x1[as.numeric(as.character(x1[,3]))<0,]
	
	if(nrow(x1up)>0){
           x1up<-x1up[sort.list(as.numeric(as.character(x1up[,2])),decreasing=T),]
           x1up$show[1:min(top.genes,nrow(x1up))]<-TRUE
 	   x1up<-x1up[sort.list(as.numeric(as.character(x1up[,3])),decreasing=T),]
	   x1up$show[1:min(top.genes,nrow(x1up))]<-TRUE
        }
	
	if(nrow(x1down)>0){
	   x1down<-x1down[sort.list(as.numeric(as.character(x1down[,2])),decreasing=T),]
           x1down$show[1:min(top.genes,nrow(x1down))]<-TRUE
	   x1down<-x1down[sort.list(as.numeric(as.character(x1down[,3]))),]
           x1down$show[1:min(top.genes,nrow(x1down))]<-TRUE
	}

	if(nrow(x1up)>0 & nrow(x1down)>0){
	   x1<-rbind(x1up,x1down)
	}
	if(nrow(x1up)>0 & nrow(x1down)==0){
	   x1<-x1up
	}
	if(nrow(x1up)==0 & nrow(x1down)>0){
           x1<-x1down
        }
    }
    x<-rbind(x2,x1)
    
    if(interactive){
	
	cc<-rep("#BBBBBB",nrow(x))
    	cc[x$Sig==TRUE]<-"#6ACDDE"

	p<-plot_ly(x,
            x=as.numeric(as.character(x[,3])),
            y=as.numeric(as.character(x[,2])),
            color=x$Sig,
            colors=cc,
            type="scatter",
            text = paste(GeneNames(x[,1]),
                ": logFC=",round(as.numeric(as.character(x[,3])),3),
                " FDR=",scientific(as.numeric(as.character(x[,4])),digits=3),sep="")) %>%
            layout(title="Interactive volcano plot",
                xaxis=list(title="log2 FC",range=c(min(as.numeric(as.character(x[,3])))-1,max(as.numeric(as.character(x[,3])))+1)),
                yaxis=list(title="-log10 PValue",range=c(min(as.numeric(as.character(x[,2]))),max(as.numeric(as.character(x[,2])))+3)))	
	
	saveWidget(p, paste(outdir,"Volcano_",id,".html",sep=""), selfcontained = F)

	# message
	print(paste("Download plot: ",outdir,"Volcano_",id,".html and ",outdir,"Volcano_",id,"_files (folder)",sep=""))	

    } else {
    	pdf(paste(outdir,"Volcano_",id,".pdf",sep=""))
      	    p<-ggplot(x,aes(x=avg_log2FC,y=p_val,color=Sig))+geom_point() +
            	scale_color_manual(values=c('#BBBBBB','#6ACDDE')) +
            	geom_text(aes(label=ifelse(show==TRUE,as.character(GeneNames(rownames(x))),'')),hjust=0,vjust=0,size=2) +
            	labs(x="log2 FC",y="-log10 Pvalue") +
		xlim(min(as.numeric(as.character(x[,3])))-1,max(as.numeric(as.character(x[,3])))+1)+
		ylim(min(as.numeric(as.character(x[,2]))),max(as.numeric(as.character(x[,2])))+3)
       	    print(p)
    	dev.off()
	
	 # message
    	 print(paste("Download plot: ",outdir,"Volcano_",id,".pdf",sep=""))
    }


return(x)
}

#' Performs DE analysis of all pairwise cluster comparisons using the LR model.
#'
#' Performs DE analysis of all pairwise cluster comparisons using the LR model and produces by default a volcano plot.
#' @param obj object. A seurat object with the clustering information.
#' @param comparisons matrix. A matrix with the clusters being compared (in rows).
#' @param comparison.id character. A unique ID to be used in the filename of the volcano plot.
#' @param outdir character. A folder to store the plots.
#' @param cells numeric. The minimum number of cells that either cluster should have for the comparison 
#'   to be performed. Default is 3. It is useful when comparing cells from subsets.
#' @param tx2genes character. The file name with the gene annotation information.
#' @param use.FC logical. If TRUE (default), the DE estimates are sorted by logFC.
#' @param top.genes numeric. The number of genes to visualise in plots.
#' @param factors character. A list of factors whose effect is removed from the data.
#' @param tx2genes.column numeric. The column of the annotation file that matches the original rownames of the matrix.mtx (to update the
#'   rownames in the appropriate form). Default is column="ENSG_nodot" that uses the Ensembl gene IDs without the '.x' symbol at the end.
#'   Other options are ENSG_dot and GeneName depending on the dataset.
#' @param what character. If Names (default), the gene names will be extracted, otherwise the Ensembl IDs will 
#'   be extracted.
#' @param symbol character. The symbol that separates the EnsemblID from the GeneName. Defaut is ':'.
#' @param min.pct numeric. Only test genes that are detected in a minimum fraction of min.pct cells in either 
#'   of the two populations. Meant to speed up the function by not testing genes that are very infrequently 
#'   expressed. Default is 0.1.
#' @param avg_logfc.cut numeric. The logFC cutoff to determine the differentially expressed genes. Default is 0.2. All genes above logFC = 0.05
#'   are shown in the analysis. 
#' @param test.use character. Denotes which test to use. Available options are: wilcox (identifies differentially expressed genes between two
#'   groups of cells using a Wilcoxon Rank Sum test), bimod (likelihood-ratio test for single cell gene expression), roc (identifies markers
#'   of gene expression using ROC analysis. For each gene, evaluates by AUC a classifier built on that gene alone, to classify between two groups
#'   of cells. An AUC value of 1 means that expression values for this gene alone can perfectly classify the two groupings, i.e. each of the cells in
#'   cells.1 exhibit a higher level than each of the cells in cells.2. An AUC value of 0 also means there is perfect classification, but in the other
#'   direction. A value of 0.5 implies that the gene has no predictive power to classify the two groups. Returns a 'predictive power' (abs(AUC-0.5) * 2)
#'   ranked matrix of putative differentially expressed genes), t (identify differentially expressed genes between two groups of cells using the Student's
#'   t-test), negbinom (identifies differentially expressed genes between two groups of cells using a negative binomial generalized linear model.  Use only
#'   for UMI-based datasets), poisson (identifies differentially expressed genes between two groups of cells using a poisson generalized linear model. Use
#'   only for UMI-based datasets), LR (uses a logistic regression framework to determine differentially expressed genes. Constructs a logistic regression
#'   model predicting group membership based on each feature individually and compares this to a null model with a likelihood ratio test), MAST (identifies
#'   differentially expressed genes between two groups of cells using a hurdle model tailored to scRNA-seq data. Utilizes the MAST package to run the
#'   DE testing) and DESeq2 (identifies differentially expressed genes between two groups of cells based on a model using DESeq2 which uses a negative binomial
#'   distribution. This test does not support pre-filtering of genes based on average difference or percent detection rate between cell groups. However,
#'   genes may be pre-filtered based on their minimum detection rate (min.pct) across both cell groups. Default is LR.
#' @param group.by character. Regroup cells into a different identity class prior to performing differential expression. Typically, it accepts a class ID from
#'   the metadata table. Default is NULL.
#' @param min.cells.group numeric. Minimum number of cells in one of the groups. Default is 3.
#' @param min.cells.feature numeric. Minimum number of cells expressing the feature in at least one of the two groups. Currently only used for poisson
#'   and negative binomial tests. Default is 3.
#' @param idents character. The colname of the @meta.data slot to serve as the Idents of the object. The levels of the Idents are the differential
#'   expression groups. Default is seurat_clusters.
#' @param mean.cut numeric. Minimum average expression that one of the groups should have to be accepted for plotting. Default is 0.3.
#' @param Pcut numeric. The adjusted p-value cutoff to detect differentially expressed genes. Default is 0.01.
#' @param plot.it logical. If TRUE, the top DE genes are plotted. Default is FALSE. The volcano plot is always generated.
#' @param volcano.type character. One of Interactive, Static or Both. Default is Both.
#' @param calculate.all logical. If TRUE (default), it will estimate the DE statistics of almost all genes (logFC > 0.05 and p-value < 1) and it
#'   will produce the volcano plots. Otherwise, the statistics of the genes with logFC > avg_logfc.cut and p-value < Pcut only will be estimated
#'   (much faster calculation). 
#' @keywords pairwiseDE
#' return A matrix with the DE analysis output.
#'
pairwiseDE<-function(obj,comparisons,comparison.id,outdir,cells=3,tx2genes,use.FC=TRUE,idents="seurat_clusters",
		     top.genes=5,factors=NULL,tx2genes.column="ENSG_nodot",what="Ensg",
		     symbol=":",min.pct=0.1,avg_logfc.cut = 0.2,test.use="LR",
		     group.by=NULL,min.cells.group=3,min.cells.feature=3,mean.cut=0.5,
		     Pcut=0.01,plot.it=FALSE,volcano.type="Both",calculate.all=TRUE){
    
   if(volcano.type!="Interactive" & volcano.type!="Static" & volcano.type!="Both"){
        stop("Please specify the volcano type. It must be one of Interactive, Static or Both.")
    }

    DefaultAssay(obj) <- "RNA"
    Idents(obj)<-obj@meta.data[,which(colnames(obj@meta.data)==idents)]

   if(!calculate.all){
        cutoffs<-c(avg_logfc.cut,Pcut)
    } else {
        cutoffs<-c(0.05,1)
    }

    index<-0
    tx2genes<-read.table(tx2genes,sep="\t",header=T)
    for(i in 1:nrow(comparisons)){
        
        g1<-length(which(as.character(obj@meta.data[,which(colnames(obj@meta.data)==idents)])==comparisons[i,1]))
        g2<-length(which(as.character(obj@meta.data[,which(colnames(obj@meta.data)==idents)])==comparisons[i,2]))
        if(g1>=cells & g1>=cells){
            index<-index+1
            print(paste("Analysing clusters ",comparisons[i,1]," vs ",comparisons[i,2],sep=""))

            if(index==1){
                 DEs_pairwise<-Seurat_DE(obj=obj,compPair=comparisons[i,],
                                         tx2genes=tx2genes,tx2genes.column=tx2genes.column,what=what,symbol=symbol,
                                         avg_logfc.cut = cutoffs[1],Pcut=cutoffs[2],outdir=outdir,factors=factors,
                                         use.FC=use.FC,plot.it=plot.it,top.genes=top.genes,min.pct=min.pct,test.use=test.use,
                                         group.by=group.by,min.cells.group=min.cells.group,min.cells.feature=min.cells.feature,
                                         mean.cut=mean.cut,idents=Idents(obj))
		 if(volcano.type=="Interactive" & calculate.all | volcano.type=="Both" & calculate.all){
		 	d<-doVolcano(de=DEs_pairwise,id=paste(paste(comparisons[i,],collapse="-"),"_",comparison.id,sep=""),
				Pcut=Pcut,avg_logfc.cut=avg_logfc.cut,top.genes=top.genes,outdir=outdir,interactive=TRUE)
		 }
                if(volcano.type=="Static" & calculate.all | volcano.type=="Both" & calculate.all){
                        d<-doVolcano(de=DEs_pairwise,id=paste(paste(comparisons[i,],collapse="-"),"_",comparison.id,sep=""),
                                Pcut=Pcut,avg_logfc.cut=avg_logfc.cut,top.genes=top.genes,outdir=outdir,interactive=FALSE)
                 }

		 
             } else {

		 a<-Seurat_DE(obj=obj,compPair=comparisons[i,],
                                                          tx2genes=tx2genes,tx2genes.column=tx2genes.column,what=what,symbol=symbol,
                                                          avg_logfc.cut = cutoffs[1],Pcut=cutoffs[2],outdir=outdir,factors=factors,
                                                          use.FC=use.FC,plot.it=plot.it,top.genes=top.genes,min.pct=min.pct,test.use=test.use,
                                                          group.by=group.by,min.cells.group=min.cells.group,min.cells.feature=min.cells.feature,
                                                          mean.cut=mean.cut,idents=Idents(obj))
		 if(volcano.type=="Interactive" & calculate.all | volcano.type=="Both" & calculate.all){
			 d<-doVolcano(de=a,id=paste(paste(comparisons[i,],collapse="-"),"_",comparison.id,sep=""),
				Pcut=Pcut,avg_logfc.cut=avg_logfc.cut,top.genes=top.genes,outdir=outdir,interactive=TRUE)
		 }
		 if(volcano.type=="Static" & calculate.all | volcano.type=="Both" & calculate.all){
                         d<-doVolcano(de=a,id=paste(paste(comparisons[i,],collapse="-"),"_",comparison.id,sep=""),
                                Pcut=Pcut,avg_logfc.cut=avg_logfc.cut,top.genes=top.genes,outdir=outdir,interactive=FALSE)
                 }

                 DEs_pairwise<-rbind(DEs_pairwise,a)
	     }

        } else {
            print(paste("The analysis is not performed because either cluster ",comparisons[i,1]," or ",comparisons[i,2]," has less than the minimum number of cells",sep=""))
        }
    
    }

  return(DEs_pairwise)
}




#' Performs DE analysis of all cluster i vs all other clusters comparisons using the LR model.
#'
#' Performs DE analysis of all cluster i vs all other clusters comparisons using the LR model and produces by default a 
#'   volcano plot.
#' @param obj object. A seurat object with the clustering information.
#' @param comparisons matrix. A matrix with the clusters being compared (in rows).
#' @param comparison.id character. A unique ID to be used in the filename of the volcano plot.
#' @param outdir character. A folder to store the plots.
#' @param cells numeric. The minimum number of cells that either cluster should have for the comparison 
#'   to be performed. Default is 3. It is useful when comparing cells from subsets.
#' @param tx2genes character. The file name with the gene annotation information.
#' @param use.FC logical. If TRUE (default), the DE estimates are sorted by logFC.
#' @param top.genes numeric. The number of genes to visualise in plots.
#' @param factors character. A list of factors whose effect is removed from the data.
#' @param tx2genes.column numeric. The column of the annotation file that matches the original rownames of the matrix.mtx (to update the
#'   rownames in the appropriate form). Default is column="ENSG_nodot" that uses the Ensembl gene IDs without the '.x' symbol at the end.
#'   Other options are ENSG_dot and GeneName depending on the dataset.
#' @param what character. If Names (default), the gene names will be extracted, otherwise the Ensembl IDs will 
#'   be extracted.
#' @param symbol character. The symbol that separates the EnsemblID from the GeneName. Defaut is ':'.
#' @param min.pct numeric. Only test genes that are detected in a minimum fraction of min.pct cells in either 
#'   of the two populations. Meant to speed up the function by not testing genes that are very infrequently 
#'   expressed. Default is 0.1.
#' @param avg_logfc.cut numeric. The logFC cutoff to determine the differentially expressed genes. Default is 0.2. All genes above logFC = 0.05
#'   are shown in the analysis. 
#' @param test.use character. Denotes which test to use. Available options are: wilcox (identifies differentially expressed genes between two
#'   groups of cells using a Wilcoxon Rank Sum test), bimod (likelihood-ratio test for single cell gene expression), roc (identifies markers
#'   of gene expression using ROC analysis. For each gene, evaluates by AUC a classifier built on that gene alone, to classify between two groups
#'   of cells. An AUC value of 1 means that expression values for this gene alone can perfectly classify the two groupings, i.e. each of the cells in
#'   cells.1 exhibit a higher level than each of the cells in cells.2. An AUC value of 0 also means there is perfect classification, but in the other
#'   direction. A value of 0.5 implies that the gene has no predictive power to classify the two groups. Returns a 'predictive power' (abs(AUC-0.5) * 2)
#'   ranked matrix of putative differentially expressed genes), t (identify differentially expressed genes between two groups of cells using the Student's
#'   t-test), negbinom (identifies differentially expressed genes between two groups of cells using a negative binomial generalized linear model.  Use only
#'   for UMI-based datasets), poisson (identifies differentially expressed genes between two groups of cells using a poisson generalized linear model. Use
#'   only for UMI-based datasets), LR (uses a logistic regression framework to determine differentially expressed genes. Constructs a logistic regression
#'   model predicting group membership based on each feature individually and compares this to a null model with a likelihood ratio test), MAST (identifies
#'   differentially expressed genes between two groups of cells using a hurdle model tailored to scRNA-seq data. Utilizes the MAST package to run the
#'   DE testing) and DESeq2 (identifies differentially expressed genes between two groups of cells based on a model using DESeq2 which uses a negative binomial
#'   distribution. This test does not support pre-filtering of genes based on average difference or percent detection rate between cell groups. However,
#'   genes may be pre-filtered based on their minimum detection rate (min.pct) across both cell groups. Default is LR.
#' @param group.by character. Regroup cells into a different identity class prior to performing differential expression. Typically, it accepts a class ID from
#'   the metadata table. Default is NULL.
#' @param min.cells.group numeric. Minimum number of cells in one of the groups. Default is 3.
#' @param min.cells.feature numeric. Minimum number of cells expressing the feature in at least one of the two groups. Currently only used for poisson
#'   and negative binomial tests. Default is 3.
#' @param idents character. The colname of the @meta.data slot to serve as the Idents of the object. The levels of the Idents are the differential
#'   expression groups. Default is seurat_clusters.
#' @param mean.cut numeric. Minimum average expression that one of the groups should have to be accepted for plotting. Default is 0.3.
#' @param Pcut numeric. The adjusted p-value cutoff to detect differential accessibility peaks. Default is 0.01.
#' @param plot.it logical. If TRUE, the top DE genes are plotted. Default is FALSE.
#' @param volcano.type character. One of Interactive, Static or Both. Default is Both.
#' @param calculate.all logical. If TRUE (default), it will estimate the DE statistics of almost all genes (logFC > 0.05 and p-value < 1) and it
#'   will produce the volcano plots. Otherwise, the statistics of the genes with logFC > avg_logfc.cut and p-value < Pcut only will be estimated
#'   (much faster calculation). 
#' @keywords onevsallDE
#' return A matrix with the DE analysis output.
#'
onevsallDE<-function(obj,comparisons,comparison.id,outdir,cells=3,tx2genes,use.FC=TRUE,idents="seurat_clusters",
                     top.genes=5,factors=NULL,tx2genes.column="ENSG_nodot",what="Ensg",
                     symbol=":",min.pct=0.1,avg_logfc.cut = 0.2,test.use="LR",
                     group.by=NULL,min.cells.group=3,min.cells.feature=3,mean.cut=0.5,
                     Pcut=0.01,plot.it=FALSE,volcano.type="Both",calculate.all=TRUE){
 
    if(volcano.type!="Interactive" & volcano.type!="Static" & volcano.type!="Both"){
	stop("Please specify the volcano type. It must be one of Interactive, Static or Both.")
    }

    DefaultAssay(obj) <- "RNA"
    Idents(obj)<-obj@meta.data[,which(colnames(obj@meta.data)==idents)]

    if(!calculate.all){
     	cutoffs<-c(avg_logfc.cut,Pcut)
    } else {
        cutoffs<-c(0.05,1)
    }

    index<-0
    tx2genes<-read.table(tx2genes,sep="\t",header=T)
    for(i in 1:length(comparisons)){
        
        g1<-length(which(as.character(obj@meta.data[,which(colnames(obj@meta.data)==idents)])==comparisons[i]))
        if(g1>=cells){
            index<-index+1
            print(paste("Analysing cluster ",onevsall[i]," vs all others",sep=""))
            if(index==1){
                 DEs_onevsall<-Seurat_DE(obj=obj,compPair=comparisons[i],
                                         tx2genes=tx2genes,tx2genes.column=tx2genes.column,what=what,symbol=symbol,
                                         avg_logfc.cut = cutoffs[1],Pcut=cutoffs[2],outdir=outdir,factors=factors,
                                         use.FC=use.FC,plot.it=plot.it,top.genes=top.genes,min.pct=min.pct,test.use=test.use,
                                         group.by=group.by,min.cells.group=min.cells.group,min.cells.feature=min.cells.feature,
                                         mean.cut=mean.cut,idents=Idents(obj))
		 if(volcano.type=="Interactive" & calculate.all | volcano.type=="Both" & calculate.all){		 
		 	d<-doVolcano(de=DEs_onevsall,id=paste(paste(c(comparisons[i],"AllOther"),collapse="-"),"_",comparison.id,sep=""),
			      Pcut=Pcut,avg_logfc.cut=avg_logfc.cut,top.genes=top.genes,outdir=outdir,interactive=TRUE)
		 }
                if(volcano.type=="Static" & calculate.all | volcano.type=="Both" & calculate.all){
                        d<-doVolcano(de=DEs_onevsall,id=paste(paste(c(comparisons[i],"AllOther"),collapse="-"),"_",comparison.id,sep=""),
                              Pcut=Pcut,avg_logfc.cut=avg_logfc.cut,top.genes=top.genes,outdir=outdir,interactive=FALSE)
                 }
		             

	     } else {

		 a<-Seurat_DE(obj=obj,compPair=comparisons[i],
                                                          tx2genes=tx2genes,tx2genes.column=tx2genes.column,what=what,symbol=symbol,
                                                          avg_logfc.cut = cutoffs[1],Pcut=cutoffs[2],outdir=plotsOutput,factors=factors,
                                                          use.FC=use.FC,plot.it=plot.it,top.genes=top.genes,min.pct=min.pct,test.use=test.use,
                                                          group.by=group.by,min.cells.group=min.cells.group,min.cells.feature=min.cells.feature,
                 					   mean.cut=mean.cut,idents=Idents(obj))
		 if(volcano.type=="Interactive" & calculate.all | volcano.type=="Both" & calculate.all){
                 	d<-doVolcano(de=a,id=paste(paste(c(comparisons[i],"AllOther"),collapse="-"),"_",comparison.id,sep=""),
				Pcut=Pcut,avg_logfc.cut=avg_logfc.cut,top.genes=top.genes,outdir=outdir,interactive=TRUE)
		 }
                 if(volcano.type=="Static" & calculate.all | volcano.type=="Both" & calculate.all){
                        d<-doVolcano(de=a,id=paste(paste(c(comparisons[i],"AllOther"),collapse="-"),"_",comparison.id,sep=""),
                                Pcut=Pcut,avg_logfc.cut=avg_logfc.cut,top.genes=top.genes,outdir=outdir,interactive=FALSE)
                 }

		 DEs_onevsall<-rbind(DEs_onevsall,a)
             }

        } else {
            print(paste("The analysis is not performed because cluster ",comparisons[i]," has less than the minimum number of cells",sep=""))
        }
    
    }

  return(DEs_onevsall)
}





#' Adds the FC information from the FoldChange() function to the DE results.
#'
#' Adds the FC information from the FoldChange() function to the DE results.
#' @param DEs data frame. The DE output.
#' @param fc data frame. The FoldChange() output,
#' @param pair character. The pair (comparison) of interest.
#' @keywords addFC2DE
#' @return An updated DE output with the fold change information.
#'
addFC2DE<-function(DEs,fc,pair){

    ii<-intersect(rownames(DEs),rownames(fc))
    DEs<-DEs[match(ii,rownames(DEs),nomatch=0),]
    fc<-fc[match(ii,rownames(fc),nomatch=0),]
    gr<-t(matrix(unlist(strsplit(colnames(fc)[1:(ncol(fc)-3)],"mean_")),nrow=2))[,2]
    gr1<-which(as.character(pair[[1]])==gr)
    if(!is.null(pair[[2]])){
        gr2<-which(as.character(pair[[2]])==gr)
    } else {
        gr2<-which(gr=="all_other")
    }

    if(gr2<gr1){
        fc[,(ncol(fc)-1)]<- -as.numeric(as.character(fc[,(ncol(fc)-1)]))
    }

    DEs<-cbind(DEs,fc[,c(gr1,gr2,(ncol(fc)-1))])

  return(DEs)
}



#' Generates the input data of the top DE genes for plotting.
#'
#' Generates the input data of the top DE genes for plotting.
#' @param DEs data frame. The DE output.
#' @param pair character. The pair (comparison) of interest.
#' @param mean.columns numeric. The column number with the average expression information.
#' @param mean.cut numeric. A cutoff for the average expression. For a gene to be DE it must have higher than it
#'   average expression in at least one of the two conditions.
#' @keywords makePlotInput
#' @return A data frame with the data to plot.
#'
makePlotInput<-function(DEs,pair,mean.columns,mean.cut){

    if(pair[[2]]!="AllOther"){
         to_plot<-DEs[as.numeric(as.character(DEs[,mean.columns[1]]))>=mean.cut |
                                as.numeric(as.character(DEs[,mean.columns[2]]))>=mean.cut,]
     } else {
         to_plot<-DEs[as.numeric(as.character(DEs[,mean.columns[1]]))>=mean.cut,]
     }

  return(to_plot)
}



#' Generates the plots of the top DE genes.
#'
#' Generates the Violin and UMAP plots of the top DE genes.
#' @param obj object. A seurat object whose data are to be plotted.
#' @param compPair character. The pair (comparison) of interest.
#' @param to_plot data frame. The part of the obj data to be plotted. Typically, the output of the makePlotInput()
#'   function.
#' @keywords DEplots
#' @return A set of plots.
#'  
DEplots<-function(obj,compPair,to_plot,feature){

    p1<-VlnPlot(object = obj,features = rownames(to_plot)[feature],pt.size = 0.1,idents = compPair) +
        ggtitle(paste(rownames(to_plot)[feature]," (",as.character(to_plot[feature,11]),")",sep=""))

    p2<-FeaturePlot(object = obj,features = rownames(to_plot)[feature],pt.size = 0.1) +
        ggtitle(paste(rownames(to_plot)[feature]," (",as.character(to_plot[feature,11]),")",sep=""))
    
    p<-list(p1,p2)

  return(p)
}



#' Performs DE analysis of between two clusters or between cluster i vs all other clusters using the LR model.
#'
#' Performs DE analysis of between two clusters or between cluster i vs all other clusters using the LR model.
#' @param obj object. A seurat object with the clustering information.
#' @param comparisons matrix. A matrix with the clusters being compared (in rows).
#' @param cells numeric. The minimum number of cells that either cluster should have for the comparison 
#'   to be performed.
#' @param tx2genes data frame. The gene annotation information.
#' @param use.FC logical. If TRUE, the DE estimates are sorted by logFC.
#' @param top.genes numeric. The number of genes to visualise in plots.
#' @param factors character. A list of factors whose effect is removed from the data.
#' @param tx2genes.column numeric. The column of the annotation file that matches the original rownames of the matrix.mtx (to update the
#'   rownames in the appropriate form). Default is column="ENSG_nodot" that uses the Ensembl gene IDs without the '.x' symbol at the end.
#'   Other options are ENSG_dot and GeneName depending on the dataset.
#' @param what character. If Names, the gene names will be extracted, otherwise the Ensembl IDs will 
#'   be extracted.
#' @param symbol character. The symbol that separates the EnsemblID from the GeneName.
#' @param min.pct numeric. Only test genes that are detected in a minimum fraction of min.pct cells in either 
#'   of the two populations. Meant to speed up the function by not testing genes that are very infrequently 
#'   expressed.
#' @param avg_logfc.cut numeric. Limit testing to genes which show, on average, at least X-fold difference (log-scale) 
#'   between the two groups of cells. Increasing logfc.threshold speeds up the function, but can miss 
#'   weaker signals.
#' @param test.use character. Denotes which test to use. Available options are: wilcox (identifies differentially expressed genes between two
#'   groups of cells using a Wilcoxon Rank Sum test), bimod (likelihood-ratio test for single cell gene expression), roc (identifies markers
#'   of gene expression using ROC analysis. For each gene, evaluates by AUC a classifier built on that gene alone, to classify between two groups
#'   of cells. An AUC value of 1 means that expression values for this gene alone can perfectly classify the two groupings, i.e. each of the cells in
#'   cells.1 exhibit a higher level than each of the cells in cells.2. An AUC value of 0 also means there is perfect classification, but in the other
#'   direction. A value of 0.5 implies that the gene has no predictive power to classify the two groups. Returns a 'predictive power' (abs(AUC-0.5) * 2)
#'   ranked matrix of putative differentially expressed genes), t (identify differentially expressed genes between two groups of cells using the Student's
#'   t-test), negbinom (identifies differentially expressed genes between two groups of cells using a negative binomial generalized linear model.  Use only
#'   for UMI-based datasets), poisson (identifies differentially expressed genes between two groups of cells using a poisson generalized linear model. Use
#'   only for UMI-based datasets), LR (uses a logistic regression framework to determine differentially expressed genes. Constructs a logistic regression
#'   model predicting group membership based on each feature individually and compares this to a null model with a likelihood ratio test), MAST (identifies
#'   differentially expressed genes between two groups of cells using a hurdle model tailored to scRNA-seq data. Utilizes the MAST package to run the
#'   DE testing) and DESeq2 (identifies differentially expressed genes between two groups of cells based on a model using DESeq2 which uses a negative binomial
#'   distribution. This test does not support pre-filtering of genes based on average difference or percent detection rate between cell groups. However,
#'   genes may be pre-filtered based on their minimum detection rate (min.pct) across both cell groups.
#' @param group.by character. Regroup cells into a different identity class prior to performing differential expression. Typically, it accepts a class ID from
#'   the metadata table.
#' @param min.cells.group numeric. Minimum number of cells in one of the groups.
#' @param min.cells.feature numeric. Minimum number of cells expressing the feature in at least one of the two groups. Currently only used for poisson
#'   and negative binomial tests.
#' @param idents factor. The differential expression groups.
#' @param mean.cut numeric. Minimum average expression that one of the groups should have to be accepted for plotting.
#' @param Pcut numeric. The adjusted p-value cutoff to detect differential accessibility peaks.
#' @param plot.it logical. If TRUE, the top DE genes are plotted.
#' @keywords onevsallDE
#' return A matrix with the DE analysis output.
#'
Seurat_DE<-function(obj,compPair,outdir,tx2genes,use.FC,top.genes,factors,tx2genes.column,what,symbol,
                     min.pct,avg_logfc.cut,test.use,group.by,min.cells.group,idents,
                     min.cells.feature,mean.cut,Pcut,plot.it){
	
    DefaultAssay(obj) <- "RNA"
    Idents(obj)<-idents
    
    tx2genes.column<-which(colnames(tx2genes)==tx2genes.column)
    if(length(tx2genes.column)==0){
        stop("The tx2genes column does not exist in the tx2gene matrix.")
    }
    
    
    pair1<-compPair[1]
    if(is.na(compPair[2])){
        pair2<-NULL
    } else {
        pair2<-compPair[2]
    }

    # estimate DA peaks
    if(!is.null(pair2)){
    	if(!is.null(factors)){
            for(i in 1:length(factors)){
            	tt<-table(Idents(obj),obj@meta.data[,which(colnames(obj@meta.data)==factors[i])])
            	tt<-tt[match(c(pair1,pair2),rownames(tt)),]
            	tt<-apply(tt,2,sum)
            	if(length(tt[tt>0])<2){
                    factors[i]<-NA
            	}	
            }
            factors<-factors[!is.na(factors)]
    	}
    }
    
    if(length(factors)>0){
        DEs <- FindMarkers(object = obj,ident.1 = pair1,ident.2 = pair2,
            min.pct = min.pct,test.use = test.use,latent.vars = factors,logfc.threshold=avg_logfc.cut,
            group.by=NULL,min.cells.group=min.cells.group,min.cells.feature=min.cells.feature)
    } else {
        DEs <- FindMarkers(object = obj,ident.1 = pair1,ident.2 = pair2,
            min.pct = min.pct,test.use = test.use,latent.vars = NULL,logfc.threshold=avg_logfc.cut,
            group.by=NULL,min.cells.group=min.cells.group,min.cells.feature=min.cells.feature)
    }
    DEs<-DEs[as.numeric(as.character(DEs$p_val_adj))<=Pcut,]

    # estimate FC and add to DEs
    #fc<-FoldChange(obj,ident.1 = pair1, ident.2 = pair2,cutoff=avg_logfc.cut)
    w1<-which(idents==pair1)
    if(!is.null(pair2)){
        w2<-which(idents==pair2)
    } else {
	w2<-c(1:ncol(obj@assays$RNA@data))[-w1]
    }
    m1<-log(apply(expm1(obj@assays$RNA@data[,w1]),1,mean)+1)
    m2<-log(apply(expm1(obj@assays$RNA@data[,w2]),1,mean)+1)
    mm<-match(rownames(DEs),names(m1))
    m1<-m1[mm]
    m2<-m2[mm]

    if(nrow(DEs)==0){

          print(paste("The analysis ",pair1," vs ",ifelse(is.null(pair2),"all_other",pair2)," returned 0 differentially expressed genes. Consider a higher Pcut and/or a smaller avg_logfc.cut parameter!",sep=""))
          result<-data.frame(matrix(0,1,28))
          colnames(result)<-c("Gene","p_val","avg_log2FC","pct.1","pct.2",
                              "p_val_adj","mean.1","mean.2","ENST_nodot",
                              "ENSG_nodot","GeneName","BioType",
                              "TF_DBD","is_TF","TF_assessment",
                              "TF_BindingMode","TF_MotifStatus","TF_Notes",
                              "TF_Comments","TF_InterproID","TF_SELEXtest",
                              "TF_PBMtest","TF_isC2H2_ZF_KRAB","Epi_Function",
                              "Epi_ComplexName","Epi_Target","Epi_SpecificTarget",
                              "Comparison")
          result<-result[-1,]

    } else {
 	
	DEs<-cbind(DEs,m1,m2)
	if(!is.null(pair2)){
	    colnames(DEs)[(ncol(DEs)-1):ncol(DEs)]<-paste("mean_",c(pair1,pair2),sep="")
	} else {
	    colnames(DEs)[(ncol(DEs)-1):ncol(DEs)]<-paste("mean_",c(pair1,"AllOther"),sep="")
	}
       
        gn<-GeneNames(rownames(DEs),what=what,symbol=symbol)
        mm<-match(gn,as.character(tx2genes[,tx2genes.column]))
	tx2<-tx2genes[mm,c(2,4:6,9:ncol(tx2genes))]
	tx2[is.na(tx2[,1]),]<-"---"
        DEs<-cbind(DEs,tx2)
        gr<-grep("mean_",colnames(DEs))
        comps<-t(matrix(unlist(strsplit(colnames(DEs)[gr],"mean_")),nrow=2))[,2]
        dire<-ifelse(as.numeric(as.character(DEs$avg_log2FC))>0,paste(comps[1],">",comps[2],sep=""),paste(comps[1],"<",comps[2],sep=""))
        DEs<-cbind(DEs,Comparison=dire)
 	
        if(use.FC){
            DEs<-DEs[sort.list(abs(as.numeric(as.character(DEs$avg_log2FC))),decreasing=T),]
        }
        
        # update the pair and compPair info
        if(is.null(pair2)){
            pair2<-"AllOther"
            ce<-1:ncol(obj)
        }
        if(pair2!="AllOther"){
            ce<-which(Idents(obj)==pair1 | Idents(obj)==pair2)
        } else {
            compPair<-sort(unique(Idents(obj)))
        }

        # make the plotting input
        to_plot<-makePlotInput(DEs=DEs,pair=list(pair1,pair2),mean.columns=gr,mean.cut=mean.cut)
        
        if(nrow(to_plot)>0){

            if(top.genes>nrow(to_plot)){

                print("The number of significant genes is less than the specified top.genes. Parameter top.genes is adjusted!")

            }

            # update top.peaks and plot
            top.genes<-min(top.genes,nrow(to_plot))
        
            if(plot.it){
                pdf(paste(outdir,"DEgenes_",pair1,"vs",pair2,".pdf",sep=""))
                    for(i in 1:top.genes){

                        p<-DEplots(obj=obj,compPair=compPair,to_plot=to_plot,feature=i,ce=ce)
                        print(p[[1]])
                        print(p[[2]])
                        
                    }
                    top <- to_plot %>% group_by(Comparison) %>% top_n(n = top.genes, wt = avg_log2FC)
                    p3<- DoHeatmap(obj, features = apply(cbind(as.character(top$V4),as.character(top$V5)),1,paste,collapse=symbol),cells=ce) + ggtitle(paste("Top ",top.genes," genes by comparison",sep=""))
                    print(p3)
                dev.off()
            }

        } else {

            print(paste("The analysis ",pair1," vs ",pair2," returned differentially expressed genes but none passed the plotting criteria. Consider a smaller mean.cut value!",sep=""))

        }
        result<-cbind(Gene=as.character(rownames(DEs)),DEs)
        colnames(result)[(gr+1)]<-c("mean.1","mean.2")
    
	if(nrow(result)>0){
	    result$avg_log2FC[result$avg_log2FC=="Inf"]<-1000
            result$avg_log2FC[result$avg_log2FC=="-Inf"]<- -1000
            result$mean.1[result$mean.1=="Inf"]<-1000
            result$mean.1[result$mean.1=="-Inf"]<- -1000
            result$mean.2[result$mean.2=="Inf"]<-1000
            result$mean.2[result$mean.2=="-Inf"]<- -1000
	}
    }
    
  return(result)
}

    





#' Finds the top genes of the differential expression analysis.
#'
#' Finds the top genes of the differential expression analysis by combing the pairwise comparison and the one vs all comparison
#'   results. Briefly, it will find the genes that are upregulated in 'Cluster i vs All Others' and check all the pairwise
#'   DE anaysis for that gene. It collects the number of pairwise tests for that gene with 'Cluster i > Cluster j', 'Cluster i = Cluster j'
#'   and 'Cluster i < Cluster j' for different adjust p-value and logFC cutoff combinations. The data are summarised in a master
#'   table, enabling the user to select the top hits. Typically, the top hits should be the genes with 'Cluster i > All Others' and
#'   'Cluster i > Cluster j' for all j != i (100% success) at the strictest adjusted p-value  / logFC combination.
#' @param DEs list. A list with components the DE results of the one vs all and the pairwise comparisons. The components should be named
#'   as with the appropriate names.
#' @param total.paiwise.tests.per.i numeric. The number of pairwise comparisons performed (independent of the direction). For example, if
#'   the cells are grouped in 10 clusters, cluster i will be compared with 9 other. Thus the value of this parameter should be 9.
#' @param Pcut numeric. A series of cutoffs for the adjusted p-value criterion. Default is c(0.05,0.01,0.001).
#' @param FCcut numeric. A series of cutoffs for the logFC criterion. Default is c(0.25,0.5,1).
#' @keywords Seurat_topGenes
#' @return A matrix with the summarised differential expression stats for each gene.
#'
Seurat_topGenes<-function(DEs,total.pairwise.tests.per.i,Pcut=c(0.05,0.01,0.001),FCcut=c(0.25,0.5,1)){

   if(is.null(names(DEs))){
       stop("Parameter DEs should be named vector with pairwise and onevsall slots.")
   }
   mm<-match(names(DEs),c("pairwise","onevsall"),nomatch=0)
   if(length(mm[mm==0])>0){
       stop("Parameter DEs should be named vector with pairwise and onevsall slots.")
   }

   Pcut<-sort(Pcut)
   FCcut<-sort(FCcut,decreasing=T)
   outcome<-c("Success","Fail","NS")
   cuts<-expand.grid(outcome,FCcut,Pcut)
   colnames(cuts)<-c("Outcome","logFC","padj")
   leg<-rep(0,nrow(cuts))
   for(i in 1:nrow(cuts)){
       leg[i]<-paste(as.character(cuts[i,1]),":",colnames(cuts)[2],"=",cuts[i,2],"&",colnames(cuts)[3],"=",cuts[i,3],sep="")
   }

   DEs_onevsall<-DEs$onevsall
   DEs_pairwise<-DEs$pairwise
   uu<-unique(DEs_onevsall$Comparison)
   out<-grep("<",uu)
   uu<-uu[-out]
   result<-data.frame(matrix(0,1,ncol(DEs_onevsall)+nrow(cuts)))
   colnames(result)<-c(colnames(DEs_onevsall),leg)
   for(i in 1:length(uu)){

        # take the genes of a specific 'one vs all' comparison: e.g. 0 vs all
        genes_of_a_comparison<-DEs_onevsall[DEs_onevsall$Comparison==uu[i],]

        # find the cluster i that is compared agaist all others
        ref<-unlist(strsplit(uu[i],"[><]"))[1]

        # extract the same gene in pairwise comparisons of ref against other clusters
        for(j in 1:nrow(genes_of_a_comparison)){
            mm<-match(as.character(DEs_pairwise[,1]),as.character(genes_of_a_comparison[j,1]),nomatch=0)
            specific_gene<-DEs_pairwise[mm>0,]
            if(nrow(specific_gene)>0){
                tab<-t(matrix(unlist(strsplit(as.character(specific_gene$Comparison),"[><]")),nrow=2))
                specific_gene<-specific_gene[tab[,1]==ref | tab[,2]==ref,]

                # see the representation at different logFC and adj-P cut-offs
                out<-c()
                for(k in 1:(nrow(cuts)/3)){
                    specific_gene_filt<-specific_gene[abs(as.numeric(as.character(specific_gene$avg_logFC_adjusted)))>as.numeric(as.character(cuts[k,2])) &
                                                  as.numeric(as.character(specific_gene$p_val_adj))<as.numeric(as.character(cuts[k,3])),]
                    success<-grep(paste("^",ref,">",sep=""),specific_gene_filt$Comparison)
                    success<-100*length(c(success,grep(paste("<",ref,"$",sep=""),specific_gene_filt$Comparison)))/total.pairwise.tests.per.i
                    fail<-grep(paste("^",ref,"<",sep=""),specific_gene_filt$Comparison)
                    fail<-100*length(c(fail,grep(paste(">",ref,"$",sep=""),specific_gene_filt$Comparison)))/total.pairwise.tests.per.i
                    none<-100-(success+fail)
                    out<-c(out,c(success,fail,none))
                }
            } else {
                    out<-rep(c(0,0,100),length(leg)/3)
            }
            result<-rbind(result,c(as.matrix(genes_of_a_comparison[j,]),out))

        }
    }

  return(result[-1,])
}


#' Adjusts the format of the markers table.
#'
#' Adjusts the format of the markers table so that it is be used for subsequent ploting. It is useful when one
#'   needs to convert the 'Gene Name' into the 'Ensembl ID:Gene Name' format.
#' @param markers data frame. A data frame whose first column contains the gene names and the second column the
#'   cell type associated each marker. The respective column names must be Gene and Cell.Type, respectively.
#' @param obj.list list. A list of Seurat objects whose count data rownames shoudl contain the gene in the format
#'   'Ensembl ID:Gene Name'. The data of all object will be used to cimplete the conversion.
#' @param assay character. One of RNA (default) or SCT. RNA is typically used to plot markers. SCT is to check the 
#'   data.
#' @keywords fixMarkers
#' @return A data frame with the updated marker data.
#'  
fixMarkers<-function(markers,obj.list,assay="RNA"){
   
    if(colnames(markers)[1]!="Gene" | colnames(markers)[2]!="Cell.Type"){
	stop("Markers should be a data.frame with colnames Gene and Cell.Type")
    }
 
    if(assay=="RNA"){
    	gg<-cbind(rownames(obj.list[[1]]@assays$RNA@data),GeneNames(rownames(obj.list[[1]]@assays$RNA@data)))
    } else {
	gg<-cbind(rownames(obj.list[[1]]@assays$SCT@data),GeneNames(rownames(obj.list[[1]]@assays$SCT@data)))
    }
    if(length(obj.list)>1){
        for(i in 2:length(obj.list)){
 	    
	    if(assay=="RNA"){           
            	gg<-rbind(gg,cbind(rownames(obj.list[[i]]@assays$RNA@data),GeneNames(rownames(obj.list[[i]]@assays$RNA@data))))
            } else {
		gg<-rbind(gg,cbind(rownames(obj.list[[i]]@assays$SCT@data),GeneNames(rownames(obj.list[[i]]@assays$SCT@data))))
	    }
        }
    }
    gg<-unique(gg)
    mm<-cbind(match(as.character(markers$Gene),gg[,ncol(gg)],nomatch=0),markers$Cell.Type)
    marks<-cbind(gg[as.numeric(as.character(mm[,1])),1],mm[as.numeric(as.character(mm[,1]))>0,2])
    marks<-data.frame(marks)
    colnames(marks)<-c("Gene","Cell.Type") 

  return(marks)
}




#' Plots a set of markers
#'
#' Plots a set of markers with Seurat's FeaturePlot(), VlnPlot() and DoHeatmap() functions.
#' @param obj object. A Seurat object. Typically the output of Seurat_cellClustering() function.
#' @param markers data frame. A data frame with the marker data. If the markers are in the same format 
#'   as the gene names of the obj's the counts matrix, then the first column of the data frame must 
#'   contain the marker IDs and the second column the cell types. If the format is not the same, the 
#'   user needs to adjust it with the fixMarkers() function. In any case, the columns names of the 
#'   markers must be Gene and Cell.Type, respectively.
#' @param outdir character. A folder to store the plots.
#' @param sampleID character. An ID to be used in the plot filenames.
#' @param marker.col numeric. The column of the markers data frame that contains the marker IDs. Default 
#'   is 1.
#' @param celltype.col numeric. The column of the markers data frame that contains the marker cell types. 
#'   Default is 2.
#' @param dim.reduc.exist logical. If TRUE (default), there is a UMAP, tSNE or PCA slot in the data. Otherwise, 
#'   it will perform dimensionality reduction and clustering on the data from the beginning.
#' @param dims numeric. The PCs to be used for UMAP. Default is 1:50 (the first 50). Note that this is not
#'   the number of PCs to be used. We specify exactly which PCs will be used in order to remove the effect
#'   of a PC that explains technical or other variability.
#' @param split.by character. A factor in object metadata to split the feature plot by. If NULL (default),
#'   the split is not performed.
#' @param resolution numeric. Value of the resolution parameter, use a value above (below) 
#'   1.0 if you want to obtain a larger (smaller) number of communities. Default is 0.8. 
#' @keywords seuratMarkers
#' @return An updated Seurat object.
#'  
seuratMarkers<-function(obj,markers,outdir,sampleID,marker.col=1,celltype.col=2,dim.reduc.exist=TRUE,split.by=NULL,dims=1:50,resolution=0.8){
 
    DefaultAssay(obj)<-"RNA"

    if(colnames(markers)[1]!="Gene" | colnames(markers)[2]!="Cell.Type"){
        stop("Markers should be a data.frame with colnames Gene and Cell.Type")
    }

    if(dim.reduc.exist){
	umap<-obj@reductions$umap@cell.embeddings
    }

    obj<-NormalizeData(obj, normalization.method = "LogNormalize", scale.factor = 10000)
    obj <- ScaleData(obj)
    print("Now running Dimensionality Reduction and Clustering...")
    obj <- FindVariableFeatures(obj, selection.method = "vst", nfeatures = 2000)
    obj <- RunPCA(obj, features = VariableFeatures(object = obj))
    obj <- FindNeighbors(obj, dims = dims)
    obj <- FindClusters(obj, resolution = resolution)
    obj <- RunUMAP(obj, dims = dims)

    if(dim.reduc.exist){

	mm<-match(rownames(obj@reductions$umap@cell.embeddings),rownames(umap),nomatch=0)
	obj@reductions$umap@cell.embeddings<-umap[mm,]

    }


    mm<-match(markers[,marker.col],rownames(obj@assays$RNA@counts),nomatch=0)
    markers<-markers[mm>0,]
    p1<-p1a<-p2<-as.list(rep(0,nrow(markers)))

    for(i in 1:nrow(markers)){
        
        p1[[i]]<-FeaturePlot(obj,features=markers[i,marker.col],label=TRUE) + 
		 ggtitle(paste(markers[i,marker.col]," (",markers[i,celltype.col],")",sep=""))
	if(!is.null(split.by)){
	   p1a[[i]]<-FeaturePlot(obj,features=markers[i,marker.col],label=TRUE,split.by=split.by) +
                     ggtitle(paste(markers[i,marker.col]," (",markers[i,celltype.col],")",sep=""))
	}
        p2[[i]]<-VlnPlot(obj,features=markers[i,marker.col]) + 
		 ggtitle(paste(markers[i,marker.col]," (",markers[i,celltype.col],")",sep=""))
        
    }
    p3<-DoHeatmap(obj,features=markers[,marker.col]) + NoLegend()
    
    pdf(paste(outdir,"Seurat_markers_",sampleID,".pdf",sep=""))
        print(p1)
	if(!is.null(split.by)){
	   print(p1a)
	}
        print(p2)
        print(p3)
    dev.off()
    
    # message
    print(paste("Download plot: ",outdir,"Seurat_markers_",sampleID,".pdf",sep=""))
    
  return(obj)
}


#' Instructs Monocle to start the pseudotimes from a certain point.
#'
#' Instructs Monocle to start the pseudotimes from a certain point defined in the start parameter.
#' @param cds object. A Monocle object.
#' @param start character. The first element should be a column name of the meta.data slot and the second
#'   element the level of that factor where the pseudotimes will start counting from.
#' @keywords GM_state
#' @return Pseudotime related variables
#' 
GM_state <- function(cds,start){
  if (length(unique(pData(cds)$State)) > 1){
    T0_counts <- table(pData(cds)$State, 
			pData(cds)[,which(colnames(pData(cds))==start[1])])[,start[2]]
    return(as.numeric(names(T0_counts)[which
          (T0_counts == max(T0_counts))]))
  } else {
    return (1)
  }
}


#' Updates a Seurat object to be used in the analysis of a specific cell type.
#'
#' Updates a Seurat object to be used in the analysis of a specific cell type.
#' @param data object. A Seurat object.
#' @param id character. A label to be used inthe filename of the mclust plot (if requested).
#' @param outdir character. A folder to store the mclust plot (if requested).
#' @param seurat.umap logical. If TRUE, the UMAP is recalculated for this dataset. Default is FALSE.
#' @param dims numeric. The number of principal components for the UMAP. Default is NULL.
#' @param celltype character. A vector of cell types present in the Seurat objects. These cell types will be 
#'   used for sorting. Default is NULL (all cell types are chosen).
#' @param celtype.col numeric. The column of the data@meta.data slot that contains the cell types. Default is 
#'   NULL (all cell types are chosen).
#' @param condition character. A vector of conditions present in the Seurat objects. These conditions will be 
#'   used for sorting. Default is NULL (all conditions are chosen).
#' @param condition.col numeric. The column of the data@meta.data slot that contains the conditions. Default is 
#'   NULL (all cell conditions chosen).
#' @param clusters numeric. A vector of Seurat clusters to be used for sorting. Default is NULL (all clusters are 
#'   chosen).
#' @param clusters.col numeric. The column of the data@meta.data slot that contains the clusters. Default is NULL 
#'   (all clusters are chosen).
#' @param do.mclust logical. If TRUE (default), it will run mclust on the data of interest.
#' @param G numeric. An integer vector specifying the numbers of mixture components (clusters) for which the BIC is 
#'   to be calculated. The default is 'G=1:9'.
#' @keywords Seurat_celltypePrep
#' @return A Seurat object. 
#'
Seurat_celltypePrep<-function(data,id,outdir,seurat.umap=FALSE,dims=NULL,celltype=NULL,celltype.col=NULL,condition=NULL,condition.col=NULL,clusters=NULL,clusters.col=NULL,
			      do.mclust=TRUE,G=1:9){
 
    if(seurat.umap){
	if(is.null(dims)){
	   stop("Please specify the dims parameter.")
	}
    	data <- RunUMAP(data, reduction = "pca", dims = 1:dims)
    	data <- FindNeighbors(data, reduction = "pca", dims = 1:dims)
    }

    if(!is.null(celltype)){
    	w1<-c()
	if(is.null(celltype.col)){
	   stop("Please specify the parameter celltype.col")
	}
    	for(i in 1:length(celltype)){
           w1<-c(w1,which(data@meta.data[,celltype.col]==celltype[i]))
    	}
    } else {
	w1<-1:ncol(data)
    }

    if(!is.null(condition)){
	w2<-c()
	if(is.null(condition.col)){
           stop("Please specify the parameter condition.col")
        }
    	for(i in 1:length(condition)){
           w2<-c(w2,which(data@meta.data[,condition.col]==condition[i]))
    	}
    } else {
	w2<-1:ncol(data)
    }

    if(!is.null(clusters)){
	w3<-c()
	if(is.null(clusters.col)){
           stop("Please specify the parameter clusters.col")
        }
    	for(i in 1:length(clusters)){
           w3<-c(w3,which(data@meta.data[,clusters.col]==clusters[i]))
    	}
    } else {
	w3<-1:ncol(data)
    }

    w<-intersect(intersect(w1,w2),w3)
    x<-data[,w]

    if(do.mclust){
    	ce<-x@reductions$umap@cell.embeddings
    	cl <- Mclust(ce,G=G)$classification
	
	coln<-colnames(x@meta.data)
	wcoln<-which(coln=="Dim1.prep" | coln=="Dim2.prep" | coln=="mclust_clusters")
	if(length(wcoln)>0){
	   x@meta.data[,wcoln[1]]<-x@reductions$umap@cell.embeddings[,1]
	   x@meta.data[,wcoln[2]]<-x@reductions$umap@cell.embeddings[,2]
           x@meta.data[,wcoln[3]]<-cl
	} else {
	   x@meta.data<-cbind(x@meta.data,Dim1.prep=x@reductions$umap@cell.embeddings[,1],Dim2.prep=x@reductions$umap@cell.embeddings[,2],mclust_clusters=cl)
	}

	pdf(paste(outdir,"mclust_",id,".pdf",sep=""))
	   p<-DimPlot(object = x, group.by = "mclust_clusters",label=TRUE) + ggtitle(paste("mclust clusters for ",celltype,sep=""))
	   print(p)
	dev.off()

	# message
	print(paste("Download plot: ",outdir,"mclust_",id,".pdf",sep=""))
 
    } else {
    	x@meta.data<-cbind(x@meta.data,x@reductions$umap@cell.embeddings)
    }
   
  return(x)
}


#' Creates a Monocle object from a Seurat object.
#'
#' Creates a Monocle object from a Seurat object. It will keep only the data of interest for further processing.
#' @param data object. A Seurat object.
#' @param celltype character. A vector of cell types present in the Seurat objects. These cell types will be 
#'   used for sorting. Default is NULL (all cell types are chosen).
#' @param celtype.col numeric. The column of the data@meta.data slot that contains the cell types. Default is 
#'   NULL (all cell types are chosen).
#' @param condition character. A vector of conditions present in the Seurat objects. These conditions will be 
#'   used for sorting. Default is NULL (all conditions are chosen).
#' @param condition.col numeric. The column of the data@meta.data slot that contains the conditions. Default is 
#'   NULL (all cell conditions chosen).
#' @param clusters numeric. A vector of Seurat clusters to be used for sorting. Default is NULL (all clusters are 
#'   chosen).
#' @param clusters.col numeric. The column of the data@meta.data slot that contains the clusters. Default is NULL 
#'   (all clusters are chosen).
#' @keywords Seurat2monocle
#' @return A Monocle object. 
#'
Seurat2monocle<-function(data,celltype=NULL,celltype.col=NULL,condition=NULL,condition.col=NULL,clusters=NULL,clusters.col=NULL){
    
    if(!is.null(celltype)){
        w1<-c()
        for(i in 1:length(celltype)){
           w1<-c(w1,which(data@meta.data[,celltype.col]==celltype[i]))
        }
    } else {
        w1<-1:ncol(data)
    }

    if(!is.null(condition)){
        w2<-c()
        for(i in 1:length(condition)){
           w2<-c(w2,which(data@meta.data[,condition.col]==condition[i]))
        }
    } else {
        w2<-1:ncol(data)
    }

    if(!is.null(clusters)){
        w3<-c()
        for(i in 1:length(clusters)){
            w3<-c(w3,which(data@meta.data[,clusters.col]==clusters[i]))
	}
    } else {
        w3<-1:ncol(data)
    }

    w<-intersect(intersect(w1,w2),w3)
    x<-data[,w]

    pd <- new("AnnotatedDataFrame", data = x@meta.data)
    rr<-rownames(x@assays$RNA@counts)
    fd<-t(matrix(unlist(strsplit(rr,":",fixed=T)),nrow=2))
    fd<-data.frame(fd)
    colnames(fd)<-c("ID","gene_short_name")
    rownames(fd)<-rr
    fd <- new("AnnotatedDataFrame", data = fd)

    print("Now generating the Monocle dataset...")
    x<-newCellDataSet(x@assays$RNA@counts,
        	              phenoData = pd,
                	      featureData = fd,
                      	      lowerDetectionLimit = 0.1,
                      	      expressionFamily = negbinomial.size())
 
  return(x)
}





#' Performs the cell ordering with Monocle2.
#'
#' Performs the cell ordering with Monocle2 and produces informative plots and data.
#' @param data object. A Seurat object with annotated cells.
#' @param num.expressed.cells numeric. The number of expressed cells a gene should have in order to be retained
#'   for downstream analysis. Part of Monocle's default pipeline.
#' @param full.model character. The model specification for Monocle's differentialGeneTest() function that identifies
#'   DE genes among Monocle's clusters. Part of the dpFeature pipeline.
#' @param reduced.model character. The alternative model specification for Monocle's differentialGeneTest() function 
#'   that identifies DE genes among Monocle's clusters. Part of the dpFeature pipeline. This needs to be specified only 
#'   in multi-factorial designs, i.g. when batches are present and theur effect need to be removed.
#' @param outdir.plot character. A folder to store the generated plots.
#' @param outdir.data character. A folder to store the generated data.
#' @param reverse logical. If TRUE, it reverses the automatically estimated pseudotimes. Default is FALSE.
#' @param DEcluster.plots character. A vector of factor variables of the pData() slot of the newly generated Monocle
#'   object that will be used for highlithing Monocle's clusters. Default is as.factor(Cluster).
#' @param Pseudotime.plots character. A vector of factor variables of the pData() slot of the newly generated Monocle
#'   object that will be used for highlithing Monocle's pseudotime plot. Default is c("State","Cluster","Pseudotime").
#' @param do.clusteringDE logical. If TRUE (default), it will perform the DE analysis among Monocle's clusters as in the 
#'   dpFeature pipeline. If FALSE, it assumes that such a table is already available.
#' @param clusteringDEgenes data frame. It expects the data of the DE analysis among Monocle's clusters. Default is NULL.
#' @param num.o.genes numeric. The number of top DE genes of the clustering analysis that are to be used for cell ordering.
#'   Default is 1000.
#' @param GM.start character. A vector specifying the stating point of Monocle's pseudotimes. It must contain two elements:
#'   the first is the column name of the obj@meta.data slot or Monocle's pData() which is relevant for the sorting and the 
#'   second is the level of the entries of that column that will be used as a starting point. For example by specifying
#'   GM.start = c("Condition","Control"), it will find the cells of the Control condition and attempt to start the pseudotimes
#'   from there. Default is NULL.
#' @param pcex numeric. The size of the dots in the various plots. Default is 1. 
#' @keywords runMonocleOrdering
#' @return A monocle object with all information of the cell ordering.
#'
runMonocleOrdering<-function(data,id,num.expressed.cells,full.model,reduced.model,outdir.plot,outdir.data,reverse=FALSE,
                         DEcluster.plots="as.factor(Cluster)",Pseudotime.plots=c("State","Cluster","Pseudotime"),
                         do.clusteringDE=TRUE,clusteringDEgenes=NULL,num.o.genes=1000,GM.start=NULL,pcex=1){

    x <- estimateSizeFactors(data)
    x <- estimateDispersions(x)
    x <- detectGenes(x, min_expr = 0.1)
    expressed_genes <-  row.names(subset(fData(x),num_cells_expressed >= num.expressed.cells))
    fData(x)$use_for_ordering <- fData(x)$num_cells_expressed > 0.05 * ncol(x)
    x <- reduceDimension(x,
                         max_components = 2,
                         norm_method = 'log',
                         num_dim = 3,
                         reduction_method = 'tSNE',
                         verbose = T)
    #x <- clusterCells(x, verbose = F)
    #pdf(paste(outdir.plot,"Monocle_Clusters_",id,".pdf",sep=""))
     #   for(i in 1:length(DEcluster.plots)){
      #      p<-plot_cell_clusters(x, color_by = DEcluster.plots[i],cell_size = pcex)
       #     print(p)
       # }
    #dev.off()

    # message
   #print(paste("Download plot: ",paste(outdir.plot,"Monocle_Clusters_",id,".pdf",sep="")))


    if(do.clusteringDE){

        print("Now estimating the DE genes among the estimated clusters...")
        clustering_DEG_genes <-differentialGeneTest(x[expressed_genes,],
                                                    fullModelFormulaStr = full.model,
                                                    reducedModelFormulaStr = reduced.model,cores = 1)
        write.table(clustering_DEG_genes,paste(outdir.data,"Monocle_clusteringDEgenes_",id,".txt",sep=""),sep="\t")

        # message
        print(paste("Download data: ",paste(outdir.data,"Monocle_clusteringDEgenes_",id,".txt",sep="")))

    } else {

        if(!is.null(clusteringDEgenes)){
            clustering_DEG_genes<-clusteringDEgenes
        } else {
            stop("Provide the clusteringDEgenes table or set do.clusteringDE = TRUE")
        }

    }

    print("Now performing the cell ordering...")
    ordering_genes <-row.names(clustering_DEG_genes)[order(clustering_DEG_genes$qval)][1:num.o.genes]
    x <-setOrderingFilter(x,ordering_genes = ordering_genes)
    x <-reduceDimension(x, method = 'DDRTree')
    if(is.null(GM.start)){
        x <-orderCells(x,reverse=reverse)
    } else {
        x <-orderCells(x)
        x <-orderCells(x,root_state = GM_state(x,GM.start))
    }

    pdf(paste(outdir.plot,"Monocle_Pseudo_",id,".pdf",sep=""))
        for(i in 1:length(Pseudotime.plots)){
            p<-plot_cell_trajectory(x, color_by = Pseudotime.plots[i],cell_size = pcex)
            print(p)
        }
    dev.off()

    # message
    print(paste("Download plot: ",paste(outdir.plot,"Monocle_Pseudo_",id,".pdf",sep="")))

    dims<-t(x@reducedDimS)
    colnames(dims)<-paste("Monocle_Dim",1:2,sep="")
    pData(x)<-cbind(pData(x),dims)
    
 return(x)

}
   





#' Estimates the cell velocities with velocyto.R.
#'
#' Estimates the cell velocities with velocyto.R.
#' @param obj object. A Seurat object.
#' @param loom list. A list of loom files from velocyto 10x. The component names are required. They should match
#'   (part of) the rownames of meta.data slot in order for the algorithm to extract the meta data information.
#' @param id character. A label to be used in the filenames of the stored the data and plots.
#' @param outdir character. A folder to store the plots.
#' @param separator character. A separator of the pData(obj) rownames. Default is "_".
#' @param cluster.by character. A column name of the pData(object). The levels of this factor defines the colors of
#'   the velocyto plots. Default is seurat_clusters.
#' @param arrow.scale numeric. Modifies the size of velocyto's arrows. Default is 3.
#' @param cell.alpha numeric. Modifies the size of velocyto's arrows. Default is 0.8.
#' @param cell.cex numeric. The size of the dots in velocyto's plot. Default is 1.
#' @param nap, ngrid numeric. Various parameters of velocyto's plot.
#' @param velocity.by.distance logical. If TRUE (default), it will estimate the relatve velocities using the cell distances
#'   from monocle's dimensionality reduction data.
#' @param kCells numeric. It estimates the relatve velocities using the predined number of neighboring cells. Default is 20.
#' @keywords veloEst
#' @return A Seurat object and the velocity plots.
#' 
veloEst<-function(obj,loom,id,outdir,separator="_",cluster.by="seurat_clusters",
	      rd.columns=c("UMAP_1","UMAP_2"),
              arrow.scale=3,cell.alpha=0.8,cell.cex=1,npar=100,ngrid_par=c(75,50,25),
              velocity.by.distance=TRUE,kCells=20){

    if(is.null(names(loom))){
        stop("The loom variable must be a named list. The names will be used to extract the appropriate pData() information.")
    }
    libraryIDs<-names(loom)
    
    design<-obj@meta.data
    desi<-as.list(rep(0,length(libraryIDs)))
    for(i in 1:length(desi)){
        desi[[i]]<-design[grep(libraryIDs[i],rownames(design)),]
        ll<-length(unlist(strsplit(as.character(rownames(desi[[i]]))[1],separator)))
        rr<-t(matrix(unlist(strsplit(rownames(desi[[i]]),"_")),nrow=ll))
        rownames(desi[[i]])<-rr[,ncol(rr)]
    }
    design<-desi

    res<-all.loom<-as.list(rep(0,length(loom[[1]])))
    names(res)<-names(all.loom)<-names(loom[[1]])
    for(i in 1:length(loom)){
        for(j in 1:length(loom[[i]])){
            cc<-colnames(loom[[i]][[j]])
            cc<-t(matrix(unlist(strsplit(cc,":",fixed=T)),nrow=2))
            cc<-str_replace(cc[,2],"x","-1")
            colnames(loom[[i]][[j]])<-cc
            g<-rep(0,ncol(loom[[i]][[j]]))
            for(jj in 1:ncol(loom[[i]][[j]])){
                hit<-grep(as.character(colnames(loom[[i]][[j]])[jj]),as.character(rownames(design[[i]])))
                if(length(hit)>0){
                    g[jj]<-hit
                }
            }
            w<-which(g>0)
            loom[[i]][[j]]<-loom[[i]][[j]][,w]
        }
    }

    for(i in 1:length(loom[[1]])){
        for(j in 1:length(loom)){
            if(j==1){
                all.loom[[i]]<-loom[[j]][[i]]
            } else {
                all.loom[[i]]<-cbind(all.loom[[i]],loom[[j]][[i]])
            }
        }
    }
    design<-do.call(rbind,design)

    ww<-which(colnames(design)==cluster.by)
    if(length(ww)==0){
        stop("The cluster.by variable does not exist.")
    }
    if(length(unique(design[,ww]))>50){
        stop("The cluster.by levels are more than 50. Consider another variable.")
    }
    n<-unique(as.character(design[,ww]))
    palette <- distinctColorPalette(length(n))
    cols<-rep(palette[1],nrow(design))
    for(i in 2:length(n)){
        cols[design[,ww]==n[i]]<-palette[i]
    }
    design<-cbind(design,Colors=cols)

    emat<-all.loom$spliced
    nmat<-all.loom$unspliced
    smat<-all.loom$ambiguous

    design<-design[match(as.character(colnames(emat)),as.character(rownames(design))),]
    cell.colors<-as.character(design$Colors)
    names(cell.colors)<-rownames(design)

    pdf(paste(outdir,"Genes_per_read_",id,".pdf",sep=""))
        hist(log10(colSums(emat)),col='wheat',xlab='cell size')
    dev.off()
    
    w<-c(which(colnames(design)==rd.columns[1]),which(colnames(design)==rd.columns[2]))
    if(length(w)<2){
	stop("The rd.columns does not exist in the @meta.data slot or they are not well-defined.")
    }
    emb<-design[,w]

    if(!velocity.by.distance){
        vel<-gene.relative.velocity.estimates(emat,nmat,deltaT=1,kCells = kCells,fit.quantile = 0.02)
    } else {
        cell.dist <- as.dist(1-armaCor(t(emb)))
        vel<-gene.relative.velocity.estimates(emat,nmat,deltaT=1,kCells = kCells,cell.dist=cell.dist,fit.quantile=0.02)
    }

    pdf(paste(outdir,"velocities_",id,".pdf",sep=""))
        index<-0
        for(i in 1:length(npar)){
            for(j in 1:length(ngrid_par)){
                index<-index+1
                res<-show.velocity.on.embedding.cor(emb=as.matrix(emb),vel=vel,n=npar[i],
                    scale='sqrt',cell.colors=ac(cell.colors,alpha=cell.alpha),cex=cell.cex,arrow.scale=arrow.scale,arrow.lwd=0.2,
                    xlim=range(as.numeric(as.character(emb[,1]))),ylim=range(as.numeric(as.character(emb[,2]))),
                    show.grid.flow=TRUE,min.grid.cell.mass=3,grid.n=ngrid_par[j],return.details=TRUE)
            }
        }
    dev.off()

    # message
    print(paste("Download plot: ",paste(outdir,"velocities_",id,".pdf",sep="")))

  return(obj)
}


#' Performs Slingshot cell ordering.
#'
#' Performs Slingshot cell ordering on a selected set of data.
#' @param data object. A seurat object. Typically the output of Seurat_celltypePrep().
#' @param id character. A label to be used inthe filename of the mclust plot (if requested).
#' @param outdir character. A folder to store the mclust plot (if requested).
#' @param rd.columns character. The column names of the @meta.data slot with the dimensionality reduction
#'   data to run the slingshot.
#' @param clusters numeric. The cluster numbers to keep for slingshot after inspecting appropriate plots.
#'   Default is NULL (all the clusters are chosen).
#' @param cluster.column character. The column name of the @meta.data slot with the clusters.
#' @param start.cluster numeric. The id of the initial cluster of slighshot pseudotimes. If NULL (default)
#'   the cluster is automatically picked.
#' @param legend.pos character. The position of the legend on the slingshot plot. Default is topright. 
#' @keywords doSlingshotOrdering
#' @return A list containing an updated Seurat object with the slingshot estimates and the respective slingshot
#'   object.
#'
doSlingshotOrdering<-function(data,id,outdir,rd.columns,clusters=NULL,cluster.column=NULL,start.cluster=NULL,legend.pos="topright"){

    w2<-c(which(colnames(data@meta.data)==rd.columns[1]),which(colnames(data@meta.data)==rd.columns[2]))
    if(length(w2)<2){
        stop("The rd.columns does not exist in the @meta.data slot or they are not well-defined.")
    }

    keep<-rep(1,nrow(data@meta.data))
    if(is.null(cluster.column)){
	stop("Please specify the cluster.column")
    }
    w1<-which(colnames(data@meta.data)==cluster.column)

    if(!is.null(clusters)){
    	keep<-match(data@meta.data[,w1],clusters,nomatch=0)
    }
    data<-data[,which(keep>0)]
    
    rd<- data@meta.data[,w2]
    cl<-data@meta.data[,w1]
    sds <- slingshot(rd, cl, start.clus = start.cluster)
    
    n <- 40
    qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
    col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))[-c(4,27)]

    aa1<-aggregate(rd[,1],list(cl),median)
    aa2<-aggregate(rd[,2],list(cl),median)
    aa<-cbind(aa1,aa2[,2])
    pdf(paste(outdir,"Slingshot_",id,".pdf",sep=""))
        plot(rd, col = col_vector[cl], pch=20, cex=0.3,xlab="Dim1",ylab="Dim2")
        lines(sds, lwd=2,col=1:length(sds@lineages))
	for(i in 1:nrow(aa)){
	    text(as.numeric(as.character(aa[i,2])),as.numeric(as.character(aa[i,3])),aa[i,1],cex=1.5)
	}
	legend(legend.pos,ins=0.05,paste("curve",1:length(sds@lineages),sep=""),col=1:length(sds@lineages),lty=1)
    dev.off()

    # message
    print(paste("Download plot: ",outdir,"Slingshot_",id,".pdf",sep=""))

    ss<-slingPseudotime(sds)
    mm<-match(rownames(ss),rownames(data@meta.data))
    data<-data[,mm]
    data@meta.data<-cbind(data@meta.data,ss)
    
return(list(SeuratObj=data,SlingObj=sds))
}

#' Performs Monocle's differential expression analysis.
#'
#' Performs Monocle's differential expression analysis using differentialGeneTest(). It works both with pseudotime
#'   and anova-based analysis. If the pseudotime analysis is based on Slingshot's estimates, the variable name
#'   that enters the model should be Slingtime. in the monocle case it is Pseudotime. 
#' @param data object. A Monocle object. Typically the output of Seurat2monocle() or runMonocleOrdering() functions.
#' @param fc.clusters character. The column name of pData(data) that contains the clusters information. It is used to
#'   estimate the logFCs of cluster i vs all others. It can be the column having the mclust clusters or the states
#'   column of Monocle.
#' @param full.model character. The model specification for Monocle's differentialGeneTest() function that identifies
#'   DE genes among clusters or across pseudotimes. 
#' @param reduced.model character. The alternative model specification for Monocle's differentialGeneTest() function
#'   that identifies DE genes among clusters. This needs to be specified only in multi-factorial designs, e.g. when batches 
#'   are present and their effect need to be removed.
#' @param tx2genes character. The file name with the gene annotation information.
#' @param tx2genes.column numeric. The column of the annotation file that matches the original rownames of the matrix.mtx (to update the
#'   rownames in the appropriate form). Default is column="ENSG_nodot" that uses the Ensembl gene IDs without the '.x' symbol at the end.
#'   Other options are ENSG_dot and GeneName depending on the dataset.
#' @param what character. If Names (default), the gene names will be extracted, otherwise the Ensembl IDs will 
#'   be extracted.
#' @param symbol character. The symbol that separates the EnsemblID from the GeneName. Defaut is ':'.
#' @param fc.cut numeric. A cutoff of differential expression. It keeps only the genes with FC >= fc.cut. The FC is estimated
#'   from the un-logged normalized data as trimmed.mean(cluster i) / trimmed.mean(all other clusters). Default is 2.
#' @param qval.cut numeric. A cutoff of differential expression. It keeps only the genes with qvalue <= qval.cut. Default
#'   is 0.05.
#' @param num.expressed.cells numeric. The number of expressed cells a gene should have in order to be retained
#'   for downstream analysis. Part of Monocle's default pipeline. It also defines the trimming of the mean calculation.
#'   We require that the trimming is num.exprs.cells / number of cells. Default is 10.
#' @param sling.curve numeric. Positive numbers indicate which Slingshot curve is to be analysed. Default is 0 assuming monocle 
#'   pseudotimes where all data are analyzed together (or the data subset has been already selection in the data parameter). 
#' @keywords monocleDE
#' @return A list with all differential expression results, the differentially expressed genes after the qvalue cutoff, the differentially 
#'   expressed genes after the qvalue and the FC cutoffs (for anova-based comparisons) and the updated Monocle object with the cells of the 
#'   lineage of interest.
#'
monocleDE<-function(data,fc.clusters,full.model,reduced.model,
		    tx2genes,tx2genes.column="ENSG_nodot",what="Names",symbol=":",
		    fc.cut=2,qval.cut=0.05,num.exprs.cells=10,sling.curve=0){
 
    sf<-is.na(pData(data)$Size_Factor[1])
    if(sf){
        print("Estimating size factors and dispersions...")
        x <- estimateSizeFactors(data)
        x <- estimateDispersions(x)
    } else {
        x<-data
    }
   
    if(sling.curve>0){

        if(length(grep("Pseudotime",full.model))>0){
            print("sling.curve > 0 implies analysis on slingshot pseudotimes but full.model indicates analysis on monocle pseudotimes.")
        }
        gg<-which(colnames(pData(x))==paste("curve",sling.curve,sep=""))
        if(length(gg)==0){
            stop("This sling.curve does not exist in the pData(data) or slingshot pseudotimes are not present.")
        }
        x<-x[,which(!is.na(pData(x)[,gg]))]
        colnames(pData(x))[gg]<-"Slingtime"
    
    }
 
    x <- detectGenes(x, min_expr = 0.1)
    expressed_genes <-  row.names(subset(fData(x),num_cells_expressed >= num.exprs.cells))

    print("Now running differential expression...")
    de.all<-differentialGeneTest(x[expressed_genes,],fullModelFormulaStr = full.model,reducedModelFormulaStr=reduced.model)
    
    tx2genes<-read.table(tx2genes,sep="\t",header=T)
    gn<-GeneNames(rownames(de.all),what=what,symbol=symbol)
    mm<-match(gn,as.character(tx2genes[,tx2genes.column]))
    tx2<-tx2genes[mm,c(2,4:6,9:ncol(tx2genes))]
    tx2[is.na(tx2[,1]),]<-"---"
    de.all<-cbind(de.all,tx2)

    de.L1<-de.all[de.all$qval<=qval.cut,]

    if(nrow(de.L1)>0){
    	de.L1<-de.L1[sort.list(de.L1$qval),]
    
    	cl<-which(colnames(pData(x))==fc.clusters)
    	if(length(cl)==0){
           stop("The fc.clusters column does not exist in the pData(data) slot.")
    	}
    	tr<-nrow(pData(x))
    	tr<-num.exprs.cells/tr
    
    	uu<-sort(unique(pData(x)[,cl]))
    	norm<-t(t(exprs(x)) /  pData(x)[, 'Size_Factor'])
    	norm<-norm[match(rownames(de.L1),rownames(norm)),]
    	fcs<-matrix(0,nrow(norm),length(uu))
        
    	print("Now calculating the fold changes...")
    	for(i in 1:nrow(norm)){
           a<-aggregate(as.numeric(as.character(norm[i,])),list(pData(x)[,cl]),mean,trim=tr)
           for(j in 1:nrow(a)){
	   	me<-mean(norm[i,which(pData(x)[,cl]!=a[j,1])],trim=tr)
	    	if(me==0){
		   me<-1e-16
	    	}
            	fcs[i,j]<-as.numeric(as.character(a[j,2]))/me
           }
    	}
    	fcs<-data.frame(fcs)
    	colnames(fcs)<-paste("FC_",a[,1],":AllOther",sep="")
    	rownames(fcs)<-rownames(norm)
    	de.L1<-cbind(de.L1,fcs)
 
    	ww<-apply(fcs,1,function(x) length(which(x>=fc.cut | x<=(1/fc.cut))))
   
   } else {
	de.L1<-NULL
   }


  return(list(All=de.all,DE=de.L1,topDE=de.L1[which(ww>0),],MonocleObj=x))
}


#' Generates the input data for BEAM analysis.
#'
#' Generates the input data for BEAM analysis. These data can be plugged either to the classic monocle model or
#'   the monocle based model utilizing Slingshot's estimates.
#' @param data object. A Monocle object.
#' @param curve1 numeric. The lineage number (curve) i present in the pData(data) generated by doSlingshotOrdering()
#'   and the subsequent Seurat2monocle() functions.
#' @param curve2 numeric. The lineage number (curve) j present in the pData(data) generated by doSlingshotOrdering()
#'   and the subsequent Seurat2monocle() functions.
#' @param inspection.col character. A factor of pData(data) whose levels will be associated to the curve pseudotimes.
#'   The association essentially generates a table that tells us the number of cells assigned to each branch (curve i
#'   or j) by factor level. The data corresponding to levels with adequate number of cells are to be used in the subsequent
#'   BEAM / BEAM-based analysis. This is to avoind comparing branch of hererogeneous cells, e.g. cells of Time t in branch 1
#'   and time t+1 in branch 2.
#' @param time.index character. A set of indices that sort the levels of inspection.col variable to facilitate the cell choice.
#'   Default is NULL.
#' @keywords BEAMprep
#' @return A list with components an updated Monocle object (estimated size factors and dispersions for all data) and the number
#'   of cells associated to each inspection.col factor level.
#'
BEAMprep<-function(data,curve1,curve2,inspection.col,time.index=NULL){
    
    sf<-is.na(pData(data)$Size_Factor[1])
    if(sf){
        print("Estimating size factors and dispersions...")
        x <- estimateSizeFactors(data)
        x <- estimateDispersions(x)
    } else {
        x<-data
    }
    
    if(!is.null(curve1) & is.null(curve2) | is.null(curve1) & !is.null(curve2)){
        stop("Curves specification implies using slighshot estimates that require both curves. Only one is specified here.")
    }
    
    
    if(!is.null(curve1) & !is.null(curve2)){
        
        print("Considering slingshot pseudotimes...")
        
        ggall<-grep("curve",colnames(pData(x)))
	gg<-c(which(colnames(pData(x))==paste("curve",curve1,sep="")),which(colnames(pData(x))==paste("curve",curve2,sep="")))
        ggout<-setdiff(ggall,gg)
	if(length(ggout)>0){
           pData(x)<-pData(x)[,-ggout]
           gg<-c(which(colnames(pData(x))==paste("curve",curve1,sep="")),which(colnames(pData(x))==paste("curve",curve2,sep="")))
	}

        if(length(gg)<2){
            stop("One or more of the specified curves do not exist in the pData(data) or slingshot pseudotimes are not present.")
        }
        x<-x[,which(!is.na(pData(x)[,gg[1]]) & is.na(pData(x)[,gg[2]]) |
                    is.na(pData(x)[,gg[1]]) & !is.na(pData(x)[,gg[2]]))]
        colnames(pData(x))[gg]<-paste("Slingtime",c(curve1,curve2),sep="")
 
	stats.tt<-as.list(rep(0,length(inspection.col)))
	names(stats.tt)<-inspection.col       
	for(k in 1:length(inspection.col)){
	   insp<-which(colnames(pData(x))==inspection.col[k])
	   if(length(insp)==0){
     	   	stop("This inspection.col does not exist in pData(x).")
    	   }
           t1<-table(pData(x)[,insp],is.na(pData(x)[,gg[1]]))
           t2<-table(pData(x)[,insp],is.na(pData(x)[,gg[2]]))
           ii<-intersect(rownames(t1),rownames(t2))
           tt<-cbind(t1[match(ii,rownames(t1)),which(colnames(t1)==FALSE)],t2[match(ii,rownames(t2)),which(colnames(t2)==FALSE)])
           if(!is.null(time.index)){
           	ggre<-rep(0,length(time.index))
           	for(i in 1:length(time.index)){
               	   gre<-grep(time.index[i],rownames(tt))
                   if(length(gre)>0){
                   	ggre[i]<-gre
                   } else {
			ggre[i]<-i
		   }
           	}
           	stats.tt[[k]]<-tt[ggre,]
	   	colnames(stats.tt[[k]])<-colnames(pData(x))[gg]
           } else {
	     stats.tt[[k]]<-tt
	     colnames(stats.tt[[k]])<-colnames(pData(x))[gg]
	   }
    	}
    }
    
    if(is.null(curve1) & is.null(curve2)){
        
        print("Considering monocle pseudotimes...")
        
        gg<-which(colnames(pData(x))=="State")
        if(length(gg)==0){
            stop("The State variable does not exist in pData(data). Consider running monocle's cell ordering first.")
        }

	stats.tt<-as.list(rep(0,length(inspection.col)))
	names(stats.tt)<-inspection.col
        for(k in 1:length(inspection.col)){
           insp<-which(colnames(pData(x))==inspection.col[k])
           if(length(insp)==0){
                stop("This inspection.col does not exist in pData(x).")
           }
           tt<-table(pData(x)[,insp],pData(x)$State)
           if(!is.null(time.index)){
           	ggre<-rep(0,length(time.index))
            	for(i in 1:length(time.index)){
                   gre<-grep(time.index[i],rownames(tt))
                   if(length(gre)>0){
                   	ggre[i]<-gre
                   } else {
			ggre[i]<-i
		   }
            	}
	   }
           stats.tt[[k]]<-tt[ggre,]
	   colnames(stats.tt[[k]])<-colnames(tt)
        }
    }
    
  return(list(Data=x,Stats=stats.tt))
}




#' Runs the BEAM differential expression analysis.
#'
#' Runs the BEAM differential expression analysis using the classic Monocle model or the Monocle-based model
#'   the analyzes Slingshot estimates.
#' @param data object. A Monocle object. Typically the output of BEAMprep() function.
#' @param full.model character. The model specification for Monocle's differentialGeneTest() function that identifies
#'   DE genes between branches. It must always be of the form ~sm.ns(pseudotimes,df=df)*Branch.
#' @param reduced.model character. The alternative model specification for Monocle's differentialGeneTest() function
#'   that identifies DE genes between branches. It must always be of the form ~sm.ns(pseudotimes,df=df).
#' @param tx2genes character. The file name with the gene annotation information.
#' @param tx2genes.column numeric. The column of the annotation file that matches the original rownames of the matrix.mtx (to update the
#'   rownames in the appropriate form). Default is column="ENSG_nodot" that uses the Ensembl gene IDs without the '.x' symbol at the end.
#'   Other options are ENSG_dot and GeneName depending on the dataset.
#' @param what character. If Names (default), the gene names will be extracted, otherwise the Ensembl IDs will 
#'   be extracted.
#' @param symbol character. The symbol that separates the EnsemblID from the GeneName. Defaut is ':'.
#' @param branch numeric. The branch (node) number required by Monocle's BEAM model. Default is NULL (the Slingshot
#'   data are analyzed). The algorithm always gives Branch = 0 to curve1 data of BEAMprep() and  Branch = 1 to curve2. 
#' @param type character. One of monocle or slingshot (default) that indicates the type of analysis carried out.
#' @param fc.cut numeric. A cutoff of differential expression. It keeps only the genes with FC >= fc.cut. The FC is estimated
#'   from the un-logged normalized data as trimmed.mean(branch i) / trimmed.mean(branch j). Branch i is always the data of
#'   curve1 and j of curve2 of beamPrep() function above. Default is 2.
#' @param qval.cut numeric. A cutoff of differential expression. It keeps only the genes with qvalue <= qval.cut. Default
#'   is 0.05.
#' @param num.expressed.cells numeric. The number of expressed cells a gene should have in order to be retained
#'   for downstream analysis. Part of Monocle's default pipeline. It also defines the trimming of the mean calculation.
#'   We require that the trimming is num.exprs.cells / number of cells. Default is 10.
#' @keywords monocleBEAM
#' @return A list with all differential expression results, the differentially expressed genes after the qvalue cutoff, the differentially 
#'   expressed genes after the qvalue and the FC cutoffs (for anova-based comparisons) and the updated Monocle object with the cells of the 
#'   lineages of interest.
#'
monocleBEAM<-function(data,full.model,reduced.model,
		      tx2genes,tx2genes.column="ENSG_nodot",what="Names",symbol=":",
		      type="slignshot",branch=NULL,fc.cut=2,qval.cut=0.05,num.exprs.cells=10){
        
    if(type=="monocle"){
        if(is.null(branch)){
            stop("Either the curves or the branch need to be specified for this analysis.")
        }
        
        print("Now running BEAM differential expression...")
        beam <- BEAM(lung, branch_point = branch)
    }
    
    if(type=="slingshot"){

	if(length(grep("Pseudotime",full.model))>0){
            stop("In type = slignshot the full.model should include the Slingtime variable")
        }

        branch<-rep(0,nrow(pData(data)))
        gg<-grep("Slingtime",colnames(pData(data)))
        branch[is.na(pData(data)[,gg[1]])]<-1
        slingtime<-rep(0,nrow(pData(data)))
        for(i in 1:length(slingtime)){
            slingtime[i]<-max(pData(data)[i,gg],na.rm=TRUE)
        }
        pData(data)<-cbind(pData(data),Slingtime=slingtime,Branch=branch)
	data<-data[,sort.list(pData(data)$Branch)]        
	ss<-pData(data)$Slingtime

	ss.left<-ss[pData(data)$Branch==0]
        ss.left<-ss.left-min(ss.left)
        ss.right<-ss[pData(data)$Branch==1]
        ss.right<-ss.right-min(ss.right)
        maxval<-max(c(max(ss.left),max(ss.right)))

        ss.left<-truncPseudos(ss.left,maxval=maxval)
        ss.right<-truncPseudos(ss.right,maxval=maxval)
        ss<-c(ss.left,ss.right)
        pData(data)$Slingtime<-ss

        data <- detectGenes(data, min_expr = 0.1)
        expressed_genes <-  row.names(subset(fData(data),num_cells_expressed >= num.exprs.cells))
        
        print("Now running BEAM-based differential expression...")
        all<-differentialGeneTest(data[expressed_genes,],fullModelFormulaStr = full.model,reducedModelFormulaStr=reduced.model)
    }
    
    tx2genes<-read.table(tx2genes,sep="\t",header=T)
    gn<-GeneNames(rownames(all),what=what,symbol=symbol)
    mm<-match(gn,as.character(tx2genes[,tx2genes.column]))
    tx2<-tx2genes[mm,c(2,4:6,9:ncol(tx2genes))]
    tx2[is.na(tx2[,1]),]<-"---"
    all<-cbind(all,tx2)

    beam<-all[all$qval<=qval.cut,]

    if(nrow(beam)>0){
    	beam<-beam[sort.list(beam$qval),]

    	tr<-nrow(pData(data))
    	tr<-num.exprs.cells/tr

    	norm<-t(t(exprs(data)) /  pData(data)[, 'Size_Factor'])
    	norm<-norm[match(rownames(beam),rownames(norm)),]
    	fcs<-rep(0,nrow(norm))

    	print("Now calculating the fold changes...")
    	for(i in 1:nrow(norm)){
        
           a<-aggregate(norm[i,],list(pData(data)$Branch),mean,trim=tr)
           a<-a[sort.list(a[,1]),]
           if(as.numeric(as.character(a[2,2]))==0){
           	a[2,2]<-1e-16
           }
           fcs[i]<-as.numeric(as.character(a[1,2]))/as.numeric(as.character(a[2,2]))
               
        }
    	fcs<-data.frame(matrix(fcs,ncol=1))
    	colnames(fcs)<-"FC_Curve1:Curve2"
    	rownames(fcs)<-rownames(norm)
    	beam<-cbind(beam,fcs)

    	ww<-which(fcs[,1]>=fc.cut | fcs[,1]<=(1/fc.cut))
   } else {
	beam<-NULL	
   }

  return(list(All=all,DE=beam,topDE=beam[ww,],MonocleObj=data))
}


#' Performs the heatmap clustering for the differentially expressed genes of a single lineage.
#'
#' Performs the heatmap clustering for the differentially expressed genes of a single lineage.
#' @param data object. A Monocle object. Typically the output of monocleDE() function.
#' @param id character. A character to be used in the filename of the stored heatmap.
#' @param type character. One of monocle or slingshot (default) that indicates the type of analysis 
#'   carried out. 
#' @param heat.clusters numeric. The numner of heatmap clusters. We suggest a few trials before
#'   specifying its final value.
#' @param outdir character. A folder to store the heatmap.
#' @param top.only logical. If TRUE, only the genes that pass both the qvalue and FC criteria are used.
#'   If FALSE (default), the genes that pass the qvalue criterion only are used.
#' @keywords lineageHeat
#' @return The differentially expressed genes and the clusters.
#'
lineageHeat<-function(data,id,heat.clusters,outdir,top.only=FALSE,type="slingshot"){

    if(type=="slingshot"){
    	colnames(pData(data$MonocleObj))[grep("Slingtime",colnames(pData(data$MonocleObj)))]<-"Pseudotime"
    }

    if(!top.only){
	de<-data$DE
    } else {
	de<-data$topDE
    }
    data$MonocleObj<-data$MonocleObj[match(rownames(de),rownames(data$MonocleObj)),]
    
    tt<-table(GeneNames(rownames(data$MonocleObj)))
    tt<-which(tt>1)
    if(length(tt)>0){
        out<-c()
        for(i in 1:length(tt)){
            g<-grep(paste(":",names(tt[i]),"$",sep=""),rownames(data$MonocleObj))
            d1<-exprs(data$MonocleObj[g,])
            a<-apply(d1,1,mean)
            out<-c(out,g[which.min(a)])
        }
        data$MonocleObj<-data$MonocleObj[-out,]
    }

     pdf(paste(outdir,"Heatmap_Lineage_",id,".pdf",sep=""))
     	print(plot_pseudotime_heatmap(data$MonocleObj,num_clusters = heat.clusters,return_heatmap=F))
    dev.off()


    print(paste("Generating heatmap and clusters for ",nrow(data$MonocleObj)," genes...",sep=""))
    p<-plot_pseudotime_heatmap(data$MonocleObj,num_clusters = heat.clusters,return_heatmap=T)
    dev.off()
    clus <- as.data.frame(cutree(p$tree_row, k=heat.clusters))
    colnames(clus) <- "Cluster"
    clus$Gene <- rownames(clus)
    clus<-clus[,2:1]
    
    # message
    print(paste("Download plot: ",outdir,"Heatmap_Lineage_",id,".pdf",sep=""))

    mm<-match(rownames(de),clus[,1],nomatch=0)
    de<-cbind(de[mm>0,],Cluster=as.numeric(as.character(clus[mm,2])))

  return(de)
}


#' Truncates the values of a numeric vector into a specific interval.
#'
#' Truncates the values of a numeric vector into a specific interval. Given values in
#'   [a,b], the function will truncate them into [0,maxval] where maxval is a user-defined
#'   value.
#' @param data numeric. A vector of values.
#' @param maxval numeric. The maximum of the interval. The minimum is 0 by default
#' @keywords truncPseudos
#' @return A vector of truncated values.
#'
truncPseudos<-function(data,maxval){
    
    maxval*(data-min(data,na.rm=T))/(max(data,na.rm=T)-min(data,na.rm=T))
    
}


#' Performs the heatmap clustering for the differentially expressed genes of a beam lineage.
#'
#' Performs the heatmap clustering for the differentially expressed genes of a beam lineage.
#' @param data object. A Monocle object. Typically the output of monocleBEAM() function.
#' @param id character. A character to be used in the file name of the stored heatmap.
#' @param type character. One of monocle or slingshot (default) that indicates the type of analysis
#'   carried out.
#' @param heat.clusters numeric. The number of heatmap clusters. We suggest a few trials before
#'   specifying its final value. Note that the left side of the heatmap corresponds to the
#'   Branch = 0 (curve1 data of BEAMprep()) and the right side of the heatmap corresponds to the
#'   Branch = 1 (curve2 data of BEAMprep()).
#' @param outdir character. A folder to store the heatmap.
#' @param colors.col character. The column name of the pData(data) that contains the information that will
#'   add colors to the smoothed lines of the branched analysis. The branches are separated by different point 
#'   shapes. The colors may refer to other features of the experimental design such as the experimental'
#'   conditions.
#' @param top.only logical. If TRUE, only the genes that pass both the qvalue and FC criteria are used.
#'   If FALSE (default), the genes that pass the qvalue criterion only are used.
#' @param type character. One of Slingshot (default) and Monocle specifying the type of data analyzed.
#'   Slingshor converts the Sligntime into Pseudotime in the pData(data) frame.
#' @param smoothing logical. If FALSE (default), the function generates only a heatmap plot of cells and 
#'   differentially expressed genes for the user to define the number of clusters. Once defined, the function
#'   can be re-applied with smoothing = TRUE to generate smoothing lines for each cluster / branch.
#' @param legend.pos character. The position of the legend on the smoothed clusters plot. Default is topright.  
#' @keywords beamHeat
#' @return The differentially expressed genes and the clusters. In the generated heatmaps the left side belongs to 
#'   the first category alphabetically (cross.monocleBEAM) or to the data of curve1 (monocleBEAM). 
#'
beamHeat<-function(data,id,heat.clusters,outdir,colors.col,top.only=FALSE,type="slingshot",smoothing=FALSE,legend.pos="topright"){

    if(type=="slingshot"){
        colnames(pData(data$MonocleObj))[which(colnames(pData(data$MonocleObj))=="Slingtime")]<-"Pseudotime"
    }
    
    data$MonocleObj<-data$MonocleObj[,sort.list(pData(data$MonocleObj)$Branch)]
    ss<-pData(data$MonocleObj)$Pseudotime
    
    ss.left<-ss[pData(data$MonocleObj)$Branch==0]
    ss.left<-ss.left-min(ss.left)
    ss.right<-ss[pData(data$MonocleObj)$Branch==1]
    ss.right<-ss.right-min(ss.right)
    maxval<-max(c(max(ss.left),max(ss.right)))
    
    ss.left<-truncPseudos(ss.left,maxval=maxval)
    ss.left<- -(ss.left+0.01)
    ss.right<-truncPseudos(ss.right,maxval=maxval)
    ss.right<-ss.right+0.01
    ss<-c(ss.left,ss.right)
    pData(data$MonocleObj)$Pseudotime<-ss
    
    if(!top.only){
        de<-data$DE
    } else {
        de<-data$topDE
    }
    data$MonocleObj<-data$MonocleObj[match(rownames(de),rownames(data$MonocleObj)),]

    tt<-table(GeneNames(rownames(data$MonocleObj)))
    tt<-which(tt>1)
    if(length(tt)>0){
        out<-c()
        for(i in 1:length(tt)){
	    g<-grep(paste(":",names(tt[i]),"$",sep=""),rownames(data$MonocleObj))            
	    d1<-exprs(data$MonocleObj[g,])
            a<-apply(d1,1,mean)
            out<-c(out,g[which.min(a)])
        }
        data$MonocleObj<-data$MonocleObj[-out,]
    }
    
    print(paste("Generating heatmap and clusters for ",nrow(data$MonocleObj)," genes...",sep=""))
    p<-as.list(rep(0,length(heat.clusters)))
    for(k in 1:length(p)){
    	p[[k]]<-plot_pseudotime_heatmap(data$MonocleObj,num_clusters = heat.clusters[k],return_heatmap=T)
    	ordered<-p[[k]]$tree_row[["order"]]
    	dev.off()
    }

    if(length(p)>1){
	print("The length of heat.clusters is greater than 1. Rerun the function with a single heat.clusters value.")
    	
	for(k in 1:length(p)){
	   pdf(paste(outdir,"Heatmap_Beam_",id,"_clusters",heat.clusters[k],".pdf",sep=""))
		print(p[[k]])
	   dev.off()
	}

	# message
        print(paste("Download plot: ",outdir,"Heatmap_Beam_",id,"_clusters*.pdf",sep=""))
	   
    } else {

        pdf(paste(outdir,"Heatmap_Beam_",id,".pdf",sep=""))
    	   print(p[[1]])
        dev.off()
	
	# message
    	print(paste("Download plot: ",outdir,"Heatmap_Beam_",id,".pdf",sep=""))
    }

    
    if(length(p)==1){
	p<-p[[1]]
    	clus <- as.data.frame(cutree(p$tree_row, k=heat.clusters))
    	colnames(clus) <- "Cluster"
    	clus$Gene <- rownames(clus)
    	clus<-clus[,2:1]
    	clus<-clus[ordered,]
    	data$MonocleObj<-data$MonocleObj[ordered,]    	

    	data$MonocleObj<-data$MonocleObj[,sort.list(pData(data$MonocleObj)$Pseudotime)]
    	dd<-t(t(exprs(data$MonocleObj)) /  pData(data$MonocleObj)[, 'Size_Factor'])
    	dd<-log10(dd+1)
    	dd<-t(scale(t(dd)))
    	ww<-which(colnames(pData(data$MonocleObj))=="Pseudotime" | colnames(pData(data$MonocleObj))=="Branch")
    	meta<-pData(data$MonocleObj)[,ww]
    	coli<-unique(as.character(pData(data$MonocleObj)[,which(colnames(pData(data$MonocleObj))==colors.col)]))
	cols<-rep(1,nrow(meta))
	for(j in 2:length(coli)){
	   cols[which(as.character(pData(data$MonocleObj)[,which(colnames(pData(data$MonocleObj))==colors.col)])==coli[j])]<-j
	}
	coli<-unique(cbind(as.character(pData(data$MonocleObj)[,which(colnames(pData(data$MonocleObj))==colors.col)]),cols))

    	if(smoothing){
           uu<-sort(unique(clus[,2]))
           pdf(paste(outdir,"Lines_Beam_",id,".pdf",sep=""))
        	
		
            	for(i in 1:length(uu)){
                   g<-as.character(clus[clus[,2]==uu[i],1])
                   d0<-matrix(dd[match(g,rownames(dd)),which(meta$Branch==0)],ncol=length(which(meta$Branch==0)))
                   d0<-apply(d0,2,mean,trim=0.1)
                   ps0<- -(as.numeric(as.character(meta$Pseudotime[which(meta$Branch==0)]))+0.01)
                   d0<-as.numeric(as.character(lm(as.numeric(as.character(d0))~sm.ns(ps0,df=3))$fitted.values))
                
                   d1<-matrix(dd[match(g,rownames(dd)),which(meta$Branch==1)],ncol=length(which(meta$Branch==1)))
                   d1<-apply(d1,2,mean,trim=0.1)
                   ps1<- as.numeric(as.character(meta$Pseudotime[which(meta$Branch==1)]))-0.01
                   d1<-as.numeric(as.character(lm(as.numeric(as.character(d1))~sm.ns(ps1,df=3))$fitted.values))
                
		   plot(ps0,d0,type="l",ylim=range(c(d0,d1)),
			main=paste("BEAM cluster ",uu[i],sep=""),xlab="Pseudotime (circles highlight Branch=0)",ylab="Normalised expression")
                   points(ps0,d0,pch=20,col=cols,cex=0.6)
		   lines(ps1,d1,col=1)
                   points(ps1,d1,col=cols,pch=3,cex=0.6)
                   legend(legend.pos,ins=0.05,coli[,1],col=as.numeric(coli[,2]),pch=20)
            	}
            
           dev.off()

 	   # message
    	   print(paste("Download plot: ",outdir,"Lines_Beam_",id,".pdf",sep=""))
       }
    
       mm<-match(rownames(de),clus[,1],nomatch=0)
       de<-cbind(de[mm>0,],Cluster=as.numeric(as.character(clus[mm,2])))

   } else {
	de<-NULL
   }

return(de)
}
    
    
#' Reverse the estimated pseudotimes
#'
#' Reverse the estimated pseudotimes.
#' @param data object. A Seurat object generated by the doSlingshotOrdering() or
#'   doMonocleOrdering() functions.
#' @param ps.column numeric. The column of the meta.data slot that contains the
#'   pseudotimes.
#' @keywords reversePseudotimes
#' @return An updated Seurat object in the form of the output of doSlingshotOrdering()
#'   or doMonocleOrdering() functions.
#'
reversePseudotimes<-function(data,ps.column){
    
    meta<-data$SeuratObj@meta.data
    ma<-max(as.numeric(as.character(meta[,ps.column])),na.rm=T)
    ps<- -as.numeric(as.character(meta[,ps.column]))
    for(i in 1:length(ps)){
        
        if(!is.na(ps[i])){
            ps[i]<-ps[i]+ma
        }
        
    }
    data$SeuratObj@meta.data[,ps.column]<-ps
    
  return(data)
}


#' Generates the data for the BEAM analysis across different cell types.
#'
#' Generates the data for the BEAM analysis across different cell types.
#' @param obj object. A Seurat object.
#' @param data1 object. A Seurat object with the Slingshot estimates. The data of a
#'   particular cell type.
#' @param data2 object. A Seurat object with the Slingshot estimates. The data of a
#'   different cell type.
#' @param curve1 numeric. The number of the curve to be analysed from data1.
#' @param curve2 numeric. The number of the curve to be analysed from data2.
#' @param type character. Only slingshot is supported for now.
#' @param pseudotime.correction logical. If TRUE (defualt), the pseudotimes of the two
#'   datasets are adjusted to have the same range.
#' @keywords cross.prep
#' @return A Monocle object for BEAM analysis.
#'
cross.prep<-function(obj,data1,data2,curve1,curve2,type,
                     pseudotime.correction=TRUE){
        
    if(type=="slingshot"){
        colnames(pData(data1))[which(colnames(pData(data1))==paste("curve",curve1,sep=""))]<-"Slingtime"
        gg<-grep("curve",colnames(pData(data1)))
        pData(data1)<-pData(data1)[,-gg]
        colnames(pData(data2))[which(colnames(pData(data2))==paste("curve",curve2,sep=""))]<-"Slingtime"
        gg<-grep("curve",colnames(pData(data2)))
        pData(data2)<-pData(data2)[,-gg]
        
        if(pseudotime.correction){
            ss1<-pData(data1)$Slingtime
            ss2<-pData(data2)$Slingtime
            ss1<-ss1-min(ss1,na.rm=T)
            ss2<-ss2-min(ss2,na.rm=T)
            maxval<-max(c(max(ss1,na.rm=T),max(ss2,na.rm=T)))

            ss1<-truncPseudos(ss1,maxval=maxval)
            ss2<-truncPseudos(ss2,maxval=maxval)
            pData(data1)$Slingtime<-ss1
            pData(data2)$Slingtime<-ss2
        }
    }

    ww<-c(match(rownames(pData(data1)),rownames(obj@meta.data)),match(rownames(pData(data2)),rownames(obj@meta.data)))
    x<-obj[,ww]
    meta<-rbind(pData(data1),pData(data2))
    x@meta.data<-meta

    pd <- new("AnnotatedDataFrame", data = x@meta.data)
    rr<-rownames(x@assays$RNA@counts)
    fd<-t(matrix(unlist(strsplit(rr,":",fixed=T)),nrow=2))
    fd<-data.frame(fd)
    colnames(fd)<-c("ID","gene_short_name")
    rownames(fd)<-rr
    fd <- new("AnnotatedDataFrame", data = fd)

    print("Now generating the Monocle dataset...")
    x<-newCellDataSet(x@assays$RNA@counts,
                              phenoData = pd,
                              featureData = fd,
                              lowerDetectionLimit = 0.1,
                              expressionFamily = negbinomial.size())

    sf<-is.na(pData(x)$Size_Factor[1])
    if(sf){
        print("Estimating size factors and dispersions...")
        x <- estimateSizeFactors(x)
        x <- estimateDispersions(x)
    }
    out<-which(is.na(pData(x)[which(colnames(pData(x))=="Slingtime")]))
    x<-x[,-out]
    
  return(x)
}

#' Runs the BEAM analysis for two different cell types.
#'
#' Runs the BEAM analysis for two different cell types.
#' @param data object. A Monocle object. Typically the output of cross.prep() function.
#' @param full.model character. The model specification for Monocle's differentialGeneTest() function that identifies
#'   DE genes between branches. It must always be of the form ~sm.ns(pseudotimes,df=df)*Branch.
#' @param reduced.model character. The alternative model specification for Monocle's differentialGeneTest() function
#'   that identifies DE genes between branches. It must always be of the form ~sm.ns(pseudotimes,df=df).
#' @param celltype.col numeric. The column number that holds the cell type annotation
#' @param tx2genes character. The file name with the gene annotation information.
#' @param tx2genes.column numeric. The column of the annotation file that matches the original rownames of the matrix.mtx (to update the
#'   rownames in the appropriate form). Default is column="ENSG_nodot" that uses the Ensembl gene IDs without the '.x' symbol at the end.
#'   Other options are ENSG_dot and GeneName depending on the dataset.
#' @param what character. If Names (default), the gene names will be extracted, otherwise the Ensembl IDs will
#'   be extracted.
#' @param symbol character. The symbol that separates the EnsemblID from the GeneName. Defaut is ':'.
#' @param branch numeric. The branch (node) number required by Monocle's BEAM model. Default is NULL (the Slingshot
#'   data are analyzed). The algorithm always gives Branch = 0 to curve1 data of BEAMprep() and  Branch = 1 to curve2.
#' @param type character. One of monocle or slingshot (default) that indicates the type of analysis carried out.
#' @param fc.cut numeric. A cutoff of differential expression. It keeps only the genes with FC >= fc.cut. The FC is estimated
#'   from the un-logged normalized data as trimmed.mean(branch i) / trimmed.mean(branch j). Branch i is always the data of
#'   curve1 and j of curve2 of beamPrep() function above. Default is 2.
#' @param qval.cut numeric. A cutoff of differential expression. It keeps only the genes with qvalue <= qval.cut. Default
#'   is 0.05.
#' @param num.expressed.cells numeric. The number of expressed cells a gene should have in order to be retained
#'   for downstream analysis. Part of Monocle's default pipeline. It also defines the trimming of the mean calculation.
#'   We require that the trimming is num.exprs.cells / number of cells. Default is 10.
#' @keywords monocleBEAM
#' @return A list with all differential expression results, the differentially expressed genes after the qvalue cutoff, the differentially
#'   expressed genes after the qvalue and the FC cutoffs (for anova-based comparisons) and the updated Monocle object with the cells of the
#'   lineages of interest.
#'
cross.monocleBEAM<-function(data,full.model,reduced.model,celltype.col,
                  tx2genes,tx2genes.column="ENSG_nodot",what="Names",symbol=":",
                  type="slignshot",branch=NULL,fc.cut=2,qval.cut=0.05,num.exprs.cells=10){

    if(type=="monocle"){
        if(is.null(branch)){
            stop("Either the curves or the branch need to be specified for this analysis.")
        }

        print("Now running BEAM differential expression...")
        beam <- BEAM(lung, branch_point = branch)
    }

    if(type=="slingshot"){

        if(length(grep("Pseudotime",full.model))>0){
            stop("In type = slignshot the full.model should include the Slingtime variable")
        }

        branch<-rep(0,nrow(pData(data)))
        uu<-sort(unique(pData(data)[,celltype.col]))
        branch[which(pData(data)[,celltype.col]==uu[2])]<-1
        pData(data)<-cbind(pData(data),Branch=branch)
        data<-data[,sort.list(pData(data)$Branch)]
        ss<-pData(data)$Slingtime

        ss.left<-ss[pData(data)$Branch==0]
        ss.left<-ss.left-min(ss.left)
        ss.right<-ss[pData(data)$Branch==1]
        ss.right<-ss.right-min(ss.right)
        maxval<-max(c(max(ss.left),max(ss.right)))
        ss.left<-truncPseudos(ss.left,maxval=maxval)
        ss.right<-truncPseudos(ss.right,maxval=maxval)
        ss<-c(ss.left,ss.right)
        pData(data)$Slingtime<-ss

        data <- detectGenes(data, min_expr = 0.1)
        expressed_genes <-  row.names(subset(fData(data),num_cells_expressed >= num.exprs.cells))

        print("Now running BEAM-based differential expression...")
        all<-differentialGeneTest(data[expressed_genes,],fullModelFormulaStr = full.model,reducedModelFormulaStr=reduced.model)
    }
    tx2genes<-read.table(tx2genes,sep="\t",header=T)
    gn<-GeneNames(rownames(all),what=what,symbol=symbol)
    mm<-match(gn,as.character(tx2genes[,tx2genes.column]))
    tx2<-tx2genes[mm,c(2,4:6,9:ncol(tx2genes))]
    tx2[is.na(tx2[,1]),]<-"---"
    all<-cbind(all,tx2)

    beam<-all[all$qval<=qval.cut,]

    if(nrow(beam)>0){
        beam<-beam[sort.list(beam$qval),]

        tr<-nrow(pData(data))
        tr<-num.exprs.cells/tr

        norm<-t(t(exprs(data)) /  pData(data)[, 'Size_Factor'])
        norm<-norm[match(rownames(beam),rownames(norm)),]
        fcs<-rep(0,nrow(norm))

        print("Now calculating the fold changes...")
        for(i in 1:nrow(norm)){

           a<-aggregate(norm[i,],list(pData(data)$Branch),mean,trim=tr)
           a<-a[sort.list(a[,1]),]
           if(as.numeric(as.character(a[2,2]))==0){
                a[2,2]<-1e-16
           }
           fcs[i]<-as.numeric(as.character(a[1,2]))/as.numeric(as.character(a[2,2]))

        }
        fcs<-data.frame(matrix(fcs,ncol=1))
        colnames(fcs)<-"FC_Curve1:Curve2"
        rownames(fcs)<-rownames(norm)
        beam<-cbind(beam,fcs)

        ww<-which(fcs[,1]>=fc.cut | fcs[,1]<=(1/fc.cut))
   } else {
        beam<-NULL
   }

  return(list(All=all,DE=beam,topDE=beam[ww,],MonocleObj=data))
}


#' Generates the data for GSEA analysis.
#'
#' Generates the data of a specific cell type and curve for GSEA analysis. Essentially, the function will estimate
#'   the size factors from a given Monocle object and will compute the normalized data. Then it will calculate
#'   gene-wise expression averages for a given number of conditions. The matrix of averages, along with the structured
#'   class .cls object, will serve as GSEA input data.
#' @param data object. A Monocle object.
#' @param class numeric. A vector with the IDs of a particular condition.
#' @param class.label character. A label for the cells included in class.
#' @param aveVar character. A vector of names from the pData(data) colnames slot that will be used for averaging. The first entry
#'   is the variable that is combined with the values of the class parameters to put the 1s on the .cls class object.
#' @param batchVar character. The pData(data) colname that described different batches.
#' @param curve numeric. The number of slighshot curve to be considered.
#' @param num.exprs.cells numeric. The minimum number of cells that gene i must be expressed in order to be kept in the
#'   GSEA analysis. Default is 50.
#' @param remove.batch.effect logical. Whether or not to remove batch effects. Default is TRUE.
#' @param separator character. If length(aveVar) >2, it defines how the labels will be collapsed and serve as colnames
#'   of the GSEA data matrix. Default is |.
#' @keywords GSEAprep
#' @return A list with components the expressin data matrix and the class object of GSEA.
#'
GSEAprep<-function(data,class,class.label,aveVar,batchVar,curve,num.exprs.cells=50,remove.batch.effect=TRUE,separator="|"){

    sf<-is.na(pData(data)$Size_Factor[1])
    if(sf){
       print("Estimating size factors and dispersions...")
       x <- estimateSizeFactors(data)
       x <- estimateDispersions(x)
    } else {
       x<-data
    }
    
    testcol<-which(colnames(pData(x))==aveVar[1])
    mm<-match(pData(x)[,testcol],class,nomatch=0)
    if(length(which(mm>0))==0){
        stop("The first entry of aveVar should contain the values of class.")
    }
    
    print("Data normalization and filtering...")
    norm<-t(t(exprs(x)) /  pData(x)[, 'Size_Factor'])
    ll<-apply(norm,1,function(x) length(which(x>0)))
    norm<-norm[ll>num.exprs.cells,]
    x<-x[match(rownames(norm),rownames(x)),]

    if(remove.batch.effect){
        b<-which(colnames(pData(x))==batchVar)
        if(length(b)==0){
            stop("The batchVar does not exist in the pData slot.")
        }
        print("Removing batch effects with removeBatchEffect()...")
        corr.norm<-removeBatchEffect(norm,batch=factor(pData(x)[,b]))
    } else {
        corr.norm<-norm
    }

    keep<-c()
    for(cu in 1:length(curve)){
    	keep<-c(keep,which(!is.na(pData(x)[which(colnames(pData(x))==paste("curve",curve[cu],sep=""))])))
    }
    keep<-unique(keep)
    x<-x[,keep]
    corr.norm<-corr.norm[,keep]
    
    vars<-as.list(rep(0,length(aveVar)))
    for(i in 1:length(aveVar)){
        colu<-which(colnames(pData(x))==aveVar[i])
        if(length(colu)==0){
            stop("One or more of the aveVar data does not exist in the pData slot.")
        }
        vars[[i]]<-paste(aveVar[i],pData(x)[,colu],sep=":")
    }
    vars<-matrix(do.call(cbind,vars),ncol=length(aveVar))
    aa<-apply(vars,1,paste,collapse=separator)
    mean.corr.norm<-matrix(0,nrow(corr.norm),length(unique(aa)))
    agg<-aggregate(as.numeric(as.character(corr.norm[1,])),list(aa),mean)
    agg<-agg[sort.list(agg[,1]),]
    coln<-agg[,1]
    mean.corr.norm[1,]<-agg[,2]

    for(i in 2:nrow(corr.norm)){
        agg<-aggregate(as.numeric(as.character(corr.norm[i,])),list(aa),mean)
        agg<-agg[sort.list(agg[,1]),]
        if(!identical(coln,agg[,1])){
            stop(paste("The categories of row ",i," are not consistent with the default",sep=""))
        }
        mean.corr.norm[i,]<-agg[,2]
    }
    mean.corr.norm<-data.frame(mean.corr.norm)
    rownames(mean.corr.norm)<-rownames(norm)
    colnames(mean.corr.norm)<-coln

    cl<-rep(0,ncol(mean.corr.norm))
    agg<-t(matrix(unlist(strsplit(coln,separator,fixed=TRUE)),nrow=length(aveVar)))
     for(i in 1:length(class)){
             cl[which(agg[,1]==paste(aveVar[1],":",class[i],sep=""))]<-1
     }
    sl<-sort.list(cl)
    cl<-cl[sl]
    mean.corr.norm<-mean.corr.norm[,sl]

    mat<-cbind(NAME=GeneNames(rownames(mean.corr.norm)),
               DESCRIPTION=GeneNames(rownames(mean.corr.norm),what="Ensg"),
               mean.corr.norm)

    cls<-matrix(0,3,1)
    cls[1,]<-paste(ncol(mean.corr.norm),2,1)
    cls[2,]<-paste("# Other",class.label)
    cls[3,]<-paste(as.character(cl),collapse=" ")

    result<-list(DataMat=mat,Classes=cls)

return(result)
}


#' Selects a predefined number of markers for visualisation.
#'
#' Selects a predefined number of markers for visualisation. It will go through the marker list and it will
#'   select the top variable genes from each cell type. It will process the SCT data slot.
#' @param obj list. A list of Seurat objects that hold the SCT data.
#' @param markers data frame. A data frame of markers. It must consist of two columns. The first column is the
#'   gene name and the second the cell type.
#' @param convert.name logical. If TRUE (default), the gene names of the markers' first column are converted
#'   into ENSG:GeneName in agreement with the rownames of the obj variable. If the rownames of the obj variable
#'   are only gene names or if the gene names of the markers' first column are already in the ENSG:GeneName
#'   format, then convert.name should be FALSE.
#' @param force.unique logical. If TRUE (default), it will retrieve the final unique gene IDs. If FALSE, it is
#'   possible that the IDs wont be unique because the markers might consist of entries from different datasets
#'   or the cell type names might not be consistent.
#' @param top numeric. The top variable number of markers per cell type that will be retrieved from each dataset
#'   (obj component). The final marker list consists of the unique markers in both datasets which can be larger
#'   than the top number.
#' @keywords vizMarkers
#' @return A data frame with the selected markers
#'
vizMarkers<-function(obj,markers,convert.name=TRUE,force.unique=TRUE,top=5){
    
    uu<-unique(as.character(markers[,1]))

    for(i in 1:length(uu)){
        d<-markers[which(as.character(markers[,1])==uu[i]),]
        d<-unique(d)
        d[1,2]<-paste(d[,2],collapse="|")
        if(i==1){
            marks2<-d[1,]
        } else {
            marks2<-rbind(marks2,d[1,])
        }
    }
    colnames(marks2)<-c("Gene","Cell.Type")
    
    if(force.unique){
        gg<-grep("|",as.character(marks2[,2]),fixed=T)
        if(length(gg)>0){
            marks2<-marks2[-gg,]
        }
    }
    
    if(convert.name){
        marks2<-fixMarkers(markers=marks2,obj.list=obj,assay="SCT")
    }
    
    hits<-matrix(0,1,2)
    for(i in 1:length(obj)){
        
        exprs<-obj[[i]]@assays$SCT@data
        uu<-unique(marks2[,2])
        for(j in 1:length(uu)){
            
	    mm<-match(as.character(marks2[which(as.character(marks2[,2])==uu[j]),1]),as.character(rownames(exprs)),nomatch=0)
	    mm<-mm[mm>0]
	    if(length(mm)==1){
		mm<-rep(mm,2)
            	exprs1<-exprs[mm,]
            	va<-apply(exprs1,1,var)
            	va<-va[sort.list(va,decreasing=T)]
            	hits<-rbind(hits,cbind(names(va[1:min(top,length(va))]),rep(as.character(uu[j]),min(top,length(va))))[1,])
            } else {
		exprs1<-exprs[mm,]
                va<-apply(exprs1,1,var)
                va<-va[sort.list(va,decreasing=T)]
                hits<-rbind(hits,cbind(names(va[1:min(top,length(va))]),rep(as.character(uu[j]),min(top,length(va)))))
	    }
        }
        
    }
    hits<-unique(hits[-1,])
    hits<-data.frame(hits)
    colnames(hits)<-colnames(marks2)
    hits<-hits[sort.list(hits[,2]),]
    
  return(hits)
}


#' Performs cell annotation using SCINA.
#'
#' Performs cell annotation based on canonical markers using SCINA.
#' @param obj list. A named list of Seurat components containing the cell clusters.
#' @param marks data frame. A data frame of markers. The first column should be named Gene containing the
#'   gene IDs (in the same format as the rownames of obj) and the second should be named Cell.Type containing
#'   the cell type that each marker refers to.
#' @param DE list. A named list with differential expression results from pairwiseDE() or onevsallDE() functions.
#'   The names of obj and DE lists must match! They are used to filter the markers and keep only those that are 
#'   differetially expressed for annotation purposes. If NULL (default), the original markers are considered.
#' @param logFC.cut numeric. A logFC cutoff for differenial expression. Default is 0.2.
#' @param FDR.cut numeric. An FDR cutoff for differential expression. Default is 0.05. 
#' @param DE.top numeric. The number of top differentially expressed genes per cell type to consider. The sorting
#'   is done in terms of both logFC and FDR (top hits by both criteria). Default is 10.
#' @param clusters.col character. The column name of the meta.data slot of obj that contains the clusters. Default
#'   is seurat_clusters.
#' @keywords scina.annotation
#' @return A list with two components. The first component is updated obj with meta.data containing the annotation
#'   information in three columns. The first extra column (Annotation) has the annotation of each cell. The second
#'   extra column has a summarized annotation for each cluster (Summary_Annotation). The cells of a cluster receive
#'   the annotation x with the largest frequency. The frequency in percent form is in the third extra column
#'   (Percent_Annotation). The second component is a summary of the Summary_Annotation and Percent_Annotation of the
#'   first component.
#'
scina.annotation<-function(obj,marks,DE=NULL,logFC.cut=0.2,FDR.cut=0.05,DE.top=10,clusters.col="seurat_clusters"){
    
    cc<-colnames(marks)
    if(length(intersect(c("Gene","Cell.Type"),cc))<2){
        stop("Parameter marks should be a data.frme with colnames Gene and Cell.Type.")
    }
    
    if(!is.list(obj)){
        stop("Parameter obj should be a named list.")
    }
    if(is.null(names(obj))){
        stop("Parameter obj should be a named list.")
    }
    sl<-sort.list(names(obj))
    obj<-obj[sl]
    
    if(!is.null(DE)){
        if(!is.list(DE)){
            stop("Parameter DE should be a named list.")
        }
        if(is.null(names(DE))){
            stop("Parameter DE should be a named list.")
        }
        sl<-sort.list(names(DE))
        DE<-DE[sl]
        ide<-identical(names(obj),names(DE))
        if(!ide){
            stop("The names of obj and DE must match!")
        }
    }
    
    Annot<-Annot.cells<-as.list(rep(0,length(obj)))
    names(Annot)<-names(Annot.cells)<-names(obj)
    for(k in 1:length(obj)){
    
       print(paste("Now annotating cells using ",names(Annot)[k]," data...",sep=""))
       exp<-obj[[k]]@assays$SCT@data
       uu<-unique(marks$Cell.Type)
       signatures<-as.list(rep(0,length(uu)))
       for(i in 1:length(signatures)){
           signatures[[i]]<-as.character(marks$Gene[marks$Cell.Type==uu[i]])
           if(!is.null(DE)){
	       wde<-which(abs(as.numeric(as.character(DE[[k]]$avg_log2FC)))>logFC.cut & as.numeric(as.character(DE[[k]]$p_val_adj))<FDR.cut)
	       if(length(wde)>0){
	       	   de<-DE[[k]][wde,]
		   de$p_val_adj[de$p_val_adj==0]<-min(de$p_val_adj[de$p_val_adj>0])/10
		   signatures[[i]]<-intersect(signatures[[i]],as.character(de$Gene))
		   de<-de[match(signatures[[i]],de$Gene),]
		   #idx1<-rank(as.numeric(as.character(de$avg_log2FC)))
		   #idx2<-rank(-log(as.numeric(as.character(de$p_val_adj))))
		   #idx<-apply(cbind(idx1,idx2),1,sum)
		   idx<-rank(as.numeric(as.character(de$avg_log2FC)))
		   de<-de[sort.list(idx,decreasing=T),]
                   signatures[[i]]<-as.character(de$Gene[1:min(DE.top,nrow(de))])
	       } else {
		   print(paste("There are no differentially expressed genes that satisfy these cutoffs in ",names(DE)[k],". DE filtering is disabled!",sep=""))
	       }
           }
       }
       
       s1<-unique(unlist(signatures))
       if(length(intersect(s1,rownames(exp)))<length(s1)){
           print(paste("Only ",length(intersect(s1,rownames(exp)))," out of the ",length(s1)," unique markers were found in the data",sep=""))
       }
       
       names(signatures)<-uu
       ll<-unlist(lapply(signatures,length))
       ll<-which(ll<2)
       if(length(ll)>0){
           signatures<-signatures[-ll]
       }
       results = tryCatch(
                          {
                            SCINA(exp, signatures, max_iter = 100, convergence_n = 10,
                                  convergence_rate = 0.999, sensitivity_cutoff = 0.9,
                                  rm_overlap=TRUE, allow_unknown=TRUE, log_file='SCINA.log')
                          },
                            error=function(x) {
                                                print("Setting SCINA's parameter rm_overlap = FALSE")
                                                SCINA(exp, signatures, max_iter = 100, convergence_n = 10,
                                                      convergence_rate = 0.999, sensitivity_cutoff = 0.9,
                                                      rm_overlap=FALSE, allow_unknown=TRUE, log_file='SCINA.log')
                            }
                         )
       meta<-obj[[k]]@meta.data
       ww<-which(colnames(meta)==clusters.col)
       if(length(ww)==0){
           stop("Column clusters.col does not exist in the meta.data slot of the processed obj!")
       }
       tt<-table(meta[,ww],results$cell_labels)
       lab<-as.list(rep(0,nrow(tt)))
       for(i in 1:length(lab)){
           lab[[i]]<-cbind(colnames(tt),tt[i,])
           lab[[i]]<-lab[[i]][sort.list(as.numeric(as.character(lab[[i]][,2])),decreasing=T),]
           lab[[i]][,2]<-round(100*as.numeric(as.character(lab[[i]][,2]))/sum(as.numeric(as.character(lab[[i]][,2]))),3)
       }
       names(lab)<-paste("Cluster",rownames(tt))
       lab<-lapply(lab,function(x) x[1,])
       Annot[[k]]<-cbind(names(lab),do.call(rbind,lab))
       
       cl<-as.numeric(unlist(strsplit(Annot[[k]][,1],"Cluster ",fixed=T)))
       cl<-cl[!is.na(cl)]
       mm<-match(as.numeric(as.character(meta[,ww])),as.numeric(as.character(cl)),nomatch=0)
       meta<-cbind(meta,Annotation=results$cell_labels,Summary_Annotation=Annot[[k]][mm,2],
                        Percent_Annotation=Annot[[k]][mm,3])
       obj[[k]]@meta.data<-meta
       
    }
    
  return(list(Obj=obj,Annotation=Annot,Signatures=signatures))
}


#' Generates the final cell type annotation.
#'
#' Generates the final cell type annotation using data integration.
#' @param obj list. A list of Seurat objects, annotations and signatures. Typically the output of scina.annotation() function.
#' @param sampleID character. An ID to be used in the filename of the plot.
#' @param outdir character. A folder to store the plot.
#' @param annot.col character. The name of the column with the annotation. The column is stored in the meta.data slot
#'   of the obj variable anf it has been generated by the scina.annotation() function. Default is Summary_Annotation
#'   which is a consensus annotation for each cluster. The alternative is value of this parameter is Annotation using
#'   SCINA's cell-specific annotation.
#' @param integrate logical. If TRUE (default), the data are integrated to reach a consensus (final) annotation.
#' @param perc.cut numeric. The minimum percentage of cells of cluster i having annotation x, for i to be annotated as x.
#' @param rm.unknown logical. If TRUE (defualt), cell type 'unknown' is not considered for the final annotation of cluster i
#'   unless it is the ony option that exists in cluster i.
#' @keywords consensusAnnotation
#' @return A Seurat object with the final annotations.
#'
consensusAnnotation<-function(obj,sampleID,outdir,annot.col="Summary_Annotation",integrate=TRUE,perc.cut=50,rm.unknown=TRUE){

    Obj<-obj$Obj   
    annot.col<-c(annot.col,"Percent_Annotation")
    w<-rep(0,length(annot.col))
    for(i in 1:length(annot.col)){
        w[i]<-which(colnames(Obj[[1]]@meta.data)==annot.col[i])
    }
    meta<-Obj[[1]]@meta.data[,w]
    colnames(meta)<-paste(names(Obj)[1],":",colnames(meta),sep="")
    if(length(Obj)>1){
        for(k in 2:length(Obj)){
            w<-rep(0,length(annot.col))
            for(i in 1:length(annot.col)){
                w[i]<-which(colnames(Obj[[k]]@meta.data)==annot.col[i])
            }
            meta1<-Obj[[k]]@meta.data[,w]
            df<-data.frame(matrix(NA,nrow(meta),ncol(meta1)))
            colnames(df)<-paste(names(Obj)[k],":",colnames(meta1),sep="")
            rownames(df)<-rownames(meta)
            mm<-intersect(rownames(df),rownames(meta1))
            mm<-match(mm,rownames(df))
            for(i in 1:length(mm)){
                df[mm[i],]<-meta1[i,]
            }
            meta<-cbind(meta,df)
        }
    }
    
    if(integrate){
        imeta<-meta[,1:2]
        if(annot.col[1]=="Summary_Annotation"){
            for(i in 1:nrow(meta)){
                dd<-meta[i,]
                dd<-t(matrix(dd[!is.na(dd)],nrow=2))
                top.p<-NA
                if(rm.unknown){
                    top.p<-max(as.numeric(as.character(dd[,2])))
                    dd<-matrix(dd[dd[,1]!="unknown",],ncol=2)
                }
                if(nrow(dd)>0){
                    if(as.numeric(as.character(dd[1,2]))<perc.cut){
                        w<-which.max(as.numeric(as.character(dd[,2])))
                    } else {
                        w<-1
                    }
                    imeta[i,1]<-dd[w,1]
                    imeta[i,2]<-dd[w,2]
                } else {
                    imeta[i,1]<-"unknown"
                    imeta[i,2]<-top.p
                }
            }
        } else {
            for(i in 1:nrow(meta)){
                dd<-meta[i,]
                dd<-t(matrix(dd[!is.na(dd)],nrow=2))
                crit1<-table(dd[,1])
                crit1<-names(crit1)[which(crit1==max(crit1))]
                if(rm.unknown){
                    ukn<-which(crit1=="unknown")
                    if(length(unk)>0){
                        if(length(ukn)==length(crit1)){
                            crit1<-"unkown"
                        } else {
                            crit1[-ukn]
                        }
                    }
                }
                if(length(crit1)>1){
                    a<-aggregate(as.numeric(as.character(dd[,2])),list(dd[,1]),mean)
                    crit1<-paste(a[which(as.numeric(as.character(a[,2]))==max(as.numeric(as.character(a[,2])))),1],collapse="|")
                }
                imeta[i,1]<-crit1
            }
        }
    }
    colnames(imeta)<-t(matrix(unlist(strsplit(colnames(imeta),":",fixed=T)),nrow=2))[,2]
    Obj<-Obj[[1]]
    ww<-match(c("Annotation","Summary_Annotation","Percent_Annotation"),colnames(Obj@meta.data),nomatch=0)
    Obj@meta.data<-Obj@meta.data[,-ww]
    if(annot.col[1]=="Summary_Annotation"){
        Obj@meta.data<-cbind(Obj@meta.data,imeta)
    } else {
        Obj@meta.data<-cbind(Obj@meta.data,Annotation=imeta[,1])
    }
    Obj@meta.data$Percent_Annotation<-as.numeric(as.character(Obj@meta.data$Percent_Annotation))
    
    pdf(paste(outdir,"CellAnnotation_",sampleID,".pdf",sep=""))
        Idents(Obj)<-Obj@meta.data[,which(colnames(Obj@meta.data)==annot.col[1])]
        p<-DimPlot(Obj)
        print(p)
        if(annot.col[1]=="Summary_Annotation"){
            p<-FeaturePlot(Obj,feature="Percent_Annotation")
            print(p)
        }
    dev.off()

    # message
    print(paste("Download plot: ",outdir,"CellAnnotation_",sampleID,".pdf",sep=""))
    
    obj$Obj<-Obj

  return(obj)
}
   


#' Picks the top differentially expressed genes by comparison
#'
#' Picks the top differentially expressed genes by comparison from the output of the onevsallDE()
#'   model that uses Seurat-based differential expression.
#' @param DE data frame. The output of onevsallDE() function.
#' @param comparison.col numeric. The column of the comparisons where the top markers will be
#'   selected from.
#' @param logfc.col numeric. The column of the logFC.
#' @param fdr.col numeric. The column of the FDR.
#' @param lfc.cut numeric. The logFC cutoff. Default is 1.
#' @param fdr.cut numeric. The FDR cutoff. Default is 0.05.
#' @param top numeric. The number of top differentially expressed genes to be picked. Default is 10.
#' @param direction character. The direction of the test. Default is '>'.
#' @param unique.only logical. If TRUE, only the unique dirrectional expressed by comparison are
#'   reported. Default is FALSE.
#' @keywords DEpicker
#' @return A tibble object with the results. 
#' 
DEpicker<-function(DE,comparison.col,logfc.col,fdr.col,lfc.cut=1,fdr.cut=0.05,top=10,direction=">",unique.only=FALSE){
 
    DE$top.Comparison<-DE[,comparison.col]
    DE$top.wt<-DE[,logfc.col]
    if(!is.null(direction)){   
    	DE<-DE[grep(direction,DE[,comparison.col]),]
    }
    DE<-DE[sort.list(as.numeric(as.character(DE[,logfc.col])),decreasing=TRUE),]
    if(unique.only){
	DE<-DE[as.numeric(as.character(DE[,logfc.col]))>lfc.cut & as.numeric(as.character(DE[,fdr.col]))<fdr.cut,]
	tt<-table(DE[,1])
	DE<-DE[match(names(tt[tt==1]),DE[,1]),]
    }
    uu<-unique(DE[,1])
    de<-matrix(0,1,ncol(DE))
    for(i in 1:length(uu)){
        dd<-DE[which(DE[,1]==uu[i]),]
        de<-rbind(de,as.matrix(dd[which.max(as.numeric(as.character(dd[,logfc.col]))),]))
    }
    de<-de[-1,]
    de<-de[as.numeric(as.character(de[,logfc.col]))>lfc.cut & as.numeric(as.character(de[,fdr.col]))<fdr.cut,]
    de<-as.data.frame(de)
    top <- de %>% group_by(top.Comparison) %>% top_n(n = top, wt = top.wt)

  return(top)

}

#' Generates the input data for the DoHeatmap() function.
#'
#' Generates the input data for the DoHeatmap() function.
#' @param data data frame. The scaled data from the @assays$RNA@scale.data slot of a
#'   Seurat object.
#' @param meta data frame. The data from the @meta.data slot of a Seurat object.
#' @param annot.col numeric. The annotation column of the meta object.
#' @param k.cols numeric. Defines the minimum cluster size allows by the dynamic tree cut method
#'   for cell clustering (k.cols*ncol(data)). Small numers generate may clusters.
#' @keywords heat.prep
#' @return A list with the information of the clustered data.
#'     
heat.prep<-function(data,meta,annot.col,k.cols){
    
    row.dist <- dist(data)
    
    uu<-unique(meta[,annot.col])
    newmeta<-meta[1,]
    newdata<-data[,1:2]
    for(i in 1:length(uu)){
    
    	w<-which(meta[,annot.col]==uu[i])
    	data1<-data[,w]
    	meta1<-meta[w,]
    	if(length(w)>=2){
           col.dist <- dist(t(data1))
           hc.cols<- hclust(col.dist, method = "ward.D2")
           dyn.cols<-cutreeDynamic(hc.cols, minClusterSize=k.cols*ncol(data), method="tree", deepSplit=FALSE)
           sl<-sort.list(dyn.cols)
           if(i==1){
           	newmeta<-cbind(meta1[sl,],dynClust=dyn.cols[sl])
            	newdata<-data1[,sl]
           } else {
           	newmeta<-rbind(newmeta,cbind(meta1[sl,],dynClust=dyn.cols[sl]))
            	newdata<-cbind(newdata,data1[,sl])
           }
    	} else {
           if(i==1){
           	newmeta<-cbind(meta1,dynClust=0)
            	dd<-data.frame(matrix(data1,ncol=1))
            	rownames(dd)<-names(data1)
            	colnames(dd)<-rownames(meta1)
            	newdata<-dd
           } else {
            	newmeta<-rbind(newmeta,cbind(meta1,dynClust=0))
            	dd<-data.frame(matrix(data1,ncol=1))
            	rownames(dd)<-names(data1)
            	colnames(dd)<-rownames(meta1)
            	newdata<-cbind(newdata,dd)
           }
    	}    
    }

    hc.rows<- hclust(row.dist, method = "ward.D2")
    ct<- cutree(hc.rows, k=nrow(data)/10)
    newdata<-newdata[hc.rows$order,]

  return(list(data=newdata,meta=newmeta))
}


#' Generates the input  data for the DoHeatmap() function of Seurat.
#' 
#' Generates the input  data for the DoHeatmap() function of Seurat. It calls the heat.prep()
#'   function above.
#' @param obj object. A Seurat object.
#' @param annot.col numeric. The annotation column of the meta object.
#' @param top object. A tibble object with the top differentially expressed genes to be
#'   plotted.
#' @param k.cols numeric. Defines the minimum cluster size allows by the dynamic tree cut method
#'   for cell clustering (k.cols*ncol(data)). Small numers generate may clusters. Default is 0.2.
#' @param ct.ordering character. If NULL (default), the cell types are order alphabetically and plotted
#'   accordingly in the heatmap. Otherwise, the order should be provided.
#' @keywords prepH
#' @return A list with the updated Seurat objects of all genes and the marker genes (top).
#'     
prepH<-function(obj,annot.col,top,k.cols=0.2,ct.ordering=NULL){
    
    if(is.null(ct.ordering)){
    	uu<-sort(unique(obj@meta.data[,annot.col]))
    } else {
	uu<-ct.ordering
    }
    Idents(obj)<-obj@meta.data[,annot.col]
    obj@active.ident <- factor(x = obj@active.ident, levels = uu)
    scaled<-obj@assays$RNA@scale.data
    scaled<-scaled[match(top$Gene,rownames(scaled),nomatch=0),]
    meta<-obj@meta.data[,c(1,annot.col)]
    meta<-meta[order(meta[,2],meta[,1]),]
    scaled<-scaled[,match(rownames(meta),colnames(scaled))]
    hh<-heat.prep(data=scaled,meta=meta,annot.col=2,k.cols=k.cols)
    oo<-obj[match(rownames(hh$data),rownames(obj)),match(colnames(hh$data),colnames(obj))]
    oo$dynClust<-hh$meta$dynClust
    rownames(oo@assays$RNA@data)<-GeneNames(rownames(oo@assays$RNA@data))
    rownames(oo@assays$RNA@counts)<-GeneNames(rownames(oo@assays$RNA@counts))
    rownames(oo@assays$RNA@scale.data)<-GeneNames(rownames(oo@assays$RNA@scale.data))
    oo@active.ident <- factor(x = oo@active.ident, levels = uu)
    
    mm<-match(oo@meta.data[,annot.col],oo@active.ident)
    oo<-oo[,mm]

  return(oo)
}



#' Place the contents of all .tsv files with the significant pathway genes ina single file.
#'
#' Place the contents of all .tsv files with the significant pathway genes ina single file.
#' @param folder_names character. The folder names that contain the .tsv files. The names should
#'   have a specific format: for BP analysis, they should start with 'BP_', for KEGG they should
#'   start with 'KEGG_' and for REACTOME they should start with 'REAC_'.
#' @param BP.id character. An id which is added automatically by BP GSEA at the beggining of each
#'   .tsv file. Default is 'GOBP_'.
#' @param KEGG.id character. An id which is added automatically by KEGG GSEA at the beggining of each
#'   .tsv file. Default is 'KEGG_'.
#' @param REACTOME.id character. An id which is added automatically by REACTOME GSEA at the beggining
#'   of each .tsv file. Default is 'REACTOME_'.
#' @keywords collectGSEAtsv
#' @return A matrix with the enriched genes, the pathway names and the folder in which they were located /
#'   retrieved from.
#'
collectGSEAtsv<-function(folder_names,BP.id="GOBP_",KEGG.id="KEGG_",REACTOME.id="REACTOME_"){
    
    res<-matrix(0,1,3)
    for(i in 1:length(lf)){
        lf1<-list.files(paste(fold,lf[i],sep=""),pattern=".tsv")
        if(length(grep("BP_",lf[i]))>0){
            lf1<-lf1[grep("GOBP_",lf1)]
        }
        if(length(grep("KEGG_",lf[i]))>0){
            lf1<-lf1[grep("KEGG_",lf1)]
        }
        if(length(grep("REAC_",lf[i]))>0){
            lf1<-lf1[grep("REACTOME_",lf1)]
        }
        for(j in 1:length(lf1)){
            x<-read.table(paste(fold,lf[i],"/",lf1[j],sep=""),sep="\t",header=T)
            x<-cbind(x,Term=rep(lf1[j],nrow(x)),File=rep(lf[i],nrow(x)))
            x<-as.matrix(x[x$CORE.ENRICHMENT=="Yes",c(2,(ncol(x)-1):ncol(x))])
            res<-rbind(res,x)
        }
    }
    res<-res[-1,]
    res[,2]<-t(matrix(unlist(strsplit(as.character(res[,2]),".ts",fixed=T)),nrow=2))[,1]
    colnames(res)<-c("Gene","Term","File")

  return(res)
    
}




#' Generates a refined UMAP of marker expression.
#'
#' Generates a refined UMAP of marker expression.
#' @param obj object. A Seurat object with the data to be plotted.
#' @param to.plot character. A list of genes to be plotted. Ussualy in the form EnsemblID:Name.
#' @param colors list. A list of colors to be used for each gene. It must either have the same
#'   length as to.plot or its length should be 1 in which case all to.plot genes take the same
#'   color.
#' @param plot.id character. Used as the plot's filename.
#' @param outdir character. A folder to store the plot.
#' @param width, height numeric. The width and height of the pdf plot. If NULL (default), the 
#'   default metrics are used.
#' @param day.panels logical. Whether different panels for the individual days will be added in 
#'   the plot. Currently only for Adam's analysis. Default is FALSE.
#' @param pts numeric. The dot size for the panels plots. Only applicable if day.panels =TRUE.
#'   Default is 1.
#' @keyword myUMAPplot
#' @return UMAP plots and their filenames
#'
myUMAPplot<-function(obj,to.plot,colors,plot.id,outdir,width=NULL,height=NULL,day.panels=FALSE,pts=1){
    
    if(length(colors)>1 & length(colors)!=length(to.plot)){
        stop("Either length(colors)==length(to.plot) or length(colors)==1")
    }
    
    ms<-rep(0,length(to.plot))
    for(i in 1:length(to.plot)){
           
           ms[i]<-print(paste("Download plots: ",outdir,plot.id,letters[i],".pdf",sep=""))
     	   if(is.null(width) | is.null(height)){	        
           pdf(paste(outdir,plot.id,letters[i],".pdf",sep=""))
           } else {
		pdf(paste(outdir,plot.id,letters[i],".pdf",sep=""),width=width,height=height)
	   } 
                if(length(colors)==1){
		    
        	   p1<-FeaturePlot(obj,features=GeneNames(to.plot[i]),order=TRUE)+
               	       scale_colour_gradientn(colors=colors[[1]])
		   dat<-obj@assays$RNA@scale.data[which(rownames(obj@assays$RNA@scale.data)==to.plot[i]),]
		   ww<-which.max(dat)
		   if(day.panels){
			o0<-obj[,unique(c(which(obj$Day==0),ww))]
			o1<-obj[,unique(c(which(obj$Day==1),ww))]
			o5<-obj[,unique(c(which(obj$Day==5),ww))]
			p1.0<-FeaturePlot(o0,features=GeneNames(to.plot[i]),order=TRUE,pt.size =pts)+
                       		scale_colour_gradientn(colors=colors[[1]]) + ggtitle("")
			p1.1<-FeaturePlot(o1,features=GeneNames(to.plot[i]),order=TRUE,pt.size =pts)+
                                scale_colour_gradientn(colors=colors[[1]]) + ggtitle("")
			p1.5<-FeaturePlot(o5,features=GeneNames(to.plot[i]),order=TRUE,pt.size =pts)+
                                scale_colour_gradientn(colors=colors[[1]]) + ggtitle("")
			lay <- rbind(c(1,1,1,1,1,1,1,NA,NA),
			             c(1,1,1,1,1,1,1,NA,NA),
             			     c(1,1,1,1,1,1,1,NA,NA),
             			     c(2,2,2,3,3,3,4,4,4),
             			     c(2,2,2,3,3,3,4,4,4))
			p1<-grid.arrange(p1,p1.0,p1.1,p1.5,layout_matrix = lay)
		   }
			
                    print(p1)
                } else {
                    p1<-FeaturePlot(obj,features=GeneNames(to.plot[i]),cols = colors[[i]],order=TRUE)
                    print(p1)
                }
           dev.off()

    }

    
  return(ms)
}



#' Generates a refined Violin of marker expression.
#'
#' Generates a refined Violin of marker expression.
#' @param obj object. A Seurat object with the data to be plotted.
#' @param to.plot character. A list of genes to be plotted. Ussualy in the form EnsemblID:Name.
#' @param annot.col numeric. The factor to be plotted in the x axis.
#' @param colors character. A named vector of colors to be used. The names should match the
#'   Idents(obj).
#' @param plot.id character. Used as the plot's filename.
#' @param outdir character. A folder to store the plot.
#' @param ct.ordering character. The order of the x axis of the violin plot. If NULL (default),
#'   an alphabetical order is used.
#' @keyword myVplot
#' @return Violin plots and their filenames
#'
myVplot<-function(obj,to.plot,annot.col,colors,plot.id,outdir,ct.ordering=NULL){

    if(is.null(ct.ordering)){
    	uu<-sort(unique(obj@meta.data[,annot.col]))
    } else {
        uu<-ct.ordering
    }
    Idents(obj)<-obj@meta.data[,annot.col]
    obj@active.ident <- factor(x = obj@active.ident, levels = uu)

    ms<-rep(0,length(to.plot))
    for(i in 1:length(to.plot)){

           ms[i]<-print(paste("Download plots: ",outdir,plot.id,letters[i],".pdf",sep=""))

           pdf(paste(outdir,plot.id,letters[i],".pdf",sep=""))

                    p1<-VlnPlot(obj,features=GeneNames(to.plot[i]),cols = colors) +
			theme(legend.position = "none")
                    print(p1)
                
           dev.off()

    }


  return(ms)
}



#' Generates a barplot with percentage of cases of one's feature levels per level of
#'   another feature.
#'
#' Generates a barplot with percentage of cases of one's feature levels per level of
#'   another feature (usually cell clusters).
#' @param obj object. A Seurat object with the data to be plotted.
#' @param features character. The features to be plotted. Should be in obj@meta.data.
#' @param control.feature character. The feature whose levels will appear in the x axis
#'   of the barplot.
#' @param plot.id character. Used as the plot's filename.
#' @param outdir character. A folder to store the plot.
#' @param scale character. Whether the features variabe is continuous or disrete. Must be 
#'   equal to the length of the features variable.
#' @keyword myBplot
#' @return Barplots and their filenames
#'
myBplot<-function(obj,features,control.feature,plot.id,outdir,scale){

    ms<-rep(0,length(features))
    w1<-which(colnames(obj@meta.data)==control.feature)
    
    for(i in 1:length(features)){

        tt<-table(obj@meta.data[,w1],obj@meta.data[,which(colnames(obj@meta.data)==features[i])])
        tt<-100*tt/apply(tt,1,sum)
        tt<-melt(tt)
        colnames(tt)<-c(control.feature,feaD[i],"Percentage")

        ms[i]<-print(paste("Download plots: ",outdir,plot.id,letters[i],".pdf",sep=""))

        pdf(paste(outdir,plot.id,letters[i],".pdf",sep=""))

            p1<-ggplot(tt,aes(x=tt[,1],y=Percentage,fill=tt[,2])) + geom_bar(stat="identity") + theme_minimal() +
                	scale_fill_discrete(name = feaD[i]) + scale_x_discrete(labels=as.character(tt[,1]),breaks=tt[,1]) +
                	labs(x=control.feature)+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
            print(p1)

        dev.off()

    }


  return(ms)
}


#' Fisher test for cell type validation.
#'
#' Fisher test for cell type validation. It takes the frequency matrix of
#'   two annotations and calculates the fisher test showing whether the two
#'   annotations agree (p.value of fisher.test < 0.05)
#' @param tabl data frame. The frequency table of the two annotations. The rows
#'   should be the final annotation. The columns should be from the extra annotation.
#' @param type1 character. The cell type coming from the final annotation.
#' @param type2 character. The cell type of the extra annotation.
#' @keywords celltype.validation_fisher
#' @return A list with the 2x2 confusion matrix of type 1 and type 2 cells and the
#'   fisher p-value.
#'
celltype.validation_fisher<-function(tabl,type1,type2){
    
    if(is.null(type2)){
        type2<-type1
    }
    
    mat<-matrix(0,2,2)
    mat[1,1]<-tabl[rownames(tabl)==type1,colnames(tabl)==type2]         # is.type1 & is.type2
    mat[2,1]<-sum(tabl[rownames(tabl)==type1,])-mat[1,1]                # is.type1 & !is.type2
    mat[1,2]<-sum(tabl[rownames(tabl)!=type1,colnames(tabl)==type2])    # !is.type1 & is.type2
    mat[2,2]<-sum(tabl[rownames(tabl)!=type1,colnames(tabl)!=type2])    # !is.type1 & !is.type2
    
    colnames(mat)<-c(paste("is.",type1," (annotated)",sep=""),paste("!is.",type1," (annotated)",sep=""))
    rownames(mat)<-c(paste("is.",type2," (validation)",sep=""),paste("!is.",type2," (validation)",sep=""))
    res<-list(data=mat,fisher.test=fisher.test(mat)$p.value)
    
  return(res)
  
}


#' Applies the garnett classifier for a set of markers.
#'
#' Applies the garnett classifier for a set of markers.
#' @param iobj object. A Seurat object with the integrated and clustered data.
#' @param clusters numeric. The UMAP clusters stored in the meta.data of iobj.
#' @param garnett.markers.path character. The path/to/filename with the markers of interest.
#' @param species character. The species (eg Human or Mouse), if such a variable is present in
#'   the meta.data of iobj. Default is NULL.
#' @param region character. The region / tissue of interest (eg anterior_wall), if such a variable
#'   is present in the meta.data of iobj. Default is NULL.
#' @param exprs.cutoff numeric. The minimum expression to consider the gene as expressed. All values
#'   below it are truncated to 0. This mimics garnett's option 'expression above' and removes some
#'   noise prior classification. Defaut is 0.
#' @param slot character. One of RNA.data, RNA.scaled.data, SCT.data, SCT.scaled.data, integrated.data
#'   or integrated.scaled.data depending on which slot is to be chosen for garnett. Default is RNA.data.
#' @param num_unknown numeric. Number of unknown cells for the training. Default is 50.
#' @keywords garnett.classifier
#' @return The meta.data of iobj with garnett's classification results.
#'
garnett.classifier<-function(iobj,clusters,garnett.markers.path,species=NULL,region=NULL,exprs.cutoff=2,slot="RNA.data",num_unknown=50){
    
    if(!is.null(species)){
        ww<-which(iobj$seurat_clusters==clusters[1] & iobj$Species==species)
    } else {
        ww<-which(iobj$seurat_clusters==clusters[1])
    }
    
    if(length(clusters)>1){
        for(i in 2:length(clusters)){
            if(!is.null(species)){
                ww<-c(ww,which(iobj$seurat_clusters==clusters[i] & iobj$Species==species))
            } else {
                ww<-c(ww,which(iobj$seurat_clusters==clusters[i]))
            }
        }
    }
    ww<-unique(ww)
    d1<-iobj[,ww]
    if(!is.null(region)){
        d1<-d1[,d1$HTO_Annotation==region]
    }
    
    pd<-new("AnnotatedDataFrame", data = d1@meta.data)
    ff<-data.frame(Genes=rownames(d1),short_gene_name=GeneNames(rownames(d1),what="Ens"))
    rownames(ff)<-GeneNames(rownames(d1),what="Ens")
    fd <- new("AnnotatedDataFrame", data = ff)
    if(slot=="RNA.data"){
	mat<-as.data.frame(d1@assays$RNA@data)
    }
    if(slot=="RNA.scaled.data"){
        mat<-as.data.frame(d1@assays$RNA@scale.data)
    }
    if(slot=="SCT.data"){
        mat<-as.data.frame(d1@assays$SCT@data)
    }
    if(slot=="SCT.scaled.data"){
        mat<-as.data.frame(d1@assays$SCT@scale.data)
    }
    if(slot=="integrated.data"){
        mat<-as.data.frame(d1@assays$integrated@data)
    }
    if(slot=="integrated.scaled.data"){
        mat<-as.data.frame(d1@assays$integrated@scale.data)
    }



    mat<-as.data.frame(d1@assays$integrated@data)
    mat[mat<exprs.cutoff]<-0
    rownames(mat)<-GeneNames(rownames(mat),what="Ens")

    monocle_obj <- newCellDataSet(as.matrix(mat),
                               phenoData = pd,
                               featureData = fd)
    monocle_obj <- estimateSizeFactors(monocle_obj)
    pData(monocle_obj)$Size_Factor<-1

    classifier <- train_cell_classifier(cds = monocle_obj,
                                             marker_file = garnett.markers.path,
                                             db=org.Hs.eg.db,
                                             cds_gene_id_type = "SYMBOL",
                                             num_unknown = num_unknown,
                                             marker_file_gene_id_type = "SYMBOL")
    classified <- classify_cells(monocle_obj, classifier,
                               db = org.Hs.eg.db,
                               cluster_extend = TRUE,
                               cds_gene_id_type = "SYMBOL")

    return(classified)
    
}

#' Takes garnett's classification results and re-annotated the cells.
#'
#' Takes garnett's classification results and re-annotated the cells.
#' @param iobj object. A Seurat object with the integrated and clustered data.
#' @pram classified data.frame. The output of garnett.classifier().
#' @param id character. A filename for the plot.
#' @param outdir character. The path to store the plot.
#' @param unknown.name character. How to rename the cells labelled as unknown by garnett.
#' @param metadata.annotation.label character. A column name for the re-annotation which
#'   is stored an an extra column on the meta.data of iobj.
#' @keywords garnett.reannotation
#' @return An updated Seurat object with garnett's annotation and an associated plot.
#'
garnett.annotation<-function(iobj,classified,id,outdir,unknown.name,metadata.annotation.label){
    
    ann<-rep("Other",nrow(iobj@meta.data))
    ann[match(rownames(pData(classified)),rownames(iobj@meta.data))]<-pData(classified)$cluster_ext_type
    ann[ann=="Unknown"]<-unknown.name
    iobj@meta.data<-cbind(iobj@meta.data,ann)
    colnames(iobj@meta.data)[ncol(iobj@meta.data)]<-metadata.annotation.label
    Idents(iobj)<-iobj@meta.data[,ncol(iobj@meta.data)]
    keep<-sort(unique(ann[ann!="Other"]))
    cols<-c("#EEEEEE","#7882a4","#c0a080","#395b64","#2666cf","#b667f1",
            "#f76e11","#fc4f4f","#54bab9","#a1b57d","#2eb086","#313552",
            "#fa4eab","#f3c5c5")
    cols<-cols[1:(length(keep)+1)]
    names(cols)<-c("Other",keep)
    
    pdf(paste(outdir,id,".pdf",sep=""))
        p1<-DimPlot(iobj,order=keep)+scale_color_manual(values = cols)
        print(p1)
    dev.off()
    
    print(paste("Download plot: ",outdir,id,".pdf",sep=""))
    
  return(iobj)
}

